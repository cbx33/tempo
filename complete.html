
<h1>Introduction</h1>
<h2>How this book works</h2>
Welcome to Git In The Trenches or GITT, a book designed to help you both apply and understand the subtleties of Git, perhaps the most powerful version control system in use today.
This book is not supposed to be purely a technical reference.
If you are looking for something more reference in nature, you should look at ProGit, by Scott Chacon, published by Apress, as it is a wonderfully detailed look at many of the Git commands.
GITT is more of a scenario based book and by reading it, it is hoped that the experiences and scenarios that you encounter will help give ways to apply Git in practical situations.
Git is a hugely powerful system and once harnessed you are most likely going to wonder how you managed without it.<br><br>GITT follows the lives of some developers at a fictional company called Tamagoyaki Inc.
They are a small software outfit who write bespoke software for people.
It may be that you work for a company that is very similar to Tamagoyaki Inc and you are looking to implement a version control system for your own company, or it could be that you have been using a version control for a long time and are looking for a helping hand in applying the Git system to your needs.
Regardless of which box you fit into, GITT should provide you with some useful knowledge in a way that is designed to help you remember the scenarios and their associated solutions.<br><br>The book will follow the lead developer John, as he works to bring the company into line by implementing a version control system.
It's not something he's ever really used in earnest and he feels a little out of his depth.
It is hoped that your confidence and knowledge about both version control systems, and Git in particular, will grow whilst reading GITT.<br><br>The chapters are presented as weeks during the implementation of Tamagoyaki Inc's version control system project.
Each chapter spells a new week in the project and you will follow the life of John and his colleagues as they solve problems and learn tricks of the Git trade.
As well as presenting and solving common issues, the book will also be littered with breakout boxes, intended to tell you exactly what is happening inside Git at each stage.
This is intended to further your knowledge and understanding of this powerful piece of software.
At the end of each chapter are "John's Notes" which should build into a quick reference guide.<br><br>After each week, there is also the opportunity for you to delve further into the guts of what has been presented during the week with the <em>After Hours</em> sections.
These sections will take the knowledge that you have learned during the week and take it to a much deeper level, often showing diagrammatic ways of how commits take place, or even looking at the contents of files within the repository file structure itself.
These chapters are not meant to scare you, but are presented in the hope that you can reinforce what you have learned through the week by reading through more complex material.<br><br>With a system as complex as Git, knowing the commands is often not the only piece of the puzzle.
A good understanding of the underlying system, and how it reacts when you press that all important <strong>Enter</strong> button is essential if you want to be able to hold your cool in a crisis.
It is rather difficult to break Git.
There are many safeguards in place, but please be aware that you should try all of the items in the book in a test environment first, to ensure they perform, what you expect.<br><br>In the text of the book you will find numerous output listings like the one below.
These not only show you the commands that are being run to interact with the Git system, but also the output that you should expect to see.
You output will always differ to that which is in the book, if sometimes only slightly, but the output has been provided so that you can follow what is happening at each stage.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;ls&nbsp;-la</code><br&nbsp;/>
<code>total&nbsp;36</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;&nbsp;3&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-07&nbsp;19:12&nbsp;.</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;13&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-09&nbsp;20:02&nbsp;..</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;35&nbsp;2011-07-07&nbsp;19:12&nbsp;another_file</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;25&nbsp;2011-07-07&nbsp;19:12&nbsp;cont_dev</code><br&nbsp;/>
<code>drwxrwxr-x&nbsp;&nbsp;8&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-07&nbsp;19:17&nbsp;.git</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;2011-03-31&nbsp;22:15&nbsp;temp_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>References in the text to commit IDs and branch names will usually be written in <strong>bold</strong> and words of general interest will be <em>emphasised</em>.
Where commands of directory names are referred to in the text, they will be written in a <code class="ncode">monospace</code> font for easy distinction.
Throughout the book, you may also encounter <em>callout</em> boxes, like the one below.<br><hr><div id="calloutblock"><h3>Information - Callout boxes</h3>
These boxes are used to convey extra information, or to more accurately define terminology.
They are there to give you that little bit of extra information.
</div><hr><br>With the introduction over, let's first go through a quick setup guide and then find out why Tamagoyaki Inc even need a version control system in the first place.


<h1>Setting up</h1>
<h2>Making sure you have everything</h2>
<h3>Obtaining Git</h3>
Of course the most important tool we are going to need in this journey is Git itself and obtaining Git depends on the operating system you are using.
Though this book uses the Linux operating system throughout its examples,
almost all of the Git functionality described in this book can be performed no matter which operating system you choose.
You may find a few Linux commands used to perform operations like listing directory contents or echoing strings into files.
You operating system will likely have some functions that are similar, but these are not recorded here in the book.
The version of Git used throughout this book is version <code class="ncode">1.7.4.1</code>,
but generally you should obtain the latest version as the functionality and output should not differ significantly.<br><h4>Windows</h4>
For the Windows operating system, the easiest way to obtain Git is to use the <em>msysgit</em> package.
This package contains several helpful options other than the main Git binaries.
<em>msysgit</em> includes two context menus called <em>Git GUI Here</em> and <em>Git Bash Here</em>.
These components attach themselves to the right-click menu in Windows so that if you right click on a folder that contains a Git repository,
you can work on it either in a command line, or graphical way.
This will be discussed in more detail later in the book.
During the installation of the <em>msysgit</em> package, users are generally asked to make two choices, one is regarding their PATH setup and the other is to do with line endings.
For both of these it is recommended, at least at this stage, two choose the default options.
The Git implementation on Windows is currently considerably slower than implementations on Unix based systems.
However, it is still operates very well on the Windows platform.
The <em>msysgit</em> package is available from http://git-scm.com.<br><h4>Linux</h4>
For the Linux operating system, most Linux distributions come with Git packaged in some way.
In Ubuntu for example, one can install Git simply by running the command <code class="ncode">sudo apt-get install git</code>.
There are many extra items on Linux that you can install that are related to Git, however for the purpose of this book, just the core package and the gui are all that are required.
If you cannot find a package for your distribution, you can always either compile it from source, or take a look at http://git-scm.com to see if there is one available for your system.<br><h4>MacOS</h4>
For MacOS
If you are using the MacOS platform, Git can be found as a download from http://git-scm.com.

<h1>Week 1</h1>
<h2>Day 1 - "Things need to change"</h2>
<h3>Meeting the Team</h3>
If you're already a seasoned version control user, you may want to skip this chapter.
It's kind of like an introduction to why we even need version control systems in the first place.
This chapter looks at Tamagoyaki Inc's requirements and why they choose the VCS that seemed right for them.
Tamagoyaki Inc.&nbsp;creates software for turning a standard PC into a media center.
Their product ships to the end user and they rely very heavily on having a good presence at trade shows, in order to bring in sales.
The following conversation describes the events that led up to the defining "We need a VCS!" discussion.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
John sat at his desk and looked out of the window.
The rain was drizzling down the pane, but he didn't care.
It was a quiet Monday morning, the release had gone well on Friday and John was just thinking about implementing the new abstraction layer to the database he'd been asked for.
Through the music playing in his headphones he hardly noticed his boss, the chief designer and the CEO approaching his desk.<br><br>"John," shouted his boss, Markus, "get your team into the board room. Now!"<br><br>Things didn't look good.<br><br> * * * <br><br>"So, what we'd like to know John, is just how a bug that was supposed to have been..." the CEO back-tracked, "that was demonstrated as being fixed two weeks ago, made it into the final release of the software?"<br><br>"I'm sorry," John started, before being cut off.<br><br>"Sorry doesn't cut it John," said the CEO, Wayne Tobi,
"This was almost a major embarrassment for Tamagoyaki Inc.&nbsp;and we need to ensure this doesn't happen again. The demonstration at the trade show was close to a complete failure. Luckily someone had the good sense to bring a backup machine."
He turned to Markus.
"I want a report on my desk by the end of the day that states what the problem was, how it slipped through our fingers and what safe guards we are going to put into place so that things like this never happen again."<br><br>"Of course sir," Markus replied.
He was bright red with his own variety of embarrassment.<br><br>The room fell silent and a few minutes of silence passed before the meeting was drawn to a close and John and his team were allowed to leave.<br><br> * * * <br><br>"So, you're telling me that when Simon came back from holiday, he picked up an older copy of the library from the network share and pushed his latest code into that?" Markus was holding back the anger.<br><br>"It appears that way." Said John sullenly.<br><br>"Oh for crying out loud. How did this happen? Why wasn't he using the latest version? And why didn't QA pick up on it?" Markus looked across the meeting room at John.
"John, you need to make sure this doesn't happen again. Find a solution!"
</div><hr><br><h3>The trouble with storage</h3>
It's not like this situation is completely uncommon.
At one point or another most people have managed to pull old code from somewhere and mistakenly use it in place of the latest, up to date, version.
When storing code on network shares or on local disks, it's easy to lose sight of which version is which, no matter how good your naming convention is.
It's like trying to build one of the baked bean puzzles when you have three boxes of them and you tipped all the pieces into one box for simplicities sake.
Not so simple any more is it?<br><br>People have a tendency to use folder names which mean something to them.
However it doesn't necessarily follow that this name means something to another developer.
"Version 2.3 -- fixed bug a" only means something to you if you know what bug a is and something like "Version 2.3 -- fixed bug a(2)" is even worse.
Unfortunately allowing people to free form type their own descriptive file names will always lead to problems like this.
When these files are stored on a network share, the problem is exacerbated ten fold because there is often no fixed reference point.<br><br>So what's the solution? Well, in a large number of cases version control can make sure that not only is there a defined place for data to sit, and with a defined structure, but also that you have a full history of the code.
Accountability is very important in code development, especially when releasing software to customers.
In some situations a customer will even mandate that the code being developed for them is stored in a version controlled environment.
In this way, the customer can ask when a certain piece of code was edited, or when an addition first entered the code base.<br><h2>Day 3 - "A possible solution"</h2>
<h3>Version Control Nuances</h3>
There are many offerings for version control out there, Git, Mercurial, Subversion, CVS, and Bazaar to name but a few of the open source ones.
Perhaps a more pertinent question is just which version control system to use.
Each of them has their relative advantages and disadvantages, but some will be suited to certain tasks more than others.
Also, it's worth noting that if you are interacting with other pieces of software, or share some development with another set of developers, it is a good idea to enquire to see what they are using.
Usually you'll find collaboration, forking and patching a lot easier if you're using the same version control system as your upstream or partners.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"So really it seems like the only real solution to this problem bar Klaus' suggestions of reducing the workforce to only one developer, thank you Klaus," Klaus nodded in acknowledgement back to John, "is to implement a version control system."<br><br>Markus chewed his lip.
"I can see where you're coming from here John, but aren't version control systems really expensive?"<br><br>"There are a number of open source offerings we could take a look at first," piped up a new voice in the discussion, "some of them are supposed to be pretty good."<br><br>"Let's all go away, take a look at the various pros and cons and reconvene tomorrow to discuss the findings," said John.
"Sound fair?"
</div><hr><br>So now we need to take a look at some various features of version control systems and see what the various advantages and disadvantages are of each.
We are going to focus on Git here primarily, as this is what the rest of the book is all about.
It is assumed that if you are reading this book, you have most likely already made the decision about which version control system you are going to use.
So let's talk about the various features that are prevalent in most version control systems.<br><h3>Distributed Version Control</h3>
Version control systems usually fit into one of two categories; centralised, or distributed.
Git is a distributed version control system.
It has been designed to run almost everything at a local level.
This will become much more clear when we talk about other features of Git a little later on, but for now just understand that Git isn't tied to a centralised repository.
This is super powerful.
No Really!<br><h3>Branching</h3>
Most version control systems offer branching as part of their default feature set.
Branching allows developers to create in essence a clone of their repository and mess around with it, safe in the knowledge that they can switch back to the original whenever they need to.
This allows developers the freedom to experiment with all manner of things without being afraid of affecting the original/clean code base.<br><br>Git implements branching in a special way.
Most older version control systems implement branching in a way that almost creates a separate copy of the repository.
This is slow and cumbersome.
Git's branching method gives developers the ability to create multiple local branches to play with.
Due to its distributed nature, when pushing code to a more central location for others to pull from, developers can choose which branches they want to push, allowing code to be experimented with privately.<br><br>The implementation of branching in Git is fast.
Due to the fact that repositories are stored locally, the speed of creating a local branch is limited only by the speed of the disks on a local machine.
Git's implementation is so lightweight that even this speed factor is negligible.<br><h3>Staging</h3>
Git deals with committing changes into the repository differently to most other version control systems by the introduction of the staging area.
The staging area allows developers to prepare their commits before they are written to the repository.
Why is this useful or any different to any other version control system.
In Git you can make a change to a file, add it to the staging area, and then continue to make changes to that file, even though you have not yet actually committed anything.
It should be noted that it's not absolutely necessary to use the staging area, but it is there for developers wishing to utilise it.<br><h3>Workflow</h3>
Due to the way that Git has been designed, it's possible to use it in practically any work flow you can think of.
Three of the most common workflows are explained below, and Git can work in any of these, making it one of the more versatile systems out there.<br><h4>Centralised Workflow</h4>
In a centralised workflow, a single shared repository is used.
Multiple developers pull changes from here into local working copies, work on the local version, and then push it back up to the central location.<br><br>Git handles this workflow just like most other version control systems.
A developer can not push his changes until he has pulled everything up to the latest from the central repository and resolved any conflicts that may arise.<br><br>Using the centralised model for the workflow, each developer has the same level of access to the repository and is considered as <strong>important</strong> as each other.
For smaller teams, this method will work well, but as teams get larger, a centralised method may get tedious.
As more and more people start to access the same files, conflicts and other issues often begin appearing more often.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w1-d1.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 1</strong><br>Centralised Workflow</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br><h4>Integration Manager Workflow</h4>
The integration manager workflow is similar to the centralised workflow because there is still a <strong>blessed</strong> repository which everyone uses as a reference.
The difference here is that there is only one person who has the rights to push changes to the <strong>blessed</strong> repository.
This person is referred to as the Integration Manager.<br><br>This workflow is handled exceedingly well by Git.
Developers will work on their repositories locally and then once they are happy, will push their changes to a location where the Integration Manager can see them.
The Integration Manager will then review the changes that the developers have made and will merge them into his own local repository.
Once they are happy that everything is working well, the Integration Manager will push their changes to the blessed repository so that all the other developers can access the changes.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w1-d2.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 2</strong><br>Integration Manager Workflow</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br><h4>Dictator and Lieutenant Workflow</h4>
The dictator and lieutenant workflow is practically an extension to the integration manager workflow.
It is more suited to larger teams, where modules or sections of the code can be assigned to a <strong>Lieutenant</strong> who is responsible for blessing all of the changes to that particular section.<br><br>Once the Lieutenants are happy with their code, they make it available to the Dictator.
The Dictator then takes on a role similar to the Integration Manager from the previous model.
In the end, all of the changes are pushed to the blessed repository for the developers at the bottom of the tree to pull from.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w1-d3.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 3</strong><br>Dictator and Lieutenant Workflow</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br><hr><div id="calloutblock"><h3>Terminology - Blessed</h3>
A blessed, or canonical, repository is one which has the approval of the managers of the project.
The blessed repository is supposed to be the de facto standard where all other clones are made from.
If there is one place where code should be correct, it is the blessed repository.
If you are hosting the project in a public place, the blessed repository will usually be the one that is made available to people as a stable point for developing from.
</div><hr><br>The main thing to remember, is that Git can utilise any of these workflows.
This makes it a very flexible system, allowing you to work in whichever way you decide.<br><h3>Offline Committing</h3>
Perhaps one of the most useful and undervalued features of distributed version control systems is that of offline committing.
It may be undervalued because not all version control systems have it.
Offline committing is the ability to continue adding and committing files to the repository without being connected to a centralised repository.<br><br>When travelling or just simply when out of the office, developers and integrators alike are able to continue managing code, viewing histories, viewing diffs and committing changes to their repository.
This is all due to the fact that Git does 99When a repository is cloned, Git actually sets up a copy of the entire repository locally, giving developers the flexibility to work anywhere, without requiring access to the company network.<br><br>When returning to the office, the developers simply push their changes to their "public" space, be it local or to a blessed location, and all of the commits that have been made whilst they are away are then made available to the rest of the team, including all history and snapshots.<br><h3>Developer Interaction</h3>
One factor to consider when choosing a version control system, is that of developer interaction.
By this we are referring to the way in which developers use and interact with the version control system itself.
There are four main methods for VCS interaction<br><h4>Graphical User Interface Client (GUI)</h4>
A graphical user interface allows the developer, or user, to physically manipulate the repository using a mouse pointer and a graphically rich environment.
A GUI client will typically consist of separate application which is run when a user wants to make changes to a repository such as adding files or committing changes.<br><br>Some developers prefer having a separate client with which to interact with their repository, whilst others prefer to have things integrated a little more.<br><h4>Shell Extension Integration</h4>
Shell integration allows the user to interact with their repository using the graphical environment that they would usually use for manipulating files and performing routine directory maintenance.
One of the most common Shell Extensions for Git is the msysgit interface which integrates itself into Windows Explorer, allowing a user to right click on an entity whilst inside a git working tree, and be presented with a context sensitive menu for entering a shell for VCS operations.<br><h4>Command Line Interface (CLI)</h4>
The command line interface is favoured by many developers as they can script with it and can see exactly what is going on, often in much more detail that with a GUI.
The CLI gives total control over the system and it is worth noting that almost all version control systems start life as command line driven interfaces.
Why is this so? It can take a lot of time and effort to put all the options and nuances of a system into a GUI.
The CLI will almost always be the most powerful of all tools, especially where version control systems are concerned.<br><h2>Day 4 - "A decision is reached"</h2>
<h3>Analysing Your Requirements</h3>
The most important aspect of choosing a version control system, is to define your requirements.
These can be few, or they can be quite specific, let's see what John and his team decide are the most important aspects for them and ultimately what they decide upon.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Offline committing seems like it's a pretty useful thing to have." Mike said nodding.
"Especially with people like John travelling all the time."<br><br>"I have to admit, it would be nice to be on the plane, and be able to pull all the code together, knowing all of the history of each section," replied John.
"The branching in Git seems to be quite powerful as well."<br><br>"I must admit," chimed in Klaus, "I've used branching a bit in Subversion before and it was a lifesaver.
It's supposed to be super fast in Git too."<br><br>"And owing to the fact that Git seems to support several workflows, it means we can try them out and see how they work for us." Markus looked at the team.
"Are we settled on Git then?"<br><br>The team nodded and everyone walked out of the board room except John.
Things were about to get interesting for him.
Very interesting.
</div><hr><br>Since this book is all about Git, we won't delve too far into the workings or features of other version control systems.
Hopefully, this chapter has given you enough information to go and check out some of the other systems, if you feel the need to.
The main thing to bear in mind is that Git is a Distributed Version Control System or DVCS.
While this is so, it is equally important to remember that it can be used in the same workflow models as centralised version control systems.<br><br>John and his teams requirements are nothing special.
They are a smallish team looking to reap the benefits of having their code in a well organised system.
They are also looking to reorder their team functions and dynamics in order to fit around the version control system and really make it core to their development.<br><br>Version control is not a replacement for workflow.
It is not intended to make everything better.
If you have people going off and doing their own thing and being careless about the way they work, version control is not going to suddenly fix everything.
A tool is just that, a tool and version control is no different.
You can buy the messiest builder in the trade a nice shiny new tool box, but unless they have the mindset to want to change, you'll probably find that all the tools end up in the largest compartment at the bottom.<br><h2>Day 5 - "Working like a team"</h2>
<h3>Team Organisation</h3>
Now that we have the basics dealt with, let's take a little look at how John arranges his team, and see whether version control is going to work for them.
It is important that the team understands how the model should work, what they are expected to do and what level of access they have.
Most of the time people will get more frustrated about not knowing what they should or should not be doing, rather than that they do or don't have access to certain things.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
It was 4:36pm on the Friday and the table in the board room was littered with empty coke cans, pizza boxes and one Japanese bento lunchbox, owned by a particularly stubborn member of the team who had vowed never to eat pizza again.
It had been Marcus' idea to bring in the food reinforcement to help the discussions along.
The team were trying to decide how to organise their model.<br><br>"There's nothing to say we can't use a combination of the models is there?" asked Mike.<br><br>"I suppose not," said John.
"What did you have in mind." His glasses were slipping down his forehead now and he was getting pretty tired.<br><br>"Well, I figure, we basically have the software split into two parts. We have the library, which myself, Klaus and Jack work on. Then there's the UI elements which Simon, Martha and Rob handle. I know there are the tools which Eugene works on too."
Everyone had started to listen to Mike as he continued.
"John, you don't want to have to deal with the library component as this more Klaus' space. So why don't we have two dictators. Klaus and yourself have access to push up to the blessed repository. John can pull from his guys, Klaus from his and we end up with a good model for version control."<br><br>John raised his eyebrows, "Not bad Mike," he said, genuinely impressed.
After spending a few hours going through the various models and who was in charge of what, it felt good to have finally reached a decision.<br><br>"So, we start on Monday then?" asked Markus, who had been listening from the other end of the table.<br><br>"Indeed." Announced Klaus, "Monday we all become Gits!"
</div><hr>

<h1>After Hours Week 1</h1>
<h2>"History Lesson"</h2>
<h3>A Brief History of Version Control</h3>
<h4>The Very Early Days</h4>
Version control systems have been around for forty years (2011 at the time of writing).
During this time they have undergone an intense amount of change and have evolved into some of the most incredibly powerful tools utilised in software development today.
Chances are that in the early days you will have started off storing different versions of your source code and documents in separate files and folders.
You may have even archived them off to compressed storage files, like zip or tar.
Rest assured, you are not the first person to do this, and in 1972, someone called Marc J.&nbsp;Rochkind, decided to create system for storing revisions of documents and source code.<br><br>The system Marc created was called SCCS and stood for Source Code Control System, in essence probably the most apt description for what we mainly use a version control system for today.
SCCS was originally written for an operating system called OS/360 MVT and was later ported to C, and was used as the most dominant version control system for UNIX, until ten years later, when RCS was introduced.<br><h4>Time To Move On</h4>
In 1982, Walter F.&nbsp;Tichy released RCS, standing for Revision Control System.
It was intended to be a free and offer more functionality than SCCS.
RCS is still being maintained, as part of the GNU project, and at the time of writing is about to have its first new release, version 5.8, in over fifteen years.<br><br>However, RCS, like its predecessor SCCS, has no way of dealing with groups of files.
Essentially, each file has its own repository which is stored near to the file under a different name.
Whilst rather advanced, with primitive forms of branching, the interface, commands and version numbering have been described by some as rather cumbersome.
Enter some successors.<br><br>CVS (Concurrent Versions System) was created in 1986, and began life as a set of shell scripts to operate on multiple files, using RCS to perform the actual repository management.
As development continued, this way of working was dropped and CVS began operating on files itself, evolving into a version control system in its own right.
The current iteration of CVS was released in 1989 and on November 1 1990, version 1.0 was released to the Free Software Foundation for distribution.<br><br>CVS did not version file renames or moves at all as at the time, re-factoring - a process of modifying code to improve some non-functional attributes of the software, was often avoided and so the feature was not required.
CVS also did not support atomic commits.
An atomic commit is used by more modern version control systems to safe guard the database.
In essence atomic committing is the act of applying multiple changes in a single operation.
If any of the changes do not apply correctly, all others are reverted and the commit is aborted.
When designing CVS this was not seen as an obstacle, as it was thought by the developers that a server and network should have enough resilience that it would never crash whilst committing.<br><br>Whilst active development of CVS has apparently ceased, as of May 2008, it is worth taking note that CVS defined the model for branching that was included and refined in almost all version control systems since.<br><h4>Offering Commercial Support</h4>
Now that version control was advanced enough and people had begun to rely on VCSs in general, commercial offerings began to spring up.
Three prominent systems that were released within a short time of each other; ClearCase, VSS and Perforce.
All three of these are proprietary systems which were developed and filled a gap in the market for commercially supported systems.<br><br>VSS, originally developed by One Tree Software for several platforms, was continually developed by Microsoft, who bought One Tree Software in 1994, with the one caveat that Microsoft ceased development of all VSS on all platforms other than Windows.
VSS integrated into Visual Studio, Microsoft's Integrated Development Environment.
VSS has now ceased development, but ClearCase, now developed by a division of IBM, and Perforce are still being actively developed and maintained.<br><h4>The Millennium</h4>
The millennium brought with it a new breed of version control systems.
Subversion, or SVN as it is colloquially known as, was developed primarily to be a replacement and mostly compatible successor to CVS.
SVN was first released in 2000 and by 2001 was able to sufficiently host its own source code due to its own advancement.
In November 2009 Subversion was accepted into the Apache group and is currently developed and maintained by its community and by several commercial entities.<br><br>Subversion brought things to the table that previous version control systems did not.
As it was released as free software, in the same vein as CVS, it was widely adopted by the open source community and later into commercial environments for its vastly improved feature set.
For a start SVN offers true atomic commits.
This gave it a definite advantage over CVS as it was seen as a truly robust alternative.<br><br>It also brought in features like the tracking of files through renames and moves, including their entire version history and the versioning of symbolic links.
SVN moved with the times and introduced many other sought after features, such as HTTP serving, cheaper branching, efficient network operation and native support for binary files.<br><br>As with all version control systems, there are aspects that people dislike.
In Subversion, people often find the implementation of tags -- that is names that point to specific points in the history of a repository, an issue.
In SVN, a tag is actually a branch.
What makes this different to other systems such as Git and its predecessor CVS, which literally point to a specific commit in the tag, SVN actually creates a snapshot of the file system.
Although it employs relatively cheap branching which is lightweight on the repository, the tagging model used can be incredibly heavyweight on the client.<br><br>Another issue with the tagging model in SVN is that it holds no history information.
This makes it impossible, for example, to take two tags and try to find out all logged commits that occurred from one to the other.
This is the difference between using a copy as a tag, and implementing a reference.
Tags should also be read-only implicitly by their very nature, they should refer to a point in history.
However as tags are implemented as branches in SVN this is not the case.<br><h4>Introducing the Linus Factor</h4>
The Linux kernel was at one point maintained under a source control system called BitKeeper.
The decision, in 2002, to use BitKeeper for the management of the Linux kernel source was rather controversial, the main opposition being that BitKeeper was a proprietary system that was offered by BitMover.
At the time, BitMover offered certain open source projects the opportunity to use BitKeeper at no cost, so long as the community developers did not engage in the creation of a competing tool.<br><br>In April 2005, BitKeeper withdrew the free license that it had granted to the open source communities, after allegations of reverse engineering by some parties on an unrelated project.
Due to the way BitKeeper worked, and decisions made regarding licensing it became impossible for several key developers, and according to some reports including Linus himself, to actually own even a commercial version of BitKeeper.<br><br>It was due to these circumstances, that Linus Torvalds himself, decided to begin writing his own version control system that would enable him to have all of the features that he had had available to him with BitKeeper, the most important of these seemingly being a distributed environment.
Linus decided on a set of criteria, which along with a distributed environment, also included a robust safeguard against corruption, be it accidental, or malicious, and very high performance.<br><br>Git development began on the 3rd of April 2005, and by April the 7th, the project had been announced and was already able to host itself.
On June 16th, the release of the Linux kernel version 2.6.12 was managed by Git.
Junio Hamano, who had been a major contributor to the project, took over maintenance of Git in July, and by December had released version 1.0 to the community.<br><br>Interestingly enough, another project was also created as a result of this chain of events.
Mercurial or Hg as it is often known, is reported to have begun development on April 19th of the same year and was started by Matt Mackall with largely the same goals as Git.
Though Git was chosen to be the version control system used by the Linux kernel, Mercurial is actively used by many other projects and shares a very similar design and concept to Git.<br><h4>Design Changes</h4>
Git has some features which should be discussed here as many of them are different to every other version control system.
Perhaps one of the most important of these is the very strong emphasis on non-linear development.
Git provides many tools with which to work with many branches and merges, with a core principal being that changes will often be passed around more than they will be written.<br><br>Git is very fast.
Though for certain operations it may be slower than some of its peers, Git has been consistently proven to be faster than most.
This design implementation was essential as the Linux kernel is indeed a very large project.<br><br>When developing systems that offer any kind of security to an end user, it is essential to provide a way of auditing the history of the code, to ensure that no tampering has taken place.
Due to the way that Git is implemented, each SHA-1 hash, used to identify a particular commit, depends on the entire history of the repository.
What does this mean to someone viewing the repository? Once the repository is published, it is impossible for someone to tamper with the history without someone noticing.
This is called cryptographic authentication of history.<br><br>Of course the most important feature, and one which will be discussed in great detail later in the book, is that of distributed development.
The emphasis on non-linear development and the implementation of very cheap and fast branching, makes Git one of the best version control systems on the market for distributed development.<br><br>As mentioned previously every version control system has advantages and disadvantages and it would not be fair to make out that Git was without flaws.
Some that have been mentioned by people over the years are its particular steep learning curve for basic understanding.
Whilst it is agreeable to some degree, it is largely due to the fact that Git is a distributed version control system and inherently these systems are more complex in their implementation that others.
Another bug bear of some people, is the fact that Git will not track empty directories.<br><h4>Wrapping Up</h4>
Though there are many other version control systems out there that are being actively developed, such as Bazaar, Plastic and Darcs, to name but a few, we are going to end our historical tale here and continue with learning more about the Git version control system.
There is a plethora of information available on the Internet about version control, so if you want to find more information about any of the systems mentioned here, that would probably be the best place to start.

<h1>Week 2</h1>
<h2>Day 1 - "We are coders, we use Git!"</h2>
<h3>Setting Up the Environment</h3>
So now we are ready to begin delving into and actually using Git, right? Well, not exactly.
First we have to decide upon how the workflow model we have envisaged is implemented in our version control system.
With Git being so versatile, it's both a blessing and a danger.
It is a good idea to define from early on, exactly how you would like the developers, lieutenants and dictators to behave, before you begin actually committing any code.
Sometimes this isn't possible.
It's quite feasible that you have never used a version control system like Git before and you begin by muddling your way through.
This is normal, but if you are in charge of implementing this type of system for a professional environment, you should really consider first how this is going to work.<br><br>Conceptually, the model which was discussed previously is easy to imagine.
We have two dictators, who both have access to the blessed repository and then several developers, who are going to have their changes reviewed and included, by the aforementioned dictators.
The physical representation of the workflow model is summarised in the diagram below.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w2-d1.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 1</strong><br>Tamagoyaki Inc's Physical Structure</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>The physical structure is all well and good, but it doesn't determine exactly how the data is moved, just who is responsible for it at each stage in the process.
What is required, is a detailed analysis of where the data flows from and to.
A data flow diagram is useful, but not essential.
However, we will create a slightly different form of diagram to show how the data will be moved from one person to another.
Before we go ahead and look at the diagram, let's go back to the trenches to see how the guys are coping with their repository design.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"John, why are we all sat in here at 9:45am on Monday morning." Klaus whined.
"I haven't even ingested enough coffee to check emails yet, let alone meet with people."<br><br>John grinned, "I don't think any amount of coffee will help you there Klaus, it's your winning personality that will pull you through."
The rest of the team laughed and then subsided as John started drawing furiously on the board.
"So we have our physical model. We know which people are going to be in charge of things, but we don't know yet how to arrange our repositories."<br><br>"Good point," chimed Mike.<br><br>"So. Obviously we're going to have a blessed repository," said John, drawing a circle on the board.
He stepped back, one hand on chin.
"Then I would imagine Klaus and I will have clones of that repository on our local machines. We will then modify those and push our changes back up to the central copy."<br><br>"I thought Git didn't have a central copy?" asked Martha.
There were other moans and grunts.<br><br>"Well," said John,
"as far as I understand it, it doesn't. I mean Klaus and I will have local copies of the repository too. We will work on those and then sync our changes back to the server. It's a sync, moreover a copy. I think it's actually called a clone."
He nodded to himself, "And, since Klaus and I will hardly ever overlap on code, we shouldn't ever need to merge or deal with conflicts."<br><br>"But what about us monkeys?" asked Martha,
"Where do we get our clones from?"<br><br>"From the central server of course," Rob stated smiling.<br><br>"Yes," John said,
"but I think what Martha is trying to say, is how will you get your updates?"
He started to walk around the room, and one or two of the developers followed him as he reached the windows and leant on the sill.
"I guess you would merge your branch with the blessed one."<br><br>The room went silent and the only noise that could be heard was the rattling of the air conditioner in the ceiling above.<br><br>Simon spoke out, "Well, I was reading over the weekend about this thing called rebase and how in some cases a rebase is better than merging."<br><br>"What's rebase and how is it different to merging?" asked Mike.<br><br>"Well, rebasing is pretty darn clever. Think of it this way. You have an upstream branch, in this case, our blessed repository. You are happily making changes. When the upstream changes, you could merge the changes in from blessed. If you do this, you create a single commit which merges the changes in. It works, but..." he trailed off a little,
"it can cause problems in certain instances. A better way to handle it is with rebasing. Rebasing can take all the changes you have made, squirrel them away, pull down all the changes to bring it up to date, and then whack your changes on top.
It's not always the best choice, but we should consider it."<br><br>John breathed out, "It sounds pretty cool Simon, but one thing is abundantly clear, we need to learn more about the Git basics before we start delving into this merging and rebasing. Let's spend the rest of the day playing with some test repositories and reconvene tomorrow."
</div><hr><br>If you've never played with a version control system before it is a good idea to take some time to just play.
Pretty soon you'll have learnt the basics and will be in a position where you will want to put your newly honed skills into practice.
Though playing on test repositories is good, it is quite usual that you need to actually use the system in a real environment before real problems arise.
The rest of this chapter is a very quick introduction to Git.
It is presented as an introduction, because it is hoped and expected that the you will take some time out to get to know the system and how it works.
Knowing something about the underlying mechanisms of Git will definitely help you as you progress and will save you an awful lot of frustration later on when operations do not seem to function as you expect.
After Hours 2 focuses on the Git object model, something all Git users should have a basic understanding of.<br><h3>Initialising A Repository</h3>
The first thing we need to do is to understand two very important things:<br><div style="padding-left:10px;"><ol><li>How to create a Git repository</li>
<li>What a Git repository actually is</li>
</ol></div><br>The first of these is relatively easy to perform.<br><br><div id="codeblock"><code>john@satsuki:~$&nbsp;mkdir&nbsp;coderepo</code><br&nbsp;/>
<code>john@satsuki:~$&nbsp;cd&nbsp;coderepo/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;init</code><br&nbsp;/>
<code>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/home/john/coderepo/.git/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>If you are a Windows user, the above output may seem a little strange to you.
In the Linux world, the shell often has a much more descriptive prompt than on Windows.
In the case above, it takes the format <code class="ncode">&lt;user&gt;@&lt;host&gt;:&lt;current_directory&gt;</code>.
The ~ is a shortcut meaning <em>Home Directory</em>, so really <code class="ncode">~/coderepo</code> actually means <code class="ncode">/home/john/coderepo</code>.<br><br>What we've done here is create a new directory called coderepo, moved into it, and then run the <code class="ncode">git init</code> command.
The result of this command is a new directory in the coderepo directory called <code class="ncode">.git</code>.
This directory will hold a local copy of our entire repository.
This will allow us to create branches, merge changes, rebase things and ultimately push our changes to somewhere else.<br><br>Something that is crucial to the running of a repository, whether you are an administrator of Git, or a developer who is using it, is an understanding of how Git works.
It is fine to jump in and play with the repository and test the water, but before committing to using Git in a production environment, you should understand what Git actually does in the background in some detail.<br><br>During the writing of this book several people have told me that Git is one of the only version control systems where a good understanding of how the underlying system works is not just highly recommended, but bordering on essential.<br><br>Let us take a few minutes to talk about how Git works internally and how the data is actually stored.
Git doesn't store changes to files, but actual snapshots of files at specific points in time.
In fact, each time a commit is made, Git actually makes a record of how the entire filesystem looked at that point, even if only one file is changed.
It refers to files by calculating a SHA-1 hash of the file and using this as an ID, because the hash is unique to the contents of the file, it is easy to detect if a file has changed.
If the SHA-1 hash of a file changes, then the file must have been modified.<br><br>When a commit is made to the repository, Git stores a few things.
A commit object is created.
This contains, among other things, information about who made the commit, the parent of the commit and a hash that points to a tree object.
The tree object describes what the filesystem looked like at the time of the commit.
In other words the tree object, tells Git what files were in there.
Lastly, Git stores the files that were in the repository under their SHA-1 names in the objects directory.
Of course Git is super clever here because if you have exactly the same file in multiple commits, the SHA-1 hash of that file doesn't change and therefore Git only stores one copy of the file to save space.<br><br>The commit object is also referred to by an SHA-1 hash.
This is different to many other version control systems which use either a number that refers to the repository or a per file version number.
Getting used to seeing 40 character SHA-1 hashes can take a little time.
Saying "I need the commit referred to as bf81617d6417d9380e06785f8ed23b247bea8f6d," is certainly not as easy as saying you need revision 6.
However, Git handles these hashes well, and you can reference a commit using a few of the characters from the beginning, as long as those characters uniquely refer to that commit, i.e.,&nbsp;as long as your choice is not in any way ambiguous.<br><br>The above description may sound rather foreign to you.
If this is the case, you should really spend some time reading through it again and possibly even jump to the After Hours section at the end of this chapter.
Understanding the way Git stores objects is a rather important aspect of Git and though it may seem rather confusing at first,
learning this will help you later on in understanding more complex matters.<br><h2>Day 2 - "Making commitments"</h2>
<h3>Let's work on our repository</h3>
The most simple way of committing a file into the repository is to create it, or copy it to the working copy of our repository and use the commands below.
The working copy is the version of the repository we have currently checked out.
This terminology will be explained more later on.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;touch&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'My&nbsp;First&nbsp;Ever&nbsp;Commit'</code><br&nbsp;/>
<code>[master&nbsp;(root-commit)&nbsp;cfe23cb]&nbsp;My&nbsp;First&nbsp;Ever&nbsp;Commit</code><br&nbsp;/>
<code>&nbsp;0&nbsp;files&nbsp;changed,&nbsp;0&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>What we have done here, is to create a new blank file, using the unix <code class="ncode">touch</code> command and add it into the repository using the <code class="ncode">git add</code> command.
Windows users note, you will not have the touch command in your default command set, but if you are using Git Bash from the msysgit package, you should have it available to you.
Then we have committed it into the repository using the <code class="ncode">git commit</code> command.
Let's make a few changes to our working copy and see what the result is.
First we are going to add another two new files, then we are going to make changes to our original file and finally we are going to run git status to see what Git has to say about our changes.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"Change1"&nbsp;&gt;&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;touch&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;touch&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Changed&nbsp;but&nbsp;not&nbsp;updated:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;checkout&nbsp;--&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;discard&nbsp;changes&nbsp;in&nbsp;working&nbsp;directory)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	modified:&nbsp;&nbsp;&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;Untracked&nbsp;files:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;include&nbsp;in&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	my_second_committed_file</code><br&nbsp;/>
<code>#	my_third_committed_file</code><br&nbsp;/>
<code>no&nbsp;changes&nbsp;added&nbsp;to&nbsp;commit&nbsp;(use&nbsp;"git&nbsp;add"&nbsp;and/or&nbsp;"git&nbsp;commit&nbsp;-a")</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So we can see that <code class="ncode">git status</code> is reporting that there are changes to our first committed file, and that our second and third files are <strong>untracked</strong>.
Untracked files are ones which Git detects as being present in the working directory, but which haven't yet been added and there for upon running a commit, these files will not be added to the repository.
Notice that if we tried to run a commit now, nothing would actually be committed to the repository.
Even though there are changes to to my_first_committed_file, we have not asked Git to include these.
So, let's go ahead and do that, and at the same time we'll make a few changes to my_second_committed_file, and add those too.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"Change1"&nbsp;&gt;&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	modified:&nbsp;&nbsp;&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>#	new&nbsp;file:&nbsp;&nbsp;&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;Untracked&nbsp;files:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;include&nbsp;in&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	my_third_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we can see that one of the sections has changed to "Changes to be committed".
So this means that Git has recognised and remembered that we are expecting these files to be committed when we next run a <code class="ncode">git commit</code>.<br><h3>Committing the Uncommitted</h3>
<hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"John, what is going on here?" shouted Klaus from across the hallway.
The entire office had heard Klaus banging his hands down on the desk for the last fifteen minutes.
"John!" the shout turned into a scream.<br><br>"Calm down Klaus, I'm just coming."
John walked over to Klaus and pulled up one of the folding plastic chairs.
After a few minutes of fumbling he finally managed to take up his position next to an infuriated Klaus.<br><br>"John, Git is driving me crazy. I have added files to the repository and I keep running a commit, but the changes aren't getting put into the blasted repo."
Klaus was clearly distressed and John resisted the urge make jokes.<br><br>John pointed at the screen.
"Run a git status Klaus and I'll show you what the problem is."
</div><hr><br>To understand what Klaus was getting in a spin about, let's make a change to <code class="ncode">my_second_committed_file</code> now and see how this affects things.
Remember we have already added the file, but we haven't yet made a commit.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"Change2"&nbsp;&gt;&gt;&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	modified:&nbsp;&nbsp;&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>#	new&nbsp;file:&nbsp;&nbsp;&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;Changed&nbsp;but&nbsp;not&nbsp;updated:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;checkout&nbsp;--&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;discard&nbsp;changes&nbsp;in&nbsp;working&nbsp;directory)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	modified:&nbsp;&nbsp;&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;Untracked&nbsp;files:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;include&nbsp;in&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	my_third_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>How interesting! We now have three sections and one of our files appears twice under both Changes to be committed and Changed but not updated.
What does this mean? If you remember back, we spoke about a staging area.
This is one area in which Git differs to many version control systems.
When you <strong>add</strong> a file into the repository, Git will actually make a copy of that file and move it into the staging area.
If you then go ahead and change that file, you would need to run another git add in order for Git to copy your changed file into the staging area.
The most important thing to remember is that Git will only ever commit what is in the staging area.<br><br>So, if we go ahead and run our commit now, we will only have the changes marked in Changes to be committed appearing in our repository.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'Made&nbsp;a&nbsp;few&nbsp;changes&nbsp;to&nbsp;first&nbsp;and&nbsp;second&nbsp;files'</code><br&nbsp;/>
<code>[master&nbsp;163f061]&nbsp;Made&nbsp;a&nbsp;few&nbsp;changes&nbsp;to&nbsp;first&nbsp;and&nbsp;second&nbsp;files</code><br&nbsp;/>
<code>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;2&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>In our examples, we have used the syntax <code class="ncode">git commit -m 'Message'</code>.
This is a slightly special way of committing, it allows us to specify our commit log message on the command line.
If we wanted to, we could run the command git commit and this would open a text editor that we could use to input our commands.<br><br>Let us finish off our round of committing by using the <code class="ncode">git commit -a</code> option.
This commits all of the changes to files which are already tracked.
Consequently we do not have to specify the files with <code class="ncode">git add</code>, like we have had to previously.
Any file which has been modified and has previously been added to the repository, will have it's changes committed upon running that command.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Changed&nbsp;but&nbsp;not&nbsp;updated:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;checkout&nbsp;--&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;discard&nbsp;changes&nbsp;in&nbsp;working&nbsp;directory)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	modified:&nbsp;&nbsp;&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;Untracked&nbsp;files:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;include&nbsp;in&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	my_third_committed_file</code><br&nbsp;/>
<code>no&nbsp;changes&nbsp;added&nbsp;to&nbsp;commit&nbsp;(use&nbsp;"git&nbsp;add"&nbsp;and/or&nbsp;"git&nbsp;commit&nbsp;-a")</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Finished&nbsp;adding</code><br&nbsp;/>
<code>&nbsp;initial&nbsp;files'</code><br&nbsp;/>
<code>[master&nbsp;9938a0c]&nbsp;Finished&nbsp;adding&nbsp;initial&nbsp;files</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Untracked&nbsp;files:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;include&nbsp;in&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	my_third_committed_file</code><br&nbsp;/>
<code>nothing&nbsp;added&nbsp;to&nbsp;commit&nbsp;but&nbsp;untracked&nbsp;files&nbsp;present&nbsp;(use&nbsp;"git&nbsp;add"&nbsp;to&nbsp;track)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><h2>Day 4 - "Let's do this right, not fast"</h2>
<h3>Uh-Oh I Think I Made A Mistake</h3>
So now we are fairly well acquainted with adding files into the repository and performing commits.
In a short while we will learn about how to view the changes we have made and perform diffs against various objects.
Before we close out the week, we need to go back to the trenches one last time.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Rob, ya got a second?" asked Mike.<br><br>"Sure, what's up?" replied Rob from across the office.
"Gimme two secs to make this commit." The office went silent again whilst Rob's fingers darted across the keyboard.
"Ahh. Damn it!" shouted Rob.<br><br>Mike rose from his chair and walked over to Rob.
"What's up?"<br><br>"I just added a file into the staging area, but I don't want it there."
He shook his head, "Well not yet anyway."<br><br>Mike chuckled, "Sorry for interrupting dude."<br><br>"Nah, it's OK, I just need to know how to pull this file out of the index."<br><br>"Git reset," shouted a voice.
The stillness of the office was interrupted by a chair free wheeling across the floor.
The occupant of the chair was Klaus.
He seemed proud that he was finally getting to grips with things.
"You can use git reset to reset a file that's in the index."
He grabbed at the keyboard, "Here, lemme show you."
</div><hr><br>The git reset is great at removing things from the index that you don't want to be there.
Of course, it can do a great many other things, but for now, let us concern ourselves with the scenario presented above.
We are working away, and have added a number of files into the index ready for committing, when we discover that we are actually not ready to commit them.
In the following example, we are going to add the file my_third_committed_file and then remove it from the index.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	new&nbsp;file:&nbsp;&nbsp;&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice how my_third_committed_file is now ready to be committed to repository.
The problem is we need to add something more to it before we do.
Remember that when we run the git add command, we are copying the file from our working copy to the index.
If we decide we no longer want that file in the repository, we can run the following.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;reset&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Untracked&nbsp;files:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;include&nbsp;in&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	my_third_committed_file</code><br&nbsp;/>
<code>nothing&nbsp;added&nbsp;to&nbsp;commit&nbsp;but&nbsp;untracked&nbsp;files&nbsp;present&nbsp;(use&nbsp;"git&nbsp;add"&nbsp;to&nbsp;track)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We have discarded the file which was residing in the index.
This is very important to note.
We are not moving the file from the index back into our working directory, we are literally just deleting the file from the index.
Our working copy remains unaffected.
We could run the <code class="ncode">git reset</code> command without appending a file.
If we did this, all the files in the index would have been discarded.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"So, I think we are all agreed, I'll keep a version of the repository under Git version control.
Until everyone else feels comfortable with some of the more advanced features." John looked around the room for any disagreements but there were none.<br><br>"Agreed John," said Markus, "I'm pleased with how you guys are progressing, very pleased, but like John said, it's far better for us to take our time and to implement this correctly, than to rush it and to end up with something that we can't administrate and that we don't know how it works."<br><br>"So next week, I want you all to start playing with diffing and logs and don't forget we have an important release due too." John pushed his glasses further up his nose.
"The week after that we'll start looking at branching and by then we may be at the stage where we can implement our model."<br><br>Everyone nodded in agreement.
</div><hr><br><hr><div id="calloutblock"><h3>Knowledge - How do we change the commit message editor?</h3>
We spoke earlier about the configuration file and how it stores information about our Git instance.
Git can use any text editor you require, even a graphical one, though the need rarely arises.
As mentioned earlier, Git has a preference lever when talking about configuration.
First and foremost it will look in the repositories own 'config' file in the .git folder.
Then, it will look in the users <code class="ncode">~/.gitconfig</code> file.
Finally, Git will look in your distributions own global folder.<br><br>If we wanted to change the editor that Git would use to modify commit messages, we can either modify the files directly, or run a command similar to the following;<br><br><div id="codeblock"><code>git&nbsp;config&nbsp;core.editor&nbsp;"nano"</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>If we want the changes to apply globally, meaning it would affect all repositories we administrate as this user, unless overridden by a repository setting, we would run the following;<br><br><div id="codeblock"><code>git&nbsp;config&nbsp;--global&nbsp;core.editor&nbsp;"nano"</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>It is worth noting that you can also use the $EDITOR environment variable to accomplish the same thing.
Many people use this in preference to the modifying the Git configuration simply because many other programs honour this setting.
</div><hr><br>Now we know how to add files into the repository.
The question is, what do we do if we need to remove a file, or even rename it.
Well, git has some commands to help with that.
<code class="ncode">git rm</code> and <code class="ncode">git mv</code> delete and move files respectively.
Usually when you want to remove files from the repository, or move them, this is how you will handle it, but what if you have already deleted a tracked file manually? Well, you have two options.
You could run <code class="ncode">git commit -a</code>, but remember this will commit all changes to tracked files.
You could also run a <code class="ncode">git rm &lt;filename&gt;</code> with the name of the file you have just deleted.
Git will then push that change into the staging area ready for commit.
The same applies to moving a file<br><br>However, it is worth noting something in the way that Git handles renames.
Git does not track renames explicitly.
This means that by running the <code class="ncode">git mv &lt;source&gt; &lt;dest&gt;</code> command, you are essentially running a Linux <code class="ncode">mv</code> command, followed by the <code class="ncode">git rm</code> on the source file and <code class="ncode">git add</code> on the destination file.
Running the <code class="ncode">git mv</code> command is a shorthand way of doing just that.
It is worth playing with this to ensure that you understand what is happening.
As an exercise, inspect the repository after each command so that you understand at what point Git recognises your actions as a rename.<br><br>We have run through a few basic commands in Git.
If you are familiar with version control systems, then possibly the only real difference you will have noticed is that of the staging area.
It really is powerful, and allows you to organise and prepare your commits, so that they are both meaningful and coherent.<br><br>For Tamagoyaki Inc, their plan to implement version control was far too aggressive.
Most of the members of the team had never even used a version control system.
When deciding to implement version control, it is essential to ensure that you are doing it for the right reasons.
Version control is a tool to help you to keep things in order, but remember tools are nothing without process.
It is process that is key to the order.<br><br><h2>Summary - John's Notes</h2>
<h3>Commands</h3>
<div style="padding-left:10px;"><ul><li><code class="ncode">git add</code> - Add files into the index or staging area</li>
<li><code class="ncode">git commit </code> - Commit files into the repository, using text editor for commit message</li>
<li><code class="ncode">git commit -m '&lt;Message&gt;'</code> - Commit files into the repository, using the command line to supply commit message</li>
<li><code class="ncode">git commit -a</code> - Commit all tracked files into the repository that have changed, using text editor for commit message</li>
<li><code class="ncode">git reset &lt;path&gt;</code> - Remove file from index or staging area</li>
<li><code class="ncode">git status</code> - Show the status of tracked, changed, untracked files</li>
</ul></div><br><h3>Terminology</h3>
<div style="padding-left:10px;"><ul><li><strong>Branch</strong> - A way of working on the same set of code in parallel without modifications overlapping</li>
<li><strong>Commit</strong> - A group of objects and a tree in a Git repository</li>
</ul></div>

<h1>After Hours Week 2</h1>
<h2>"A Little Of Git's Internals"</h2>
<h3>A Look At Plumbing</h3>
This After Hours section is going to get a little deep.
For some of you it may be more information than you bargained for.
However, sometimes, when the worst happens, it is comforting to know that you at least have a basic understanding of what is happening under the hood.
These After Hours sections are designed to give you that knowledge.
They are for the people who are not just satisfied with knowing that things work, but they want to know <em>why</em> things work.<br><br>To start with, we are going to use the Git repository that we have been playing with in Week 2 and take a deeper look at what is actually inside a Git repository.
Let us view the directory structure, to see what has been created in the <code class="ncode">.git</code> folder.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo/.git$&nbsp;ls&nbsp;-la</code><br&nbsp;/>
<code>total&nbsp;52</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;&nbsp;8&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-03-31&nbsp;20:35&nbsp;.</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;&nbsp;3&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-03-31&nbsp;20:28&nbsp;..</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;&nbsp;2&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-03-31&nbsp;20:22&nbsp;branches</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;30&nbsp;2011-03-31&nbsp;20:34&nbsp;COMMIT_EDITMSG</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;92&nbsp;2011-03-31&nbsp;20:22&nbsp;config</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;73&nbsp;2011-03-31&nbsp;20:22&nbsp;description</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;23&nbsp;2011-03-31&nbsp;20:22&nbsp;HEAD</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;&nbsp;2&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-03-31&nbsp;20:22&nbsp;hooks</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;208&nbsp;2011-03-31&nbsp;20:35&nbsp;index</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;&nbsp;2&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-03-31&nbsp;20:22&nbsp;info</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;&nbsp;3&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-03-31&nbsp;20:27&nbsp;logs</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;13&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-03-31&nbsp;20:34&nbsp;objects</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;&nbsp;4&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-03-31&nbsp;20:22&nbsp;refs</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/.git$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><strong>branches</strong> - Though deprecated now, this folder stores shorthands for git pull, push and fetch commands, by creating a file, the name of which is passed to the command instead of the repository argument.<br><strong>COMMIT_EDITMSG</strong> - This file holds the last commit message that was displayed in the editor.<br><strong>config</strong> - This is the main configuration file for Git.
It is the first place git looks for upon invocation.
If this file is not present, Git will inspect <code class="ncode">~{</code>/.gitconfig}.
After this, Git will go to <code class="ncode">/etc/gitconfig</code>.
The file holds information about the remotes, tracking branches, push configurations and many more items.<br><strong>description</strong> - This is a simple text file which gives a description to a repository when being view via gitweb or similar.<br><strong>HEAD</strong> - This file is a pointer to the parent commit of your current branch.<br><strong>hooks</strong> - Scripts can be placed in here to perform operations at certain points during the commit process.<br><strong>info</strong> - The info folder contains some additional information about the repository<br><strong>logs</strong> - The logs folder holds various logs regarding Git's operation<br><strong>objects</strong> - The is the directory that holds all of the actual files that are stored in the repository.
The files are named by their SHA-1 values.
Inside the folder are a number of directories which make up the first 2 characters of the SHA-1 value.
The remaining portion of the SHA-1 hash is used to name the file.<br><strong>ORIG_HEAD</strong> - Hold the previous SHA-1 hash that HEAD pointed to.
This allows certain operations to go back, in the case of failure.
(Not present in our listing)<br><strong>refs</strong> - This folder holds the files that contain information about local branches, remote branches and tags.<br><br>More files and folders will appear here during the running of the repository as you begin to start using different features in Git.<br><br>The most interesting of the folders here is the <code class="ncode">objects</code> folder.
This folder as previously described holds all of the objects that are stored in the repository.
Now, what do we actually mean by objects.
As yet, we have not really defined what an object is.
We are going to look now at three types of object that Git places in this directory.
These are the commit, tree and blob objects.
We need a little more information as the names themselves do not fully describe what the item is.<br><div style="padding-left:10px;"><ul><li><strong>commit</strong> - A commit object is an object that describes a specific point in time.
Whenever you perform a <code class="ncode">git commit</code> from the command line, what you are actually doing is creating one of these objects in the repository.
This object stores information about the committer, the date, a link to the previous commit object and most importantly a link to the tree object of the current commit.</li>
<li><strong>tree</strong> - A tree object defines which files were physically included in the commit when it was added to the database.
The tree contains the name of the files that were present in the tree by recording their blob SHA-1 id and their filename.
Sub-folders of a directory will be referenced by another tree object.
In this way, a tree object will contain references to both tree objects and blob objects</li>
<li><strong>blob</strong> - A blob object actually contains the data that resides inside the file.
There is one object generated per revision of a file.
However, if exactly the same data resides in two separate files, then there will only be one object created and that object will be referenced by two trees.
In this way, multiple copies of the same file, or files which have not changed through multiple revisions are not stored multiple times.
Even though Git stores a complete snapshot of the file system at every revision.</li>
</ul></div><br>So, when we commit into the repository we create a commit object.
The commit objects houses links to a tree.
The tree object contains links to either blobs or trees.
Regardless, the structure of a basic repository may look something a little like Figure 1.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af2-d1.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 1</strong><br>Overview of objects in a repository</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>So now we know what a basic repository should look like, let us go through each stage of our committing in <strong>Week 2</strong> and see how it is built up at each stage.
Below is a consolidated list of all the objects in the repository.<br><br><div id="codeblock"><code>./09/5b9cda52807c9c11781ec0a4aee927787b61f1</code><br&nbsp;/>
<code>./16/3f06147a449e724d0cfd484c3334709e8e1fce</code><br&nbsp;/>
<code>./34/a5dff148e70c12310cda0800d6bcaf82530bdc</code><br&nbsp;/>
<code>./3a/d4cc3fe5a61c5563cb1b2ff3680d7e95be0fce</code><br&nbsp;/>
<code>./3f/fa7ab6dafef2bc38a70a39c53604c333ed4d7a</code><br&nbsp;/>
<code>./8d/664b74cce3a1f24d498d2d2bcc36e9915b5a65</code><br&nbsp;/>
<code>./99/38a0c30940dccaeddce4bb2eb151fba3a21ae5</code><br&nbsp;/>
<code>./cf/e23cbe0150fda69a004e301828097935ec4397</code><br&nbsp;/>
<code>./e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>In order to start rebuilding a picture of our repository, let us first find out what the first commit to our repository was.
Looking back in <em>Week 2</em> we can see the following trimmed output.<br><br><div id="codeblock"><code>[master&nbsp;(root-commit)&nbsp;cfe23cb]&nbsp;My&nbsp;First&nbsp;Ever&nbsp;Commit</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So we need to start with the object that begins <code class="ncode">cfe23cb</code>.
Remember in the description above about the SHA-1 hashes, the first two bytes are the directory name.
We are looking for a file that starts with the characters <code class="ncode">e23cb</code> and it will be in the directory called <code class="ncode">cf</code>.
By George! Looking at the list above, we can see that there is one file which fits the bill.
In fact it would be a little ambiguous if there were two.
It <em>could</em> happen that we would have two SHA-1 hashes that started with the same seven characters, but it's not likely.
The line we are interested in is listed below.<br><br><div id="codeblock"><code>./cf/e23cbe0150fda69a004e301828097935ec4397}</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>It would be nice if we could find out a little more about this object, and confirm that it is what we expect it to be.
to start with, let us run the Linux <code class="ncode">file</code> command on it, to see what it makes of it.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo/.git/objects/cf$&nbsp;file&nbsp;e23cbe0150fda69a004e301828097935ec4397</code><br&nbsp;/>
<code>e23cbe0150fda69a004e301828097935ec4397:&nbsp;VAX&nbsp;COFF&nbsp;executable&nbsp;-&nbsp;version&nbsp;5185</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/.git/objects/cf$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>The <code class="ncode">file</code> command, tells us that the file is actually of <code class="ncode">VAX COFF executable - version 5185</code> filetype.
This is obviously not correct.
Git stores its objects by Zlib compressing them, which is why it is difficult for the <code class="ncode">file</code> command to make any sense out of them.
Later in the book, you will find out exactly how to generate your own repository from scratch, but for now, let us just understand that Git first creates a header for the content, then adds the content to the header, creates the SHA-1 hash of such data and finally Zlib compresses it to store to disk.<br><h3>Out comes the wrench</h3>
Wouldn't it be nice if we could view the data that was inside the file simply, without having to write our own tools.
If you look through the Git man page, you will find one listed under the <strong>Interrogation</strong> section, called <code class="ncode">git cat-file</code>.
Anyone who has spent any time with Git will know what the <code class="ncode">cat</code> command does.
<code class="ncode">cat</code> is used to display the contents of files.
In Git, this command is used to display the contents, type or size of a repository object, be it either of type commit, tree or blob.<br><hr><div id="calloutblock"><h3>Information - What's with all the wrenches?</h3>
You may have noticed the less than subtle references to plumbing.
Git has two types of commands.
Those that are readily available to the end user, and those that are not.<br><br>The commands that are readily available to the end user are called Porcelain commands because they have been refined and are simple to use, think Tap and Sink.<br><br>Commands which get a little down and dirty with the details are called Plumbing commands because they are dealing with the primitive objects that make things work, think Pipes and Joints.
</div><hr><br>If we run this plumbing command against our object, and supply the <code class="ncode">-t</code> parameter, <code class="ncode">git cat-file</code> will tell us the type of the object.
If we run it with the <code class="ncode">-s</code> parameter, it will tell us the size.
Finally, running it with the <code class="ncode">-p</code> parameter we can see what the object actually contains.
Each of these has been demonstrated below.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;cat-file&nbsp;-t&nbsp;cfe23c</code><br&nbsp;/>
<code>commit</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;cat-file&nbsp;-s&nbsp;cfe23c</code><br&nbsp;/>
<code>215</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;cfe23c</code><br&nbsp;/>
<code>tree&nbsp;34a5dff148e70c12310cda0800d6bcaf82530bdc</code><br&nbsp;/>
<code>author&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;&nbsp;1301599664&nbsp;+0100</code><br&nbsp;/>
<code>committer&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;&nbsp;1301599664&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>My&nbsp;First&nbsp;Ever&nbsp;Commit</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Fantastic! We now have a way of confirming the objects are what we think they are.
If we were to run the command against every file in the repository, we would end up with a list that would look something like the one below.
Notice our commit object sat in the middle.<br><br><div id="codeblock"><code>./09/5b9cda52807c9c11781ec0a4aee927787b61f1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blob</code><br&nbsp;/>
<code>./16/3f06147a449e724d0cfd484c3334709e8e1fce&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commit</code><br&nbsp;/>
<code>./34/a5dff148e70c12310cda0800d6bcaf82530bdc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree</code><br&nbsp;/>
<code>./3a/d4cc3fe5a61c5563cb1b2ff3680d7e95be0fce&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blob</code><br&nbsp;/>
<code>./3f/fa7ab6dafef2bc38a70a39c53604c333ed4d7a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree</code><br&nbsp;/>
<code>./8d/664b74cce3a1f24d498d2d2bcc36e9915b5a65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree</code><br&nbsp;/>
<code>./99/38a0c30940dccaeddce4bb2eb151fba3a21ae5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commit</code><br&nbsp;/>
<code>./cf/e23cbe0150fda69a004e301828097935ec4397&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commit</code><br&nbsp;/>
<code>./e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blob</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now things start to get interesting.
Did you also notice the tree SHA-1 hash mentioned when we ran <code class="ncode">git cat-file -p</code>? This is the tree object that stores the file structure.
Why don't we run the command against that file too?<br><hr><div id="calloutblock"><h3>Note - Packing for a holiday?</h3>
It is worth noting that the objects noted above are not the only objects that you will find in the <code class="ncode">objects</code> folder.
Git will sometimes clean itself up and perform packing operations.
This is out of scope for this chapter though.
</div><hr><br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;34a5dff</code><br&nbsp;/>
<code>100644&nbsp;blob&nbsp;e69de29bb2d1d6434b8b29ae775ad8c2e48c5391</code><br&nbsp;/>
<code>&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We can now see a list of all files that were present in that snapshot of the working tree.
In our case this just happens to be one file.
Using our command one last time against the object name of the file, we can see the actual contents of the file.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;e69de29</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>At first glance one may consider it odd that there is nothing in there.
However, if we take a trip back in time and flick back to the first commit that we made to our repository, you will see that we never actually put any content in our file at all.
So, the object contains nothing.
Now we can draw up a diagram of our repository after the first commit.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af2-d2.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 2</strong><br>Overview of objects in repository after <strong>first</strong> commit</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>If we pick another commit object from the list and run our command on it we can see something new has appeared in the output.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;163f061</code><br&nbsp;/>
<code>tree&nbsp;3ffa7ab6dafef2bc38a70a39c53604c333ed4d7a</code><br&nbsp;/>
<code>parent&nbsp;cfe23cbe0150fda69a004e301828097935ec4397</code><br&nbsp;/>
<code>author&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;&nbsp;1301599979&nbsp;+0100</code><br&nbsp;/>
<code>committer&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;&nbsp;1301599979&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>Made&nbsp;a&nbsp;few&nbsp;changes&nbsp;to&nbsp;first&nbsp;and&nbsp;second&nbsp;files</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>This commit object has an extra field.
This field is the <code class="ncode">parent</code> field.
It tells Git which commit object is the parent to this one.
We were lucky in our guess that the parent object <strong>cfe23cb</strong> was actually the object we had first encountered.
By knowing this nugget of information, we can actually deduce that the object <strong>9938a0c</strong> was actually the next commit.
Checking in Week 2 will confirm this.
It seems we could now build a complete history of our repository so far.
If we did so, we would end up with a diagram that looked a little like the one below.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af2-d3.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 3</strong><br>Overview of objects in repository after <strong>three</strong> commits</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Hopefully you can see from this diagram that Git will reuse objects as discussed above.
This diagram describes the repository layout completely and if you correlate, we have correctly identified and accounted for each object in the repository.
Now we know how to traverse a repository.
In <em>Week 3</em> we find the Git commands to let us do that without having to break out the wrenches and resort to plumbing.
After all, why use a wrench to turn on a tap?


<h1>Week 3</h1>
<h2>Day 1 - "How do I see what's going on?"</h2>
<h3>Logging in Git</h3>
Perhaps the best feature of a version control system is the level of accountability that it offers if set up correctly.
What do we mean by this? People often mistake the word <strong>accountability</strong> for the word <strong>blame</strong>.
This is not true at all.
Accountability is key in understanding the events that led up to a particular bug being introduced, or a situation occurring.
How this is dealt with, is a up to the management teams, but accountability should not be something that is revered, it should be something that is looked upon as a tool to help define the cause of a problem.<br><br>By its very nature, a version control system is also a logging system.
Every time we committed something into the repository in the last chapter, we supplied a log message.
In fact, if we don't supply a commit message, let us see what happens.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Untracked&nbsp;files:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;include&nbsp;in&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	my_third_committed_file</code><br&nbsp;/>
<code>nothing&nbsp;added&nbsp;to&nbsp;commit&nbsp;but&nbsp;untracked&nbsp;files&nbsp;present&nbsp;(use&nbsp;"git&nbsp;add"&nbsp;to&nbsp;track)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;"</code><br&nbsp;/>
<code>Aborting&nbsp;commit&nbsp;due&nbsp;to&nbsp;empty&nbsp;commit&nbsp;message.</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;reset&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Git will actually not allow you to commit with a blank message.
This is actually fantastic news, as people are far less likely to write a useless message than they are a blank one.
It is very important that when using a version control system you write in a useful commit message.
If you fixed a bug, say so.
If you added a new function, why not put that in too.
When someone wants to find out what a certain commit was for, or even when you come back to the project six months later and realise you've forgotten everything, log messages are crucial in piecing back together a history of development.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"So John, I've been committing and all that," started Rob,
"but how do I see the history of what I have done."<br><br>"It's really pretty simple," replied John,
"But it really depends on what you want to know."
Rob placed his thumb and forefinger onto his chin.
"Well, for now, I just want to see a list of all of my commits."<br><br>"That one's the simplest of all."
</div><hr><br>At its simplest, <code class="ncode">git log</code> will give an output of all of the commits that have been applied to the current branch.
Depending on what type of machine you are using it on, the output from <code class="ncode">git log</code> will be navigable, usually using the up and down arrows, with 'q' used to quit.
Let's have a quick look at the output of our test repository and see what the log messages look like.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log</code><br&nbsp;/>
<code>commit&nbsp;9938a0c30940dccaeddce4bb2eb151fba3a21ae5</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;20:34:23&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Finished&nbsp;adding&nbsp;initial&nbsp;files</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;163f06147a449e724d0cfd484c3334709e8e1fce</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;20:32:59&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Made&nbsp;a&nbsp;few&nbsp;changes&nbsp;to&nbsp;first&nbsp;and&nbsp;second&nbsp;files</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;cfe23cbe0150fda69a004e301828097935ec4397</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;20:27:44&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;My&nbsp;First&nbsp;Ever&nbsp;Commit</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>The <code class="ncode">git log</code> command shows us a chronological list of all of the commits to the repository and also gives us several more important pieces of information.
In total there are four pieces of information displayed by default.<br><div style="padding-left:10px;"><ul><li><strong>commit</strong> - This is the SHA-1 hash of the commit object that is stored inside the repository.
You can find more information about this in the <em>What's inside the Git repository?</em> section <em>Week 2</em>.
This is how we refer to the commit.
If someone asked you in what commit you <em>Made a few changes to first and second files</em>, you could reply that you did that in commit 163f0.
As explained earlier, it is good to remember that you don't need to remember or type out the whole <strong>163f06147a449e724d0cfd484c3334709e8e1fce</strong>, only the first part is required.
Generally, the first five characters will do.</li>
<li><strong>Author</strong> - This is the name and email address of the author of the commit.
When we begin to look at merging, you will see that the author of a commit, is not necessarily the <em>committer</em> of the commit.
If you want to find out more about how to set these options, see the breakout box in this Week, called <em>Changing your identity</em>.</li>
<li><strong>Date</strong> - The date is simply the date at which the commit was created.
Again, note that when we start looking at merging, the date will be the date the commit was created, not the date it was merged into the repository.</li>
<li><strong>Commit Message</strong> - This is the log message that was added along with the commit when it was created.
Hopefully you can now see how important it is to create useful and meaningful messages in here.</li>
</ul></div><br><hr><div id="calloutblock"><h3>Note - Note on Commit IDs</h3>
Please note, that if you are following the commits and changes on your local computer, you may not and probably will not have the same commit IDs as are presented in this book.
You are advised to use them here to follow what is happening, but to substitute them with your own values, when you start working with the rest of this chapter.
</div><hr><br><hr><div id="calloutblock"><h3>Note - Changing your identity</h3>
Particularly when working with other people, or when publishing your repository to a public location, it's a good idea to make sure people know who you are and how to get in contact with you.
Every time you make a commit to a repository, Git gives the opportunity to take note of who posted the commit.
When you first install Git, it probably won't have the correct information in there for you, so it's important that you take the time to set this up.<br><br>To set up your name and email address, we need to modify use <code class="ncode">git config</code> again.<br><br><div id="codeblock"><code>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;user.name&nbsp;"John&nbsp;Haskins"</code><br&nbsp;/>
<code>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;user.email</code><br&nbsp;/>
<code>"john.haskins@tamagoyakiinc.koala"</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>That's it.
Now by default, Git will use this setting whenever you commit to a repository, unless you override it by locally modifying the repository's <code class="ncode">.gitconfig</code>.
</div><hr><br><h2>Day 2 - "But I need more information"</h2>
<h3>Digging a little deeper</h3>
<hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"I know John, and next time I will make a note of it, but right now, I'd really like to know where this file got changed," Klaus pointed at the piece of paper containing a print out, "specifically when this function was introduced."<br><br>John smiled.
His hands danced over the keyboard as he finished compiling an email.
"And you've no idea when this was added at all?" he asked.<br><br>"No, sorry John, I don't."
He pondered, "I guess I could write a script to untar all the versions we've created in the last week and search through them."
He sighed, "Can't the wonderful Git help us out here?"<br><br>A head popped up over the cubicle wall.
"You wanna find out when a function was introduced to a file?"
It was Rob.
"After John showed me the basics, I went and read up on it a little.
Git has some really powerful searching within the log tool."<br><br>"Well come on then," blurted Klaus,
"Don't keep me hanging on."<br><br>A chime of the popular 1966 hit sprang out in the office.<br><br>Klaus pulled a hand down over his face, "Oh don't you all start!"
</div><hr><br>Git can actually do some rather powerful searching to assist a developer in their daily tasks.
It would have been useful if the particular item that was being searched for had been included in the log, but sometimes, things either get missed, or there are just too many changes introduced in one commit to list them all.<br><br>In these instances, the <code class="ncode">git log -S&lt;string&gt;</code> command comes to our aid.
This command will search through the commits in a repository and will return a list of commits which introduced or removed a specific string into the repository.
First of all, let's run this against our test repository.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;-SChange1</code><br&nbsp;/>
<code>commit&nbsp;163f06147a449e724d0cfd484c3334709e8e1fce</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;20:32:59&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Made&nbsp;a&nbsp;few&nbsp;changes&nbsp;to&nbsp;first&nbsp;and&nbsp;second&nbsp;files</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>You can see that <code class="ncode">git log</code> has shown us the commit that instantiated the change.
As you can imagine, when using a large code base, this tool can be invaluable.
It allows us to pinpoint a specific moment when a certain string of text entered the repository.
When running this against a very large repository, this could take a long time, and so the ability to shrink the search scope down will result in a much faster result.
To do this we can append a path to our previous command.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;-SChange2&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;-SChange2&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>commit&nbsp;9938a0c30940dccaeddce4bb2eb151fba3a21ae5</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;20:34:23&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Finished&nbsp;adding&nbsp;initial&nbsp;files</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>If you remember from our committing back in Week 2, we added the string <code class="ncode">Change2</code> to the second file but not the first.
So the first time we run this command, it fails, as we are searching against <code class="ncode">my_first_committed_file</code>.
The second time we run it, we are searching against <code class="ncode">my_second_committed_file</code> and this is where we see a result.
Commit <strong>9938a0</strong> contains the commit we are looking for.<br><h2>Day 3 - "What actually changed?"</h2>
<h3>Doing the diff dance</h3>
Knowing what the committer thinks they committed is brilliant.
However, sometimes it's just not enough.
The reason for this is stated fairly precisely in the first sentence of this paragraph, so let us add a little formatting to bring out the real meaning.
Knowing what the committer <em>thinks</em> they committed is brilliant.
By looking at the commit message we only know as much as the committer wants us to.
If they are the helpful sort, this will probably be all that we need, most of the time.
On the other hand there is always the situation where you'd like to know a little more about what was actually placed into the repository.<br><br>The <code class="ncode">git diff</code> command can show us exactly that.
For more information about diff in general, see the diff breakout box in this chapter.
Think of a diff as an easy way of looking at the differences between two files, surrounded by a little context.
This can often be enhanced by a visual diff viewer, but for now, let's stick with our simple text based <code class="ncode">git diff</code>.<br><br>If we want to find out what the changes are between our current commit and one of the previous ones, we can write a command like the one below.
Notice that below, <strong>163f06</strong> refers to the second commit that we made to the repository.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff&nbsp;163f06</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_second_committed_file&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>index&nbsp;3ad4cc3..095b9cd&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/my_second_committed_file</code><br&nbsp;/>
<code>+++&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Change1</code><br&nbsp;/>
<code>+Change2</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>What this is telling us, is that between <strong>e86dd</strong> and our current commit <strong>6ca16</strong>, we added the line <em>Change2</em> to the file <code class="ncode">my_second_committed_file</code>.
We can see this by the preceding <code class="ncode">+</code> on the line <code class="ncode">Change2</code>.
Let's make a few changes to our repository and see how the diffs look.
We're actually going to make a few changes to the files using a text editor so that you can't see what we've done.
Then, hopefully, when we run the <code class="ncode">git diff</code> you'll be able to see clearly what has happened.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;HEAD~1..HEAD</code><br&nbsp;/>
<code>commit&nbsp;a022d4d1edc69970b4e8b3fe1da3dccd943a55e4</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;22:05:55&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>The command <code class="ncode">git log HEAD~{</code>1..HEAD} tells Git to show us the git log for all commits between <code class="ncode">HEAD~1</code> and <code class="ncode">HEAD</code>.
The notation used here is something new to us, but seeing as HEAD points to the most current commit, HEAD~1 points to the commit previous to HEAD.
This is how we tell Git to show us only the most recently commit.<br><br>As it turns out, John Haskins didn't really create a very meaningful log message.
<em>Messed with a few files</em> is pretty unhelpful in the grand scheme of things.
So let's be thankful that this isn't Tamagoyaki Inc's core repository and take a look at what actually happened in the commit <strong>a022d4</strong>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff&nbsp;HEAD~1..HEAD</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_second_committed_file&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>index&nbsp;095b9cd..c9887f8&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/my_second_committed_file</code><br&nbsp;/>
<code>+++&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>-Change1</code><br&nbsp;/>
<code>-Change2</code><br&nbsp;/>
<code>+Changed&nbsp;this&nbsp;file&nbsp;completely</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_third_committed_file&nbsp;b/my_third_committed_file</code><br&nbsp;/>
<code>new&nbsp;file&nbsp;mode&nbsp;100644</code><br&nbsp;/>
<code>index&nbsp;0000000..5d27866</code><br&nbsp;/>
<code>---&nbsp;/dev/null</code><br&nbsp;/>
<code>+++&nbsp;b/my_third_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-0,0&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>+Addition&nbsp;to&nbsp;the&nbsp;line</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, we have several things going on here, so let's take each of them in isolation and see what is going on.
We are going to dissect the diff to see what each section means.<br><br><div id="codeblock"><code>diff&nbsp;--git&nbsp;a/my_second_committed_file&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>This first line tells us that we are dealing with <code class="ncode">my_second_committed_file</code>.
This is showing that we are comparing the first revision, or a, against the second revision, b.<br><br><div id="codeblock"><code>index&nbsp;095b9cd..c9887f8&nbsp;100644</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>This second line actually tells us the beginning of the object IDs, as they are stored in the repository.
Note that these IDs are not the commit IDs, but the actual blob IDs that Git uses to refer to the file.
For more information on this, checkout the <em>Object's living in harmony</em> breakout box.<br><br><div id="codeblock"><code>---&nbsp;a/my_second_committed_file</code><br&nbsp;/>
<code>+++&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>The next few lines are telling us which is the original file, and which is the new file, so we can use this as a reference.<br><br><div id="codeblock"><code>@@&nbsp;-1,2&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>-Change1</code><br&nbsp;/>
<code>-Change2</code><br&nbsp;/>
<code>+Changed&nbsp;this&nbsp;file&nbsp;completely</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we see some lines which are generally referred to as a hunk.
The hunk has two important pieces of information.
Section <code class="ncode">-1,2</code> tells us that in the original file, we are looking at the original file (<code class="ncode">-</code>), that the starting line where the change takes place is line 1 (<code class="ncode">1</code>) and that the hunk applies to two lines (<code class="ncode">2</code>).
The next section tells us that in the new file, the change takes place as line 1, and because the comma and remaining number are omitted, we can infer that the hunk applies to only 1 line.<br><br>The three following lines show what actually took place.
Strings <code class="ncode">Change1</code> and <code class="ncode">Change2</code> were deleted from the file, whereas <code class="ncode">Changed this file completely</code> was added to the file.<br><br>Looking at the next diff segment, we can see it applies to a different file.
Essentially this hunk is no different to the last, the only interesting portion is shown below.<br><br><div id="codeblock"><code>new&nbsp;file&nbsp;mode&nbsp;100644</code><br&nbsp;/>
<code>index&nbsp;0000000..5d27866</code><br&nbsp;/>
<code>---&nbsp;/dev/null</code><br&nbsp;/>
<code>+++&nbsp;b/my_third_committed_file</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>This shows us that <code class="ncode">my_third_committed_file</code> is actually a new file.
Notice the <code class="ncode">/dev/null</code> and the <code class="ncode">0000000</code> object ID, indicating that there was no original file.<br><h3>Diffing Over A Range</h3>
All the operations that we have performed so far have been on one commit.
Whilst important and valuable, it may be that you want to see an entire range of changes.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"I'm still not entirely convinced about this John," said Martha.
"I've been playing around with Git, like you asked me, but it still just seems like we're replicating the work that we used to do with the readme changelogs and the tarball files."<br><br>She sat down on a near-by chair and wheeled it over to John's desk.
She surveyed the desk for an inch of vacant real estate before finally resting her elbow on the corner of his desk next to a copy of Pro Git.<br><br>"Well, actually Martha, I can see exactly what you mean. Up until now, there is no difference between the old and the new process. I'm still in control of all the versions, so nothing has really changed."
He thought long and hard, "Tell ya what. Why don't you give me an operation that you've always wanted to do against our code tree tarballs easily."<br><br>"Easy," she snapped back,
"I want to know what changes were made for the last two weeks whilst I had been away on holiday."
She smiled an almost mischievous smile as she referenced 'The Incident', as it had become known throughout the office.<br><br>"Easy," John quipped, mimicking her mannerisms.
The two broke out in laughter.
"We can use git log for that, and I think there are some date options too. Let me check the man page."
</div><hr><br>Looking at the man page for git log is a mind trip for the uninitiated.
Weighing in at over 600 lines of text, it is abundantly clear that this tool does a whole lot more than viewing a simple history of commits to the repository.
It is well worth taking the time to read through the current available options by typing <code class="ncode">man git log</code> on the command line.
If you have the documentation installed, this will yield the <em>man</em> page for <code class="ncode">git log</code>.<br><br>Listing all commits in our repository is useful, being able to filter this output is fantastic.
This is one area in which the developers of Git have placed a great deal of time and effort.
For example, we can use <code class="ncode">git log</code> to not only show us the commit message, but also provide a diff output as well.
This means that for each commit entry in the output, we will see a diff as well.
Now, whilst we are further empowered by having the diff output in chronological order for each commit, we can take things further by filtering the commits.<br><br>Suppose we want to view all the commits that we made in the last week, typing the following into the command line in our test repository yields the following result.
<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;-p&nbsp;--since="last&nbsp;week"</code><br&nbsp;/>
<code>commit&nbsp;a022d4d1edc69970b4e8b3fe1da3dccd943a55e4</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;22:05:55&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_second_committed_file&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>index&nbsp;095b9cd..c9887f8&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/my_second_committed_file</code><br&nbsp;/>
<code>+++&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>-Change1</code><br&nbsp;/>
<code>-Change2</code><br&nbsp;/>
<code>+Changed&nbsp;this&nbsp;file&nbsp;completely</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_third_committed_file&nbsp;b/my_third_committed_file</code><br&nbsp;/>
<code>new&nbsp;file&nbsp;mode&nbsp;100644</code><br&nbsp;/>
<code>index&nbsp;0000000..5d27866</code><br&nbsp;/>
<code>---&nbsp;/dev/null</code><br&nbsp;/>
<code>+++&nbsp;b/my_third_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-0,0&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>+Addition&nbsp;to&nbsp;the&nbsp;line</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice we get to see the diff that was presented before when we ran our <code class="ncode">git diff HEAD~1..HEAD</code> command, but this time, as we have used the git log command instead, we get to see the diff output as well.
This is what the <code class="ncode">-p</code> flag is for.
Take note of the way we have specified the time period that we are interested in.
The section <code class="ncode">--since="last week"</code> tells Git to filter the output and show only the entries that were committed within the last week.<br><br>This type of filtering can be exceedingly useful to a developer.
Often when problems arise, you do not have a defined point in time that you know it was last working.
However most of the time, you can say with some certainty, "I know it was working two weeks ago".
Using the methods described above, will give the user all of the changes, categorised by commit, that occurred in those two weeks, allowing them to narrow down the scope of exactly where to begin looking for the offending changes.<br><br>If the developer can further categorise the issue, such as, "I know which file the change must have occurred in", then the following example will demonstrate just how easy it is to filter the results even further.
Even in the simplified example repository that we have been using, running this command filters the output to a single file.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;-p&nbsp;--since="last&nbsp;week"&nbsp;--&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>commit&nbsp;a022d4d1edc69970b4e8b3fe1da3dccd943a55e4</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;22:05:55&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_second_committed_file&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>index&nbsp;095b9cd..c9887f8&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/my_second_committed_file</code><br&nbsp;/>
<code>+++&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>-Change1</code><br&nbsp;/>
<code>-Change2</code><br&nbsp;/>
<code>+Changed&nbsp;this&nbsp;file&nbsp;completely</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;9938a0c30940dccaeddce4bb2eb151fba3a21ae5</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;20:34:23&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Finished&nbsp;adding&nbsp;initial&nbsp;files</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_second_committed_file&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>index&nbsp;3ad4cc3..095b9cd&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/my_second_committed_file</code><br&nbsp;/>
<code>+++&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Change1</code><br&nbsp;/>
<code>+Change2</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;163f06147a449e724d0cfd484c3334709e8e1fce</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;20:32:59&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Made&nbsp;a&nbsp;few&nbsp;changes&nbsp;to&nbsp;first&nbsp;and&nbsp;second&nbsp;files</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_second_committed_file&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>new&nbsp;file&nbsp;mode&nbsp;100644</code><br&nbsp;/>
<code>index&nbsp;0000000..3ad4cc3</code><br&nbsp;/>
<code>---&nbsp;/dev/null</code><br&nbsp;/>
<code>+++&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-0,0&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>+Change1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>See how easy that is.
Note, the <code class="ncode">--</code> is necessary to tell Git the following string is a path.
We no longer have the information for <code class="ncode">my_third_committed_file</code> present in the output.
We have filtered everything out but the information we are looking for.
When you are up against deadlines, pouring through pages and pages of diffs and changes can be incredibly time consuming.
Having the tools available to cut that output down to just the relevant material can be life saving.<br><h2>Day 4 - "Finding a good reference point"</h2>
<h3>Tag you're it!</h3>
During software development, a project will generally get to a point where it is ready to be released to people outside of the development team.
When this grand day occurs, it is crucial that both the developers and the users have a reference point with which to refer to the state of the code.
Having a code name or a version number means that within a very short period of time, both parties can converse about a problem, safe in the knowledge that they are on the same page.<br><br>In most version control systems, the word tagging is used to describe a reference point in the code's history.
A tag will usually refer to a single commit and labels that particular commit with a name that is easier to remember than a standard version number or SHA-1 hash.
The tag name used can be a codename, or a version number.
Often people will follow a simple numbering scheme, like <code class="ncode">v1.9</code>.<br><br>In this example, the <code class="ncode">1</code> may refer to the major version number, and will denote a family of versions, often only changing a few times in a projects lifetime.
The <code class="ncode">9</code> is a minor version number and can refer to a much more frequent release schedule.
You may also see textual items being appended to this version string, like <code class="ncode">rc</code>, <code class="ncode">b</code>, and <code class="ncode">a</code>, denoting <em>Release Candidate</em>, <em>Beta</em> and <em>Alpha</em> respectively.<br><br>Git implements tags in a very elegant way.
A tag is simply a label in Git that points to a single commit object.
The tag name can then be used in place of the SHA-1 to refer to a point in the repositories history.
Due to the simplicity of tags, it is also possible and very simple to tag a commit that occurred way into the past.
Let us take a look at a simple tag example.
We will make the current point in the repository <code class="ncode">v1.0a</code>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;tag&nbsp;v1.0a</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>On its own, this output from <code class="ncode">git tag</code> doesn't really tell us much, but running the following, shows us a little more information<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;rev-parse&nbsp;v1.0a</code><br&nbsp;/>
<code>a022d4d1edc69970b4e8b3fe1da3dccd943a55e4</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>By running the <code class="ncode">git rev-parse</code> with the tag name <code class="ncode">v1.0a</code>, Git has returned us the SHA-1 hash of the commit we were referring to.
If we look back up at the earlier output, we can see that the most recent commit into the repository was indeed <strong>a022d4d1edc69970b4e8b3fe1da3dccd943a55e4</strong>.
To give us something to work with, let's tag the commit <strong>163f06...</strong> with the tag name <code class="ncode">v0.9</code>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;tag&nbsp;v0.9&nbsp;163f06</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now, we can do the following;<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff&nbsp;v0.9..v1.0a</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_second_committed_file&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>index&nbsp;3ad4cc3..c9887f8&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/my_second_committed_file</code><br&nbsp;/>
<code>+++&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>-Change1</code><br&nbsp;/>
<code>+Changed&nbsp;this&nbsp;file&nbsp;completely</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_third_committed_file&nbsp;b/my_third_committed_file</code><br&nbsp;/>
<code>new&nbsp;file&nbsp;mode&nbsp;100644</code><br&nbsp;/>
<code>index&nbsp;0000000..5d27866</code><br&nbsp;/>
<code>---&nbsp;/dev/null</code><br&nbsp;/>
<code>+++&nbsp;b/my_third_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-0,0&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>+Addition&nbsp;to&nbsp;the&nbsp;line</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice that instead of using the dynamic reference HEAD, we have now used the tag names <code class="ncode">v0.9</code> and <code class="ncode">v1.0a</code> to refer to our previous commits and have returned the combined diff output of all the changes which occurred between the two.<br><br>You can find out more about tags and how to specify more information in the <em>After Hours</em> section at the end of this Week.<br><hr><div id="calloutblock"><h3>Note - A little about tags</h3>
Tags are great and you should most definitely use them in your repositories to make good reference points, but there is one point that you should always remember.
Though we have not yet delved into the realms of remote branches, it is important to note that once you have tagged a certain commit, and pushed that to the repository, you cannot then remove that tag if someone else clones, or pulls your tags from that remote branch.
This will all become clearer during the next week, but fits in with the overall ethos of working with version control systems, if someone has seen the past, you should not EVER change it.
</div><hr><br><h2>Day 5 - "Putting things back again"</h2>
<h3>Revert, I say. Revert!</h3>
Whilst working with your repository, something occurs quite often, is the need to go back in time, either temporarily or permanently, or even partially.
Git allows you to do this in a multitude of ways.
Let's see a real life situation where this need could arise.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"No, I don't have a copy of the file.
I was stupid and after I submitted it to you I er... deleted it".<br><br>John gave Michael the raised eyebrow look.
It wasn't the first time Michael had come to him with a similar problem.
Usually John would have had Michael go rooting through the archives to find it.
This time though, he wondered if Git might just come to the rescue.<br><br>"Tell ya what Michael," he grinned,
"Since this isn't the first time you've come to me with this kind of predicament, why don't you go and find out how to use Git to get the file back." Michael sighed.
"I have tagged the repo each time we created an archive, so tell me what I need to run to extract it."<br><br> * * * <br><br>"Man", started Michael running over to John's desk forty five minutes later.
"I never knew there were so many ways to skin a cat"<br><br>Michael was a little out of shape and though he had only crossed a minor distance, he now stood there, leaned over John's desk ever so slightly out of breath.<br><br>"So, you learn much?" asked John.<br><br>"Where d'ya want me to start?"<br></div><hr><br>Where exactly do we start? Well one of the neat things about Git is that there are many ways to produce the same result.
While that may not seem like a benefit now, the trick is knowing just how to use each tool and what the benefit is of each method.
Right now, we are ready to look at four methods for achieving the task of viewing old information in the repository.
So how do we choose which method we wish to use? We need to answer a few more questions before we are ready to decide.<br><br>The table below shows the three methods that we have access to now.
Note that this may not be a definitive list of methods, but that these can give us access to the data we need to view.
The columns are requirements or criteria.
We need to evaluate each command in order to determine which one is right for us.
Once you have been using Git a while, these kind of evaluations will become second nature to you, but right now, we will take a look at all available options, just to see what is out there.<br>
<center>
  <table><tr><td>
</td></tr><tr><td>
    Method Name</td><td>
    Alters Repository</td><td>
    Changes History</td><td>
    Alters Working Copy</td><td>
    Reversible</td><td>
    Multiple Files</td></tr><tr><td>
    Reset</td><td>Possibly</td><td>Possibly</td><td>Possibly</td><td>Possibly</td><td>Yes</td></tr><tr><td>
    Checkout</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>
    Show</td><td>No</td><td>No</td><td>No</td><td>N/A</td><td>No</td></tr>
  </table>
</center>
<br>Let's take a look at each of these in turn.
We are going to be covering two new commands and revisiting an old one.
Let us start with <code class="ncode">git reset</code>.
We have already met this tool once.
When we used it previously, its purpose was to pull files out of the index that we were not ready to commit.
We were using <code class="ncode">git reset</code> in its simplest state.
Actually Git can perform several other kinds of reset.
It should be noted here that using this can be quite dangerous as it can affect your index, your working copy, your branch and the pointer HEAD.<br><br>In order to use <code class="ncode">git reset</code> in any sane way to achieve our goal, we would need to look at branching, which at the moment, we are not ready to do.
In short <code class="ncode">git reset</code> can drastically effect your working copy, affecting multiple files, and before we begin investigating, we really need to learn how to play in a safe environment.<br><br>The next method on our list to discuss is the <code class="ncode">git checkout</code> command.
This command can be used to bring back either a single file or multiple files and once again at this stage, is best employed in conjunction with branches.
At this point, you may be wondering why we are placing such emphasis on the use of branches.
As you will see next week, branches are incredibly powerful things, which allow you to experiment and play with your data, without the risk of losing anything.
<code class="ncode">git checkout</code> will pull files from a previous commit into our working copy.
This is something remember.
If we have any changes in our working copy, the checkout will fail.<br><br>The last method we can use to view data which was in a previous commit, is the <code class="ncode">git show</code> command.
This command literally pulls data from a previous version and dumps it to the standard output, a little like the <code class="ncode">cat</code> command present in almost every single *nix environment.<br><br>Now that we have taken a quick look at our three methods, we must decide which one is going to be the most useful to us.
Looking at the scenario above, we can deduce that we really only need to pull out one file.
If our intention was to do large amounts of work on an old branch and pull many files from it, <code class="ncode">git reset</code> may have been a good choice.
As we are looking for only a single file, we should consider looking at the checkout and show tools.<br><br>So now let us see how we can use <code class="ncode">git checkout</code> to take one of our files back to the past.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>nothing&nbsp;to&nbsp;commit&nbsp;(working&nbsp;directory&nbsp;clean)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;v0.9&nbsp;--&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;cat&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>Change1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;HEAD&nbsp;--&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;cat&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>Changed&nbsp;this&nbsp;file&nbsp;completely</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>nothing&nbsp;to&nbsp;commit&nbsp;(working&nbsp;directory&nbsp;clean)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;v0.9&nbsp;--&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	modified:&nbsp;&nbsp;&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;HEAD&nbsp;--&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>nothing&nbsp;to&nbsp;commit&nbsp;(working&nbsp;directory&nbsp;clean)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice how we first checked that we didn't have any local modifications by running the <code class="ncode">git status</code> command.
Then we are safe to run the <code class="ncode">git checkout</code> command.
We used the <code class="ncode">v0.9</code> tag from earlier to refer to an earlier commit state.
The next part of the command is the double hyphen (<code class="ncode">--</code>) that tells Git that what comes after it is the path.
Finally we choose <code class="ncode">my_second_committed_file</code> as the source file.
After this, when we <code class="ncode">cat</code> the file, we see that it has changed to what it used to be in <code class="ncode">v0.9</code>.<br><br>We then switch the file back to the latest version by using the <code class="ncode">HEAD</code> reference.
Note that on the odd occasion, the <code class="ncode">HEAD</code> reference doesn't always point to where you think it does, but this is an area we are yet to cover.
Then we run the command one more time, but this time we intersperse it with a <code class="ncode">git status</code> to see that there are changes made to out local working copy.<br><h3>Show me the money</h3>
The <code class="ncode">git show</code> command will have largely the same effect, except it grabs us the data without having to change existing files in our working copy.
Let us view a quick example.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;show&nbsp;v0.9:my_second_committed_file</code><br&nbsp;/>
<code>Change1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;show&nbsp;v0.9:my_second_committed_file&nbsp;&gt;&nbsp;temp_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;cat&nbsp;temp_file</code><br&nbsp;/>
<code>Change1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>The format of the <code class="ncode">git show</code> command is rather similar to the checkout command we used a few moments ago.
The only difference is the presence of the colon, instead of the double hyphen.
Notice how the effect of the first command is just to print out the contents of the requested file to the screen.
With the Linux environment it is easy to pipe this output to a new file.
In the example above, we pipe the output using the <code class="ncode">&gt;</code> character to the file called <code class="ncode">temp_file</code><br><br>Hopefully you can now see that there are often several ways to achieve the same result and it is important to ensure that you choose the right tool for the job.
The reset command was too dangerous to use, the checkout command modified our working copy, but the show tool allowed us to create a new file, guaranteeing that our working copy remained untouched.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"So, if I am currently have changes to the file you want, in my local repository," began John,
"What command would you recommend I use?"<br><br>Michael paused, clearly considering each method in his head.
The noise from the sandwich van's horn rang through the office and Michael immediately stood bolt upright and looked panicked.
"The van John" he stuttered, "The van"<br><br>"You can go to the van when you tell me which command I should use." John smirked.
Michael was one of the more junior members of the team and the managers often took the opportunity to haze him.<br><br>"I'm gonna go with git show," he said in a rush.<br><br>"Why?" asked John.<br><br>"So you don't harm the working tree." replied Michael smoothly, already walking out the door.<br><br>"You could have also branched," shouted Rob, who was a few steps ahead of him.<br><br> * * * <br><br>"So, what's the status then John?" asked Markus.<br><br>John pressed a button on his laptop and the slideshow on the screen advanced to show an organisational model.
"Well, we've not had a whole lot of time this week as the release for project Manta, but we've managed to look at logging and diffing, which is something that we really needed to cover. Klaus also showed everyone how to tag things and went through our version numbering system again as several people had forgotten."
Everyone in the room looked at Jack.
"We also found out about how to pull older versions out of the repository in a variety of ways."<br><br>Markus looked pleased, "So, what's next?"<br><br>"Klaus?" asked John.<br><br>"Next, John put my team in charge of defining and teaching everyone about branching and merging. This is the really important stuff."
Klaus took over control of the laptop and clicked onto the next slide, which detailed a list of features.
"We really need to get a good handle on these topics to be successful. It is key to collaboration"<br><br>"Well done team," ended Markus,
"Wayne is going to be impressed with this."<br></div><hr><br>We now have a good working knowledge of how to do many key things in Git.
Logging and diffing is supremely important for inspecting what changes have occurred in the repository.
Though the options here are not an exhaustive list, they should give you a basic understanding of how to use the tools.
It is well worth looking at the man pages for these commands to get an idea of just how expansive they can be.
For example, the diff tool can not only show you differences between your working copy and the index, but also between your index and the latest commit, using the <code class="ncode">cached</code> option.<br><br>Next we move on to branching and merging.
Branching can be a tricky subject, so it is important to understand what is happening at the repository level.
It would be prudent to look over the <em>After Hours</em> section for Week 2 before continuing as some of the terminology may be a little confusing otherwise.<br><br><h2>Summary - John's Notes</h2>
<h3>Commands</h3>
<div style="padding-left:10px;"><ul><li><code class="ncode">git log</code> - Return a navigable list of commits to a repository</li>
<li><code class="ncode">git log -S&lt;string&gt;</code> - Show all commits that either introduced or removed a particular string from the repository</li>
<li><code class="ncode">git log -S&lt;string&gt; &lt;path&gt;</code> - Show all commits that either introduced or removed a particular string from the repository, but restrict the search to a specific path</li>
<li><code class="ncode">git log HEAD~1..HEAD</code> - Show all commits between HEAD~1 and HEAD, essentially the last commit</li>
<li><code class="ncode">git diff HEAD~1..HEAD</code> - Show the actual differences between HEAD~1 and HEAD</li>
<li><code class="ncode">git tag &lt;name&gt;</code> - Create a tag with the given name</li>
<li><code class="ncode">git tag &lt;name&gt; &lt;commit&gt;</code> - Retrospectively tag a commit with a given name</li>
<li><code class="ncode">git rev-parse &lt;tag&gt;</code> - Show the commit SHA-1 hash object referred to by the given name</li>
</ul></div><br><h3>Terminology</h3>
<div style="padding-left:10px;"><ul><li><strong>Branch</strong> - A way of working on the same set of code in parallel without modifications overlapping</li>
<li><strong>Diff</strong> - Shows the actual differences between files</li>
<li><strong>Hunk</strong> - A section of a diff output</li>
</ul></div>

<h1>After Hours Week 3</h1>
<h2>"A Closer Look At Diffs and Tags"</h2>
<h3>The Diff Utility</h3>
We learnt in <em>Week 3</em> how to work with a diff, and what a diff actually represents.
It is interesting to note how old the <code class="ncode">diff</code> utility actually is and how it works.
The diff algorithm was developed in the early 1970s and the research published in 1976, by Douglas McIlroy, who wrote the original diff utility and James Hunt.
The algorithm we use today to perform diffs has become known as the Hunt-McIlroy after the research papers authors.<br><br>In essence the task of calculating a diff is that of finding the differences between two files on a line by line basis.
Mathematically, this can be described as the LCS or Longest Common Subsequence problem, which is a classic computer science problem.<br><br>Though we are not going to go into the problem in great detail, it is useful to know what actually happens at this level.
Essentially you have two sequences, for now we are going to simplify the problem and work on a string of letters.<br><br>Old string:
<br><div id="codeblock"><code>a&nbsp;b&nbsp;c&nbsp;d&nbsp;e&nbsp;j&nbsp;k&nbsp;l&nbsp;m&nbsp;p&nbsp;r&nbsp;s</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>New string:
<br><div id="codeblock"><code>a&nbsp;c&nbsp;d&nbsp;f&nbsp;g&nbsp;h&nbsp;i&nbsp;j&nbsp;n&nbsp;o&nbsp;p&nbsp;t&nbsp;u</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>The challenge is to find the longest sequence of items that is present in both of the strings above.
This new sequence is found by deleting items from the first and second set until all that remains is a sequence of common items.<br><br>In our example case, this is as follows
LCS string:
<br><div id="codeblock"><code>a&nbsp;c&nbsp;d&nbsp;j&nbsp;p</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Comparing this to each of our strings above, it is easy to generate a diff.
If the items are present in the <em>Old string</em>, but not in the LCS string then they must have been deleted.
Conversely if they are present in the <em>New string</em>, but not the LCS, then they must have been additions.
Putting this into practice in our example and marking deletions with <code class="ncode">-</code> and additions with <code class="ncode">+</code>, we get the following:<br><br>Diff string:
<br><div id="codeblock"><code>b&nbsp;e&nbsp;fghi&nbsp;klm&nbsp;o&nbsp;rs&nbsp;tu</code><br&nbsp;/>
<code>-&nbsp;-&nbsp;++++&nbsp;---&nbsp;+&nbsp;--&nbsp;++</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>The actual algorithm for generating the LCS and the subsequent diff is too complex to describe here and is out of the scope of this book.
This section was included to give you some idea of how Git performs some of its actions internally.<br><h3>More about tags</h3>
Tags can actually do a little more than just hold a single identifier to a specific commit.
A tag can also have a log message with it, similar to the commit objects we discussed earlier.
In order to invoke this option, we need to use the <code class="ncode">git tag -m 'message'</code> option.
This will allow us to supply a message to be stored along with the tag.
Let us see how this works in practice.<br><br>Firstly we can use the <code class="ncode">git tag</code> command to show all tags that are currently in the repository.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;tag</code><br&nbsp;/>
<code>v0.9</code><br&nbsp;/>
<code>v1.0a</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now let us create a new tag and give it some extra information.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;tag&nbsp;v1.0b&nbsp;-m&nbsp;'This&nbsp;is&nbsp;an&nbsp;annotated&nbsp;tag'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Unfortunately Git was not particularly forthcoming with information on the creation of the tag.
On saying that, it is not difficult for us to use the <code class="ncode">git show</code> command to see what we have done.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;show&nbsp;v1.0b</code><br&nbsp;/>
<code>tag&nbsp;v1.0b</code><br&nbsp;/>
<code>Tagger:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;23:55:50&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>This&nbsp;is&nbsp;an&nbsp;annotated&nbsp;tag</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;a022d4d1edc69970b4e8b3fe1da3dccd943a55e4</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;22:05:55&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_second_committed_file&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>index&nbsp;095b9cd..c9887f8&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/my_second_committed_file</code><br&nbsp;/>
<code>+++&nbsp;b/my_second_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>-Change1</code><br&nbsp;/>
<code>-Change2</code><br&nbsp;/>
<code>+Changed&nbsp;this&nbsp;file&nbsp;completely</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/my_third_committed_file&nbsp;b/my_third_committed_file</code><br&nbsp;/>
<code>new&nbsp;file&nbsp;mode&nbsp;100644</code><br&nbsp;/>
<code>index&nbsp;0000000..5d27866</code><br&nbsp;/>
<code>---&nbsp;/dev/null</code><br&nbsp;/>
<code>+++&nbsp;b/my_third_committed_file</code><br&nbsp;/>
<code>@@&nbsp;-0,0&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>+Addition&nbsp;to&nbsp;the&nbsp;line</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice that as well as showing us the tag itself, the <code class="ncode">git show</code> command also gave us a diff of what exactly changed in this commit.
Small details like this are what makes Git in particular a joy to use for developers.<br><br>If we found that we had actually created the tag incorrectly, we have two options, we could use the <code class="ncode">-d</code> option to delete a tag, or we could use the <code class="ncode">-F</code> option to forcibly overwrite a tag with the same name with different information.
However please remember the warning about tags in <em>Week 2</em>.
It is very dangerous to go changing tags, especially if you have already pushed them out somewhere where other people can grab them from.<br><br>Now that we have learnt a little about how to play with tags, we should probably take a look under the hood.
This is an After Hours section after all.<br><br>The implementation of tags in Git is very simple indeed.
We are going to jump into the <code class="ncode">.git</code> directory and take a look at a simple output from some commands.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;cd&nbsp;.git/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/.git$&nbsp;ls</code><br&nbsp;/>
<code>branches&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;config&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HEAD&nbsp;&nbsp;&nbsp;index&nbsp;&nbsp;logs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refs</code><br&nbsp;/>
<code>COMMIT_EDITMSG&nbsp;&nbsp;description&nbsp;&nbsp;hooks&nbsp;&nbsp;info&nbsp;&nbsp;&nbsp;objects</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/.git$&nbsp;cd&nbsp;refs/tags/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/.git/refs/tags$&nbsp;ls</code><br&nbsp;/>
<code>v0.9&nbsp;&nbsp;v1.0a&nbsp;&nbsp;v1.0b</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/.git/refs/tags$&nbsp;cat&nbsp;v1.0a</code><br&nbsp;/>
<code>a022d4d1edc69970b4e8b3fe1da3dccd943a55e4</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/.git/refs/tags$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Inside the <code class="ncode">.git/refs/tags</code> folder, there is a file for every single tag in the system.
This file contains a single string of characters.
That string looks oddly like an SHA-1 commit to me.
Using the tricks that we learnt in the last After Hours section, we can interrogate the Git repository, by throwing a few wrenches at it.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;a022d4</code><br&nbsp;/>
<code>tree&nbsp;96551f45496232c0ec6b389731d55fa3d7e1c8fd</code><br&nbsp;/>
<code>parent&nbsp;9938a0c30940dccaeddce4bb2eb151fba3a21ae5</code><br&nbsp;/>
<code>author&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;&nbsp;1301605555&nbsp;+0100</code><br&nbsp;/>
<code>committer&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;&nbsp;1301605555&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;cat-file&nbsp;-t&nbsp;a022d4</code><br&nbsp;/>
<code>commit</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Excellent! Just as we expected.
So Git stores the SHA-1 hash for the commit we are referring to, in a file which has the same name as the tag.
Just for clarity, let us run the same set of commands against our newly created annotated tag.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;cd&nbsp;.git/refs/tags/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/.git/refs/tags$&nbsp;cat&nbsp;v1.0b</code><br&nbsp;/>
<code>6cbcf47957589bf4b84cc934a26731636d021574</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/.git/refs/tags$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Hang on a minute! Shouldn't the output of the <code class="ncode">v1.0a</code> and <code class="ncode">v1.0b</code> files be the same.
There were both created at the same point in the repositories history.
They were both supposed to be pointing to the same commit.
Let us use a little plumbing and see what is going on.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;cat-file&nbsp;-t&nbsp;6cbcf4</code><br&nbsp;/>
<code>tag</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Interesting.
So it seems as if there is another type of object that can be added to the list.
The <em>tag</em> object.
So what exactly is the difference here? To answer that we need to take a look at the difference between the two tags.
<code class="ncode">v1.0a</code> was a simple tag, whereas <code class="ncode">v1.0b</code> is an annotated tag.<br><br>When the tag was merely a pointer to a commit object, the repository required nothing more that the object that it was referring to, to be stored in the file.
Now we have more information, Git treats the information just as it would any other, by creating an object.
We can investigate this further and use the <code class="ncode">-p</code> parameter to the <code class="ncode">git cat-file</code> command to see exactly what is stored within this file.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;6cbcf4</code><br&nbsp;/>
<code>object&nbsp;a022d4d1edc69970b4e8b3fe1da3dccd943a55e4</code><br&nbsp;/>
<code>type&nbsp;commit</code><br&nbsp;/>
<code>tag&nbsp;v1.0b</code><br&nbsp;/>
<code>tagger&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;23:55:50&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>This&nbsp;is&nbsp;an&nbsp;annotated&nbsp;tag</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So an annotated tag contains more information than just the commit ID we are referring to.
This is pretty handy and later on in the book we will start talking about topics like signed tags, which are required if you wish to verify the identity of the person claiming to have created the tag.<br><br>A shorter After Hours section this time.
Next time we will move on to taking a deeper look at what happens behind the scenes with branches and merging.
Stay tuned.


<h1>Week 4</h1>
<h2>Day 1 - "We're getting somewhere"</h2>
<h3>Planting trees</h3>
Tamagoyaki Inc have now realised that they have to take these things slow and steady if they want to implement a stable and robust system.
This week, they are going to start actually using branches and merging in changes, probably one of the largest topics to cover when doing any type of collaborative development.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Dude!" shouted Eugene from across the office.
"Dude!!" he repeated.<br><br>No one looked up and the hum of the computers seemed to drown out the murmurs of voices and clicking of keys.<br><br>"Dud..."
He was cut off by another voice.
It was Klaus.<br><br>"Maybe if you gave us some indication of who you were addressing Eugene," said Klaus in his usual matter-of-factly tone,
"we may actually be able to help you."<br><br>"John!" Shouted Eugene, as if ignoring Klaus entirely.
The manager hadn't looked up from his monitor as he had advised the tools guy and he now sat there continuing to type with one hand, the other reaching over and yanking out the earbud that was playing a droning beat in John's ear.<br><br>"Ouch!" said John, slightly startled.<br><br>"Dork wants you," said Klaus, using his pet name for Eugene.<br><br>John walked over to Eugene.
"Sup?!"<br><br>"I don't get branches," said the developer.
"I mean I don't get what the heck they do, why I would ever want to use them, and how are they even different to tags anyway?"
</div><hr><br>First, we should probably start off by answering that very question and describing what branches are and what they can be used for.
In Git, a branch is just a pointer to a commit in the repository.
At first glance this might not seem any different to a tag.
A tag points to a commit, so does a branch.
So what distinguishes between the two? Let us start playing with branches a little and the answer will become obvious in a while.
Branches allow you to try things out and even keep a history of the things you try without actually affecting your main branch.
In essence you are able to take things in a completely different direction, safe in the knowledge that your core code base will be safe.<br><br>This is best illustrated by a little demonstration, so we are going to take our testing repository and branch off to try out new, wonderful and wacky things.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;ls</code><br&nbsp;/>
<code>my_first_committed_file&nbsp;&nbsp;&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>my_second_committed_file&nbsp;&nbsp;temp_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;wacky</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch</code><br&nbsp;/>
<code>*&nbsp;master</code><br&nbsp;/>
<code>&nbsp;&nbsp;wacky</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>From looking at the output, it would appear that our <code class="ncode">git branch wacky</code> command did not accomplish a whole lot.
Running the <code class="ncode">git branch</code> command will give us a list of all branches in the repository.
You may have noticed the presence of the <code class="ncode">*</code> in front of the word <code class="ncode">master</code>.
This is telling us that we are on the branch called <strong>master</strong>.
Hang on though, did we not just create a new branch called <strong>wacky</strong>?<br><br>Well yes we did.
However we have not yet switched to it.
To do this, we use our good friend <code class="ncode">git checkout</code>.
This will change the working copy to reflect the most recent commit in that branch, and will reset our HEAD accordingly, so that it points to this latest commit<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;wacky</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'wacky'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch</code><br&nbsp;/>
<code>&nbsp;&nbsp;master</code><br&nbsp;/>
<code>*&nbsp;wacky</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now the <code class="ncode">*</code> has moved to be in front of the word <code class="ncode">wacky</code> and we have confirmation from the line above that we have in fact <code class="ncode">Switched to branch 'wacky'</code>.
Now we are here in wonderland, what can we do? Well, potentially anything we could do in our previous branch, but with the added benefit that we are separated.
Some of you maybe be thinking, but we never created an initial branch called <strong>master</strong>.
Whilst this is true in one sense, the <code class="ncode">git init</code> command actually created this branch for us when we initialised the repository.<br><br>We will start off by taking a deeper look at what is present in our branch.
Running a <code class="ncode">git log</code> shows us the history of our branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log</code><br&nbsp;/>
<code>commit&nbsp;a022d4d1edc69970b4e8b3fe1da3dccd943a55e4</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;22:05:55&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;9938a0c30940dccaeddce4bb2eb151fba3a21ae5</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;20:34:23&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Finished&nbsp;adding&nbsp;initial&nbsp;files</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;163f06147a449e724d0cfd484c3334709e8e1fce</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;20:32:59&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Made&nbsp;a&nbsp;few&nbsp;changes&nbsp;to&nbsp;first&nbsp;and&nbsp;second&nbsp;files</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;cfe23cbe0150fda69a004e301828097935ec4397</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;20:27:44&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;My&nbsp;First&nbsp;Ever&nbsp;Commit</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>You may notice here that the log messages being displayed are identical to that which we had before in our <strong>master</strong> branch.
This is nothing to be worried about.
You may be wondering how these can be present if we are in a totally separate environment.
Well, though we have branched, the history that led us to this point is the same.
As we have not made any changes yet, we do not notice any divergence.
If we now make changes to the <em>repository</em> we can take a look and see how this will affect things.
To start with, let us remove a few files from the working tree, commit these actions, then add a few more, stage them and commit the new files.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;rm&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>rm&nbsp;'my_first_committed_file'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;rm&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>rm&nbsp;'my_second_committed_file'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'Removed&nbsp;a&nbsp;few&nbsp;files'</code><br&nbsp;/>
<code>[wacky&nbsp;4a155e4]&nbsp;Removed&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;0&nbsp;insertions(+),&nbsp;2&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"A&nbsp;new&nbsp;file"&nbsp;&gt;&nbsp;newfile1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"Another&nbsp;new&nbsp;file"&nbsp;&gt;&nbsp;newfile2</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;newfile*</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'Added&nbsp;two&nbsp;new&nbsp;files'</code><br&nbsp;/>
<code>[wacky&nbsp;55fb69f]&nbsp;Added&nbsp;two&nbsp;new&nbsp;files</code><br&nbsp;/>
<code>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;2&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;newfile1</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;newfile2</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So we have made two new commits to the repository under our new branch.
If we run a Linux <code class="ncode">ls</code> command to see the files which are in the working tree, we can see that our working copy has indeed altered.
We will also use our <code class="ncode">git log</code> tool to see what the latest commit is.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;ls</code><br&nbsp;/>
<code>my_third_committed_file&nbsp;&nbsp;newfile1&nbsp;&nbsp;newfile2&nbsp;&nbsp;temp_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;-n1</code><br&nbsp;/>
<code>commit&nbsp;55fb69f4ad26fdb6b90ac6f43431be40779962dd</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Apr&nbsp;1&nbsp;00:10:49&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Added&nbsp;two&nbsp;new&nbsp;files</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Brilliant.
As you can see, we have used <code class="ncode">git log</code> in a slightly different way to limit the number of commits.
This is what the <code class="ncode">-n</code> parameter is used for.
However, what happens if we go back to the <strong>master</strong> branch again? In theory we should have everything back the way we left it just before creating the branch.
Let's move back into our <strong>master</strong> branch and examine the state of play.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;ls</code><br&nbsp;/>
<code>my_first_committed_file&nbsp;&nbsp;&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>my_second_committed_file&nbsp;&nbsp;temp_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;-n1</code><br&nbsp;/>
<code>commit&nbsp;a022d4d1edc69970b4e8b3fe1da3dccd943a55e4</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Mar&nbsp;31&nbsp;22:05:55&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Comparing that to our previous <code class="ncode">ls</code> command, we can see that this is exactly what the working tree looked like at the beginning of the chapter.
Let us take a look at a diagram of the commit history to see what has happened in our repository.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w4-d1.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 1</strong><br>Our first branch</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>So there are really two pointers in our repository at the moment, from a branch point of view.
One of them points to commit <strong>a022d4d...</strong> and is called <strong>master</strong>.
The other is called <strong>wacky</strong> and points to <strong>55fb69f...</strong>.
At this point you may be thinking that branches are pretty much the same thing as tags.
Well, they are except for one important fact.
We are going to use our <code class="ncode">git branch</code> command, with a new parameter, to show us the difference.
Take a look at the output of the following operations.
We have pruned the output of the <code class="ncode">git show</code> command for brevity.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;wacky</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'wacky'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-v</code><br&nbsp;/>
<code>&nbsp;&nbsp;master&nbsp;a022d4d&nbsp;Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;wacky&nbsp;&nbsp;55fb69f&nbsp;Added&nbsp;two&nbsp;new&nbsp;files</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;tag&nbsp;v2.0</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;show&nbsp;v2.0</code><br&nbsp;/>
<code>commit&nbsp;55fb69f4ad26fdb6b90ac6f43431be40779962dd</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So here we have added a tag in our current branch, <strong>wacky</strong>, and we can see that the commit ID for the tag <strong>v2.0</strong> points <strong>55fb69f</strong>.
We can also see that the branch <strong>wacky</strong> is currently pointing to the same commit ID, <strong>55fb69f</strong>.
Now let us add another file in, make a commit and see what happens after this.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"New&nbsp;stuff"&nbsp;&gt;&nbsp;another_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;another_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'Added&nbsp;another&nbsp;file'</code><br&nbsp;/>
<code>[wacky&nbsp;9710177]&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;another_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;show&nbsp;v2.0</code><br&nbsp;/>
<code>commit&nbsp;55fb69f4ad26fdb6b90ac6f43431be40779962dd</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-v</code><br&nbsp;/>
<code>&nbsp;&nbsp;master&nbsp;a022d4d&nbsp;Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;wacky&nbsp;&nbsp;9710177&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>How interesting.
The difference between tags and branches now becomes pretty clear.
Whilst a tag always points to the same commit, a branch reference always points to the tip of that branch.
In essence the reference that a branch points to moves as subsequent commits are made.
By doing this, the whole history of the branch can be retraced.
Since we know the latest commit, we also know the parent of that commit and so on and so on.<br><br>Since a branch is just a pointer to a commit, performing operations like adding, modifying and deleting files in the repository can be done safely, without destroying any data in another branch.
In short, it will allow us to completely redesign whatever is being stored in the current branch without worrying about how it will affect our baseline.
For a developer, this is pretty crucial stuff.
This gives people the chance to play with their data and experiment, which is often where the greatest ideas come from.<br><h2>Day 2 - "Branches galore"</h2>
<h3>Working with branches</h3>
Now we know about branches in general, we should really learn about how to merge changes from one branch into another.
Branches are fantastic for trying new things out and testing ideas, but if those ideas are successful, we need a way of pulling those changes into our <strong>master</strong> branch.<br><br>Of course we could do this the old fashioned way.
We could switch into our <strong>wacky</strong> branch, do a little development, copy the files somewhere else, switch to our <strong>master</strong> branch, and paste the files over the top.
Now, this is probably the simplest way of merging possible.
In actual fact, this is not really merging at all.
However one thing that would be lost is the history of how that branch has developed over time.
Sometimes this can be crucial for knowing why certain things were changed during the development process.<br><br>Let us take a little look at the command output of a simple merge, explain it a little, and then look at a diagrammatic representation.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch</code><br&nbsp;/>
<code>&nbsp;&nbsp;master</code><br&nbsp;/>
<code>*&nbsp;wacky</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Firstly we check just to see what branch we are on.
Next we checkout the branch we want our development branch to be merged into.
In this case, we want to merge <strong>wacky</strong> into <strong>master</strong> and so we must first checkout the <strong>master</strong> branch.
Then we can merge in the changes from our <strong>wacky</strong> branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we can run the actual merge.
<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;merge&nbsp;wacky</code><br&nbsp;/>
<code>Updating&nbsp;a022d4d..9710177</code><br&nbsp;/>
<code>Fast-forward</code><br&nbsp;/>
<code>&nbsp;another_file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;my_first_committed_file&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-</code><br&nbsp;/>
<code>&nbsp;my_second_committed_file&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-</code><br&nbsp;/>
<code>&nbsp;newfile1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;newfile2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;5&nbsp;files&nbsp;changed,&nbsp;3&nbsp;insertions(+),&nbsp;2&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;another_file</code><br&nbsp;/>
<code>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;my_first_committed_file</code><br&nbsp;/>
<code>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;my_second_committed_file</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;newfile1</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;newfile2</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We can see that the first line after our <code class="ncode">git merge</code> command shows us which commit <strong>master</strong> is the latest common ancestor to both branches and then which commit is the last in our new branch.
In this case we are merging from <strong>a022d4d</strong> to <strong>9710177</strong>.
The line below this is even more important.
This type of merge is called a <em>fast-forward</em> merge.
We have not made any changes to our <strong>master</strong> branch since we began developing and subsequently, after finishing our development work, we literally only require fast-forwarding the <strong>master</strong> branch to the same point in time as our <strong>wacky</strong> one.
Beneath this text, we see more information about just what is included in the merge.<br><br>We are going to perform a quick check, to see that we are in fact on the master branch and that the latest log message is the one from the point we last left the <strong>wacky</strong> branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;-n1</code><br&nbsp;/>
<code>commit&nbsp;9710177657ae00665ca8f8027b17314346a5b1c4</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Apr&nbsp;1&nbsp;00:16:17&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch</code><br&nbsp;/>
<code>*&nbsp;master</code><br&nbsp;/>
<code>&nbsp;&nbsp;wacky</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now let us take a quick look at a diagram to see how this change actually affected the commit flow.
We have included tags in this diagram, so that you can see where they point to as well.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w4-d2.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 2</strong><br>Our first merge</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>This picture should make it clear that the fundamental difference between tags and branches is that whilst the pointer to a branch moves with each commit to that branch, a tag points to a single commit only and never changes, unless forcibly so by the user.<br><br>There are a number of tricks that we can employ when using branches.
They are possible because of the super flexible way in which branches are implemented in Git.
As a branch is literally a pointer to a commit, certain operations are available to a user that other systems just can not implement.
However, we should point something out at this point.
Even though we have not yet made any of our repositories public or available to other people, something should always be in the back of your mind.
Allow a few minutes to read the next few paragraphs below.<br><br>As someone once said, "With great power, comes great responsibility." Git is hugely powerful.
However, with this power comes a certain level of responsibility.
We are referring here to Git's ability to change history.
If you have watched any science fiction films involving time travel, you should be aware of the difficulties and problems often associated with time travel.
In Git, the same rule applies and the basics of the rule boil down to this: <strong>If you have made a commit, or path of commits available, you should never ever change anything in the history of those commits or the commits themselves.</strong><br>If you are wondering why this is so important, consider this.
If you are making a series of films, and you have already released the first two of a trilogy, you would not put elements in the third one that contradict the history of the others.
You can not just act like the history of the first two did not happen.
Occasionally this happens in the film industry and what is the reaction of the public? People get mad.
Sometimes very mad.
This is what will happen if you do the same with Git.
People who are using your repository will end up with many problems and inconsistencies.
<strong>Do NOT do it, ever</strong>.
There are ways to revert certain behaviour and we will cover this at a later stage.<br><br>Having said this, you should not shy away from the awesome capabilities of Git.
We are going to cover a few situations now which you may find yourself in.
Some of them do alter history, some of them do not.
This is why it is important to have an understanding of how Git works.
It can be your best friend, but it can also cause you issues.
If you take the time to tame the beast, it will be one of the most awesome tools in your developers tool bag and can save your life time and time again.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Oh man." The familiar cry of Simon needing something reverberated round the office.
Rob could never understand why he didn't ask for help.
Simon would sit there wallowing out loud until someone could take it no longer and would eventually go over and help him.<br><br>"What to do... what to do."<br><br>Rob could take it no more.
Simon had been exclaiming now for about five minutes and Rob seemed to either be the only one who wasn't listening to music, or who was getting annoyed.
He rolled his eyes, "What's up Si?"<br><br>Simon grinned inanely to himself.
"I just started modifying some files and well ... I don't want to get rid of them ... I'm not 100
"Well, when did you last commit?"<br><br>"Just before I started all this work," came the reply.<br><br>Rob pointed at Simon's screen.
"You can just create a new branch now and move all the changes into it in one go. You can do it in one command actually."
</div><hr><br>It is one hundred percent true.
How many times have you been working on something and wished that you could move all the changes you had made to a new safe environment to protect your already good, working code.
Well, the new safe environment we spoke of sounds suspiciously like a branch.
In Git, any changes you have in your working copy can be taken into a new branch by issuing one command.
It is important to note that these changes can also be taken into an existing branch, but you may run into problems if those changes conflict with items already in that branch.<br><br>For now let us see how we can take our working copy changes into a new branch to continue development of some wonderful new feature.
We are going to start by making some changes to our newfiles.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"and&nbsp;some&nbsp;more&nbsp;changes"&nbsp;&gt;&gt;&nbsp;newfile1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"and&nbsp;a&nbsp;new&nbsp;feature"&nbsp;&gt;&gt;&nbsp;newfile2</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we are going to make a new branch and switch into it.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;wonderful</code><br&nbsp;/>
<code>M	newfile1</code><br&nbsp;/>
<code>M	newfile2</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;'wonderful'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Did you see that? We managed to create a new branch and move into it in one go.
The <code class="ncode">git checkout</code> command is usually what we would use to move into a branch, not create it.
When we use the <code class="ncode">-b</code> parameter, the <code class="ncode">git checkout</code> command can be used to create a new branch and switch to it in one go.
Notice we have chosen the name <strong>wonderful</strong> for this particular branch.
There is also a status output below this that shows we have pulled two modifications into this branch, denoted by the letter <code class="ncode">M</code> in front of the file name.<br><br>Now we can commit these changes.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Fantastic&nbsp;new&nbsp;feature'</code><br&nbsp;/>
<code>[wonderful&nbsp;cfbecab]&nbsp;Fantastic&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;2&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff&nbsp;master&nbsp;wonderful</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile1&nbsp;b/newfile1</code><br&nbsp;/>
<code>index&nbsp;24e7dfa..ef20984&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile1</code><br&nbsp;/>
<code>+++&nbsp;b/newfile1</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>+and&nbsp;some&nbsp;more&nbsp;changes</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile2&nbsp;b/newfile2</code><br&nbsp;/>
<code>index&nbsp;cba16cc..dac4357&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile2</code><br&nbsp;/>
<code>+++&nbsp;b/newfile2</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>+and&nbsp;a&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>After running the diff, we can see the differences between the <strong>master</strong> and the <strong>wonderful</strong> branches.
Looking more closely at the hunks, the only differences between the two branches are those that we made before we created our <strong>wonderful</strong> branch.
We have achieved what we set out to in bringing uncommitted changes from <strong>master</strong> into <strong>wonderful</strong> and subsequently committing them.<br><h2>Day 3 - "Tricking the twigs"</h2>
<h3>More neat ways to work with branches</h3>
This is only the beginning of the fantastic feature set that Git offers.
By knowing how Git handles your data, you can make it work for you.
Let us take a look at another situation you may find yourself in.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Rob!" shouted Simon for the fourth time that morning.
"Rob, I made a real boo boo this time."<br><br>Rob walked over to Simon again, head lolling back on his shoulders and his eyes rolling.
His arms weighed heavily by his side and his walk reminded Simon of that of a zombie.<br><br>"What have you done THIS time?" asked the developer as he reached the desk.<br><br>Simon drew in his breath deeply, "Well, I created a branch, started working away, committing like a good'un, but I only just realised I'm on the wrong branch. I forgot to switch."
He hung his head in shame.
"I'm screwed right?"<br><br>"Not necessarily," replied his colleague.
</div><hr><br>This wouldn't work in all situations, but then there are other techniques described later in the book to deal with more special cases.
In this scenario we have created a branch, forgotten to switch into it, and carried on committing as if we were in our new branch.
At first glance it may seem as if we are stuck.
Once we have committed, we can't undo those commits right? Well, that's not entirely accurate.<br><br>We actually have two ways of clearing up this particular situation.
The first of these is to use <code class="ncode">git revert</code> to undo the changes of each commit.
Whilst this will work, we have two problems, a) we do not know how to use the <code class="ncode">git revert</code> tool yet, and b) we can actually handle this situation much more cleanly.
We are going to make a new branch, make a few commits and then look at a diagram of our recent work to see how we can work things out.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Already&nbsp;on&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"and&nbsp;some&nbsp;awesome&nbsp;changes"&nbsp;&gt;&gt;&nbsp;newfile1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Made&nbsp;an&nbsp;awesome&nbsp;change'</code><br&nbsp;/>
<code>[master&nbsp;a27d49e]&nbsp;Made&nbsp;an&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes"&nbsp;&gt;&gt;</code><br&nbsp;/>
<code>&nbsp;newfile2</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Made&nbsp;another&nbsp;awesome&nbsp;change'</code><br&nbsp;/>
<code>[master&nbsp;7cc32db]&nbsp;Made&nbsp;another&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w4-d3.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 3</strong><br>Repository including the mistake</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w4-d4.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 4</strong><br>Repository showing how things <em>should</em> look</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Figure 3 shows how our repository looks now, whereas Figure 4 shows how the repository should have looked if we had performed it properly.
You should notice that the positions of <code class="ncode">master</code> and <code class="ncode">zaney</code> have switched places.
How can we rectify this?<br><br>We already discussed one method using <code class="ncode">git revert</code>, which we are due to cover a little later.
However, because of the way that the history has been written, we can do something very simple.
We are going do the following the following steps.<br><div style="padding-left:10px;"><ol><li>Switch to our <strong>zaney</strong> branch</li>
<li>Fast-forward our zaney branch so that it points to the same commit using a merge</li>
<li>Switch back to our <strong>master</strong> branch</li>
<li>Reset our master branch back to the required point in time</li>
</ol></div><br>So let us take a look at the command line output and see how we achieve this.
Hopefully you should be familiar with most of the commands.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;zaney</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'zaney'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;merge&nbsp;master</code><br&nbsp;/>
<code>Updating&nbsp;9710177..7cc32db</code><br&nbsp;/>
<code>Fast-forward</code><br&nbsp;/>
<code>&nbsp;newfile1&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;newfile2&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;2&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we reach step 4 in our set of instructions.
The one function we do not know how to perform yet is the resetting of our branch back to a previous point in time.
The point we need to rewind back to is the point that we initially created the <strong>zaney</strong> branch at.
We could have gotten this information by using <code class="ncode">git log</code>.
Instead, this time we can use the information presented in the merge output to show the common ancestor, which has to be the point that we created our branch at.
In this case it is commit <strong>9710177</strong>.<br><br>We are now going to perform the last step using an old friend called <code class="ncode">git reset</code>.
You may be thinking that <code class="ncode">git reset</code> is only used to reset files in the index, but in fact, <code class="ncode">git reset</code> can actually perform many more tasks.
We are going to use it with the <code class="ncode">--hard</code> option.
This option can be dangerous, as it will discard all modifications in the working tree, so use with caution.
If we had uncommitted changes in our repository at this point, we could not have used this option.
Let's use the command and see where we get.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;reset&nbsp;--hard&nbsp;9710177</code><br&nbsp;/>
<code>HEAD&nbsp;is&nbsp;now&nbsp;at&nbsp;9710177&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, we are told that the HEAD of our master branch is now at commit <strong>9710177</strong>.
We have successfully rewound our <strong>master</strong> branch to a previous state.
The <code class="ncode">--hard</code> parameter reset the index and the working tree to be at the state of the commit we tell it to.
It disregards all working copy and staged modifications, so use it with care.<br><br>The <code class="ncode">git reset</code> command does not only work for rewinding back in time.
It can also be used to move a branch forward in time.
As an example of this, we used a fast-forward merge to move our <strong>zaney</strong> branch forward to be in-line with master.
We could just have easily used <code class="ncode">git reset --hard 7cc32db</code> from within the zaney branch, to bring it to the same point as the master.
In fact, though it looks scary, we could also have used <code class="ncode">git reset --hard master</code> to reset the <strong>zaney</strong> branch to be at the same point as <strong>master</strong>.
Saves typing out those horrid commits does it not?<br><br>Finally we are going to introduce one more use of the <code class="ncode">git log</code> command to show us how our repository looks in a semi-graphical way.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;--graph&nbsp;--pretty=oneline&nbsp;--all&nbsp;--abbrev-commit&nbsp;&nbsp;--decorate</code><br&nbsp;/>
<code>*&nbsp;7cc32db&nbsp;(zaney)&nbsp;Made&nbsp;another&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>*&nbsp;a27d49e&nbsp;Made&nbsp;an&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;cfbecab&nbsp;(wonderful)&nbsp;Fantastic&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>|/</code><br&nbsp;/>
<code>*&nbsp;9710177&nbsp;(HEAD,&nbsp;wacky,&nbsp;master)&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>*&nbsp;55fb69f&nbsp;(v2.0)&nbsp;Added&nbsp;two&nbsp;new&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;4a155e4&nbsp;Removed&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;a022d4d&nbsp;(tag:&nbsp;v1.0b,&nbsp;v1.0a)&nbsp;Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;9938a0c&nbsp;Finished&nbsp;adding&nbsp;initial&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;163f061&nbsp;(v0.9)&nbsp;Made&nbsp;a&nbsp;few&nbsp;changes&nbsp;to&nbsp;first&nbsp;and&nbsp;second&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;cfe23cb&nbsp;My&nbsp;First&nbsp;Ever&nbsp;Commit</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>The <code class="ncode">--graph</code> parameter, tells Git to draw a graph down the left hand column.
The <code class="ncode">--pretty=oneline</code> parameter reduces the commit details to one line, else we see the entire log message of the commit.
<code class="ncode">--all</code> shows all branches.
The <code class="ncode">abbrev-commit</code> in the command tells Git to abbreviate the commit IDs to a sensible length.
Finally, <code class="ncode">--decorate</code> shows us the tag and branch references.
Hopefully if you compare this tree to the diagram earlier, you will see that the tree is actually completely in order.<br><br>Be aware that during this work we have changed the history of at least one of our branches.
Had we pushed our changes to a public server, which is something that will be discussed next week, we would have to force these changes to be accepted at the server end.
Git knows we are trying to change a past that may have been viewed by others and will warn us accordingly.<br><h2>Day 4 - "I pressed delete..."</h2>
<h3>Handling the pressure</h3>
We have had some awesome fun working with branches, and hopefully you can see how utterly powerful Git is.
Sometimes though we can get ourselves into trouble and it is here that Git can also come to our rescue.
Let us learn how to delete a branch.
We are going to delete our <strong>wacky</strong> branch now as we have already merged it and no longer require it.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-d&nbsp;zaney</code><br&nbsp;/>
<code>error:&nbsp;The&nbsp;branch&nbsp;'zaney'&nbsp;is&nbsp;not&nbsp;fully&nbsp;merged.</code><br&nbsp;/>
<code>If&nbsp;you&nbsp;are&nbsp;sure&nbsp;you&nbsp;want&nbsp;to&nbsp;delete&nbsp;it,&nbsp;run&nbsp;'git&nbsp;branch&nbsp;-D&nbsp;zaney'.</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-D&nbsp;zaney</code><br&nbsp;/>
<code>Deleted&nbsp;branch&nbsp;zaney&nbsp;(was&nbsp;7cc32db).</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-v</code><br&nbsp;/>
<code>*&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;9710177&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>&nbsp;&nbsp;wacky&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9710177&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>&nbsp;&nbsp;wonderful&nbsp;cfbecab&nbsp;Fantastic&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Ooops.
Despite the firm warning from Git, we have inadvertently deleted the <strong>zaney</strong> branch by mistake.
This does happen.
When people are in the thick of it, they do make mistakes and it is comforting to know that Git is able to recover from this, but how? We have deleted the branch reference that pointed to the commit that was at the tip of the <strong>zaney</strong> branch by using the <code class="ncode">-d</code> and <code class="ncode">-D</code> parameters.
So the question is, does that commit still exist any more? Maybe we did more damage than we thought.
By deleting all references to the commit, how do we get it back?<br><br>All is most definitely not lost.
Even though we have removed all references to the commits in question, they still exist in the repository.
They will continue to so unless we run a clean up on the repository, which will be covered later, or if the items are left to age for more that at least fourteen days.
This means that we have up to two weeks to try to recover the lost commits.
Of course in practice one would hope that we would perform the recovery much earlier than that.<br><br>We already know the commit ID that the branch was pointing to.
Git has been very kind and told us it, just before it carried out the delete.
We are looking for commit <strong>7cc32db</strong>.
If we run the command below, we will create and recover our branch in one go.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;zaney&nbsp;7cc32db</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-v</code><br&nbsp;/>
<code>*&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;9710177&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>&nbsp;&nbsp;wacky&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9710177&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>&nbsp;&nbsp;wonderful&nbsp;cfbecab&nbsp;Fantastic&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7cc32db&nbsp;Made&nbsp;another&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Our branch has been restored and points to the same place as it did before we deleted it.
As each commit points to its parent, we now have the complete history of <strong>zaney</strong> restored and the branch can be used as normal.
To complete this action, let us delete the <strong>wacky</strong> branch as originally intended.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-d&nbsp;wacky</code><br&nbsp;/>
<code>Deleted&nbsp;branch&nbsp;wacky&nbsp;(was&nbsp;9710177).</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-v</code><br&nbsp;/>
<code>*&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;9710177&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>&nbsp;&nbsp;wonderful&nbsp;cfbecab&nbsp;Fantastic&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7cc32db&nbsp;Made&nbsp;another&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, when we deleted <strong>wacky</strong> we were not warned about unmerged changes.
This is because the <strong>wacky</strong> branch is at the same point as the <strong>master</strong> branch.<br><h2>Day 5 - "Conflicting information"</h2>
<h3>What to do when it all goes wrong</h3>
The team have been playing with branches for a few days now and are beginning to settle into the idea of branching often.
As you can see, in Git, a branch is a really simple device for allowing experimentation and development.
As the implementation of branches is so simple, it is also really fast to switch between branches.
If you have been keeping up with the <em>After Hours</em> sections, you can hopefully see that when switching branches, Git only needs to alter what is different between one working copy and another.<br><br>Let us see what new issues the team runs into during Week 4.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Hmm," the puzzled noise reverberated round Klaus' corner of the office.
Mumbling commenced.
"So if I did that, then why is that not ... I mean I didn't think ... that's probably the problem Klaus ... sill 'luser'."
He chuckled to himself, hardly noticing the looming figure of John.<br><br>"You got a conflict," said John matter of factly.<br><br>"I can see that," came Klaus' reply.
"The problem is how do I solve it"<br><br>"What were you doing?"<br><br>"Well I had a few branches I had been working on and I was trying to merge them in."<br><br>"Figures," said John.
</div><hr><br>Conflicts are bound to happen at some point.
Even the best project processes in the world will sometimes end up with a conflict that has to be resolved.
We should, at this point, clarify what a conflict actually is.
A conflict occurs when an attempt is made to reconcile multiple changes to the same section of a file at the same time.
This usually means that the same line of code is modified by two different parties at the same time.
Now that we have several branches in our test repository, let us merge them back into master and see if we come up with a conflict.<br><br>First we are going to add a little change to one of our files.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"Another&nbsp;update&nbsp;to&nbsp;this&nbsp;file"&nbsp;&gt;&gt;&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Updated&nbsp;third&nbsp;file'</code><br&nbsp;/>
<code>[master&nbsp;4ac9201]&nbsp;Updated&nbsp;third&nbsp;file</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now let us merge in our <strong>wonderful</strong> branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;merge&nbsp;wonderful</code><br&nbsp;/>
<code>Merge&nbsp;made&nbsp;by&nbsp;recursive.</code><br&nbsp;/>
<code>&nbsp;newfile1&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;newfile2&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;2&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So far, our merge has gone pretty well.
We have taken all of the changes that were made in the <strong>wonderful</strong> branch and pulled them into our <strong>master</strong> branch.
If we wanted to, we could continue on making changes to the <strong>wonderful</strong> branch and we could keep pulling changes in from one to the other as time went by.
Figure 5 shows what our repository looks like now.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w4-d5.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 5</strong><br>Repository state after <strong>wonderful</strong> merge</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Our repository tree looks a little strange now.
Notice that the most recent commit, <strong>b119573</strong>, has two parents.
Can this be true? If we run our <code class="ncode">git show</code> command against that commit ID, we see something new.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;show&nbsp;b119573</code><br&nbsp;/>
<code>commit&nbsp;b119573f4508514c55e1c4e3bebec0ab3667d071</code><br&nbsp;/>
<code>Merge:&nbsp;4ac9201&nbsp;cfbecab</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Apr&nbsp;1&nbsp;07:35:13&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Merge&nbsp;branch&nbsp;'wonderful'</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice the line <code class="ncode">Merge: 4ac9201 cfbecab</code>, which simply tells us that this is a special type of commit, a merge commit.
When we previously performed a merge, the branch we were merging back into had not changed since we branched off and did our development work.
If you remember, we called this a <em>fast-forward</em> merge, simply because we moved our <em>destination</em> branch forwards to meet the tip of the development branch.<br><br>This time things are a little different.
During out development time on <strong>wonderful</strong>, something changed on <strong>master</strong>.
We did not make many alterations, but just the fact that we made some changed the way the merge was performed.
In fact, we can see this if we look at the first line after the merge.
Instead of indicating a <em>fast-forward</em> merge, it now states that the merge was <em>recursive</em>.
If you are interested in the different types of merge algorithms, you should read the <em>After Hours</em> section for this chapter.<br><br>So now the history of this latest commit actually relies on two previous commits.
The changes that have been introduced in these commits are merged together to form a combined tree of files.
This is the snapshot that is represented in commit <strong>ba0bfc</strong>.<br><br>Let us now remove that third file before merging in the <strong>zaney</strong> branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;rm&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>rm&nbsp;'my_third_committed_file'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Removed&nbsp;third&nbsp;file'</code><br&nbsp;/>
<code>[master&nbsp;ed2301b]&nbsp;Removed&nbsp;third&nbsp;file</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;0&nbsp;insertions(+),&nbsp;2&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So now we are ready to merge in the <strong>zaney</strong> branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;merge&nbsp;zaney</code><br&nbsp;/>
<code>Auto-merging&nbsp;newfile1</code><br&nbsp;/>
<code>CONFLICT&nbsp;(content):&nbsp;Merge&nbsp;conflict&nbsp;in&nbsp;newfile1</code><br&nbsp;/>
<code>Auto-merging&nbsp;newfile2</code><br&nbsp;/>
<code>CONFLICT&nbsp;(content):&nbsp;Merge&nbsp;conflict&nbsp;in&nbsp;newfile2</code><br&nbsp;/>
<code>Automatic&nbsp;merge&nbsp;failed;&nbsp;fix&nbsp;conflicts&nbsp;and&nbsp;then&nbsp;commit&nbsp;the&nbsp;result.</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Oh dear! That probably did not go as well as we had hoped.
We have two conflicts.
The first is in <code class="ncode">newfile1</code> and the second in <code class="ncode">newfile2</code>.
You may be wondering why.
The last commit we made did not make any changes to either of those files, so why do we suddenly have a conflict? When using a version control system like Git, conflicts are an every day part of life.
A conflict does not mean you have done something wrong.
It simply means that the automatic merging algorithm can not merge the changes.<br><br>In this case we have a conflict because the files have changed in both sides of the merge, since they diverged.
Rephrasing this slightly: Since the point when we created the branch <strong>zaney</strong>, at commit <strong>55fb69</strong>, both the <strong>master</strong> branch and the <strong>zaney</strong> branch have both modified the same files in the same places.
Right now, our merge is paused.
For now, let us abort the merge so that we can take a closer look at what happened.
<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;reset&nbsp;--merge</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So let us compare the changes between our latest common ancestor and our branch tips.
We will first look at the difference between the ancestor and our <strong>master</strong> branch, but limit it to the files with conflicts.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff&nbsp;55fb69&nbsp;master&nbsp;--&nbsp;newfile*</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile1&nbsp;b/newfile1</code><br&nbsp;/>
<code>index&nbsp;24e7dfa..ef20984&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile1</code><br&nbsp;/>
<code>+++&nbsp;b/newfile1</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>+and&nbsp;some&nbsp;more&nbsp;changes</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile2&nbsp;b/newfile2</code><br&nbsp;/>
<code>index&nbsp;cba16cc..dac4357&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile2</code><br&nbsp;/>
<code>+++&nbsp;b/newfile2</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>+and&nbsp;a&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we will do the same between the common ancestor and the tip of <strong>zaney</strong>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff&nbsp;55fb69&nbsp;zaney&nbsp;--&nbsp;newfile*</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile1&nbsp;b/newfile1</code><br&nbsp;/>
<code>index&nbsp;24e7dfa..d94dacc&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile1</code><br&nbsp;/>
<code>+++&nbsp;b/newfile1</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>+and&nbsp;some&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile2&nbsp;b/newfile2</code><br&nbsp;/>
<code>index&nbsp;cba16cc..45659d7&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile2</code><br&nbsp;/>
<code>+++&nbsp;b/newfile2</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>+and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So hopefully you can see that we have tried to change the second line in both files.
This is where the conflict is arising from.
Let us try to run the merge again and this time we will resolve the conflicts manually.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;merge&nbsp;zaney</code><br&nbsp;/>
<code>Auto-merging&nbsp;newfile1</code><br&nbsp;/>
<code>CONFLICT&nbsp;(content):&nbsp;Merge&nbsp;conflict&nbsp;in&nbsp;newfile1</code><br&nbsp;/>
<code>Auto-merging&nbsp;newfile2</code><br&nbsp;/>
<code>CONFLICT&nbsp;(content):&nbsp;Merge&nbsp;conflict&nbsp;in&nbsp;newfile2</code><br&nbsp;/>
<code>Automatic&nbsp;merge&nbsp;failed;&nbsp;fix&nbsp;conflicts&nbsp;and&nbsp;then&nbsp;commit&nbsp;the&nbsp;result.</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;cat&nbsp;newfile1</code><br&nbsp;/>
<code>A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&nbsp;HEAD</code><br&nbsp;/>
<code>and&nbsp;some&nbsp;more&nbsp;changes</code><br&nbsp;/>
<code>=======</code><br&nbsp;/>
<code>and&nbsp;some&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&nbsp;zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;cat&nbsp;newfile2</code><br&nbsp;/>
<code>Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&nbsp;HEAD</code><br&nbsp;/>
<code>and&nbsp;a&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>=======</code><br&nbsp;/>
<code>and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&nbsp;zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We have displayed the contents of <code class="ncode">newfile1</code> and <code class="ncode">newfile2</code> during this merge.
At the moment, no commits have been made and we have a chance to tell Git exactly what these files should look like.
You should be able to see that Git has modified the files to show us what both the branches think the file should look like.
At the top, just after the <code class="ncode">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> is how the line was modified in the <strong>master</strong> branch.
We then have a divider <code class="ncode">=======</code> and after that we have the line, as it was modified in the <strong>zaney</strong> branch, followed by <code class="ncode">&gt;&gt;&gt;&gt;&gt;&gt;&gt; zaney</code>.
We can now edit these files manually, remove the dividers, header and footer and commit the result.<br><br>We are going to edit <code class="ncode">newfile1</code> to look like this:<br><br><div id="codeblock"><code>A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We will also edit <code class="ncode">newfile2</code> to look like this:<br><br><div id="codeblock"><code>Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>and&nbsp;a&nbsp;new&nbsp;awesome&nbsp;feature</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we have resolved the conflicts and set the files straight, we can add the files and commit the result.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;newfile*</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Merged&nbsp;in&nbsp;zaney'</code><br&nbsp;/>
<code>[master&nbsp;d50ffb2]&nbsp;Merged&nbsp;in&nbsp;zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;-n2</code><br&nbsp;/>
<code>commit&nbsp;d50ffb2fa536d869f2c4e89e8d6a48e0a29c5cc1</code><br&nbsp;/>
<code>Merge:&nbsp;ed2301b&nbsp;7cc32db</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Apr&nbsp;1&nbsp;07:42:04&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Merged&nbsp;in&nbsp;zaney</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;ed2301ba223a63a5a930b536a043444e019460a7</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Apr&nbsp;1&nbsp;07:37:34&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;third&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Our merge has been completed.
Let us now see what our repository looks like graphically, in Figure 6.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w4-d6.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 6</strong><br>Repository state after <strong>zaney</strong> merge</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>It is quite reasonable that you may want to continue working on branches after you have integrate those changes back into your master.
Obviously you would have to merge your <strong>master</strong> branch back into <strong>zaney</strong> or any of the others, otherwise you could be developing on older versions of the code.
This brings up an interesting point which will be covered in a later chapter, as there are multiple ways to keep a development branch up to date.<br><br>So, at the end of this week, we have learnt how to create branches, how to merge them, and how to resolve conflicts.
It should be stressed that a conflict is not a <strong>bad</strong> thing.
Conflicts do happen and when they do you should simply take your time and resolve the conflict in order to represent the <em>best of both worlds</em>.
The <em>After Hours</em> section for Week 4, takes a closer look at merging and explains some more about what branches are at a repository level.<br><br><h2>Summary - John's Notes</h2>
<h3>Commands</h3>
<div style="padding-left:10px;"><ul><li><code class="ncode">git branch &lt;branch_name&gt;</code> - Creates a new branch with a given name</li>
<li><code class="ncode">git checkout &lt;branch_name&gt;</code> - Switches to a new branch</li>
<li><code class="ncode">git log -n1</code> - Limits the output of the log command to only a single commit</li>
<li><code class="ncode">git branch -v</code> - Verbosely list all local branches</li>
<li><code class="ncode">git show &lt;reference&gt;</code> - Show the information pointed to by the reference</li>
<li><code class="ncode">git merge &lt;branch_name&gt;</code> - Merge in a given branch to the current one</li>
<li><code class="ncode">git checkout -b &lt;branch_name&gt;</code> - Create a new branch and switch into it in one go</li>
<li><code class="ncode">git reset --hard &lt;commit_ref&gt;</code> - Reset a branch to a specific commit reference</li>
<li><code class="ncode">git log --graph --pretty=oneline --all  --abbrev-commit --decorate</code> - Shows a graphical view of the repository</li>
<li><code class="ncode">git log --graph --oneline --all --decorate</code> - A shorter form of the above command</li>
<li><code class="ncode">git branch -d &lt;branch_name&gt;</code> - Delete a branch that has already been merged</li>
<li><code class="ncode">git branch -D &lt;branch_name&gt;</code> - Forcibly delete a branch</li>
<li><code class="ncode">git branch &lt;branch_name&gt; &lt;commit_ref&gt;</code> - Create a new branch, starting at the commit reference</li>
<li><code class="ncode">git reset --merge</code> - Abort a merge and reset back to pre-merge state</li>
<li><code class="ncode">git diff &lt;commit_1&gt; &lt;commit_2&gt; -- &lt;files&gt;</code> - Show the difference between the two commits, for certain files</li>
</ul></div><br><h3>Terminology</h3>
<div style="padding-left:10px;"><ul><li><strong>Conflict</strong> - A conflict occurs when an attempt is made to reconcile multiple changes to the same section of a file at the same time.</li>
<li><strong>Fast-Forward Merge</strong> - The simplest merge type, which simply winds a branch forward in time to meet the tip of another.</li>
</ul></div>

<h1>After Hours Week 4</h1>
<h2>"Merge merge merge"</h2>
<h3>How does merging work?</h3>
To start with, we need to define which merging strategy we are talking about.
In Git there are multiple ways to instruct a merge to take place.
Below is a brief list of the options that you can supply to the <code class="ncode">git merge</code> command along with a brief description of how each one affects the merge process.
We will explain the details a little more further on.
<br><div style="padding-left:10px;"><ul><li><strong>resolve</strong> - A two headed merge strategy using a 3-way merge algorithm.
This is used by default in Git.</li>
<li><strong>recursive</strong> - A two headed merge strategy using a 3-way merge algorithm.
This algorithm looks at situations where multiple common ancestors are eligible and creates a merged tree of the common ancestors to be used as a reference.
Usually, this method has less conflicts and carries with it multiple sub-options.</li>
<li><strong>octopus</strong> - This merge strategy can merge in multiple heads.
When trying to pull multiple topic branches into a single merge, an <strong>octopus</strong> is the default method that Git will use.</li>
<li><strong>ours</strong> - Another multiple head strategy, which simply ignores all changes from the other branches.
At first it may sound like a useless idea, but it could be used to keep the history of a branch without actually keeping the branch itself.</li>
<li><strong>subtree</strong> - A much more advanced merge strategy based on the <strong>recursive</strong> which trees are adjusted to result in a better merge.</li>
</ul></div><br>Now that we are aware of the different options available to us, let us discuss what happens when we actually perform a merge.
Let us consider the state of our repository at the end of Week 4, as shown in Figure 1.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w4-d6.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 6</strong><br>Repository at the end of <em>Week 4</em></div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>For arguments sake, let us say that we were on the <strong>wonderful</strong> branch, and we wanted to merge the <strong>zaney</strong> branch into it.
Using a standard 3-way merge algorithm, this would mean taking our current branch, which we will call <strong>A</strong>, the <strong>zaney</strong> branch, which we will call <strong>B</strong> and a parent which we will <strong>C</strong>.
Why do we need this parent? What is it used for?<br><br>In order to merge changes from a specific file together, we need to know exactly how that file has changed over time.
In order to know that, we need to have a common starting point.
By that we mean that we need to have a state in both of the branches history, where <strong>A</strong> and <strong>B</strong> were the same.
In a version control system, this is most easily achieved by finding a commit that is common to the history of both branches.
This commit is called the <em>Best Common Ancestor</em>.<br><br>Usually, when developing software, the code tree will be branched at various points along the way.
Sometimes we may need to merge these branches together, or merge these branches back into the master branch.
Which ever way we do it, we will need to find a common ancestor.
Figure 2, demonstrates a couple of possible merge proposals, and one of their common ancestors.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af4-d2.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 2</strong><br>Finding the <em>Best Common Ancestor</em></div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>As you can see from the second example, branch <strong>B</strong> was created from a commit above the <em>Common Ancestor</em>, but the <em>Common Ancestor</em> remains the same.<br><br>Let us go back to our example above.
We are attempting to merge in <strong>zaney</strong> to the <strong>wonderful</strong> branch.
We need to find the <strong>C</strong> in our equation.
To do this we could pour over Figure 1.
This should yield the result to be commit <strong>9710177</strong>.
Is there are way we can ask Git to do the same thing? The following output introduces a new command that is used to find the <em>Best Common Ancestor</em> for a given merge proposal.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-af4$&nbsp;git&nbsp;merge-base&nbsp;wonderful&nbsp;zaney</code><br&nbsp;/>
<code>9710177657ae00665ca8f8027b17314346a5b1c4</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-af4$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;9710177</code><br&nbsp;/>
<code>tree&nbsp;268f487e5c29a4b01c3a91637bac0024253fb77e</code><br&nbsp;/>
<code>parent&nbsp;55fb69f4ad26fdb6b90ac6f43431be40779962dd</code><br&nbsp;/>
<code>author&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;&nbsp;1301613377&nbsp;+0100</code><br&nbsp;/>
<code>committer&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;&nbsp;1301613377</code><br&nbsp;/>
<code>&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-af4$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>In our example, <code class="ncode">git merge-base</code> uses two parameters to speficy the two heads that we wish to merge.
We can see that the commit that Git suggests as the <em>Best Common Ancestor</em> is what we suggested above, <strong>9710177</strong>.
We have reused our <code class="ncode">git cat-file</code> command to prove that the commit is the one we suggested, as you can see, the commit messages match.<br><br>This explains how a simple merge takes place, Git will find the common ancestor, and try to merge in the differences to produce a merged version.
If the merge cannot take place, then as shown in <em>Week 4</em>, Git will put all the changes in the file, label them, and then raise a conflict for the user to resolve.<br><br>With the information presented here, you should now be able to reread the descriptions above and understand what is going on at a base level.
If you require further information on merging, there is a wealth of documentation and papers about merge algorithms on the Internet.<br><h2>"Grepping your life away"</h2>
<h3>A subtle twist on searching</h3>
As well as our <code class="ncode">git log</code> tool, which we have used for searching, it is useful to know that there is actually another way to search for strings in your current directory.
We can use the <code class="ncode">git grep</code> tool to find all files in our working tree which have a certain pattern in them.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;grep&nbsp;awesome</code><br&nbsp;/>
<code>newfile1:and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>newfile2:and&nbsp;a&nbsp;new&nbsp;awesome&nbsp;feature</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>This has returned two files, both containing the string <code class="ncode">awesome</code>, as this is the parameter that we passed to the <code class="ncode">git grep</code> command.<br><br>We can extend this a little further and ask Git to supply the context around the line that it finds.
In our simple case, it results in the following.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;grep&nbsp;-C3&nbsp;awesome</code><br&nbsp;/>
<code>newfile1-A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>newfile1:and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>--</code><br&nbsp;/>
<code>newfile2-Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>newfile2:and&nbsp;a&nbsp;new&nbsp;awesome&nbsp;feature</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>This is just a short introduction to the <code class="ncode">git grep</code> command.
If you want to know more, you should spend some time reading the manual.


<h1>Week 5</h1>
<h2>Day 1 - "This isn't working for me John"</h2>
<h3>Dealing with resistance</h3>
So, now that the team have discovered the basics of branching, they are conceptually ready to start using it in earnest.
When implementing a version control system, or shifting from one to another, it is important to make sure that the users are happy with the system and know how to use it.
Training is a big issue.<br><br>It would seem that the team have coped with the initial usage of Git and that they have utilised each others talents in specific areas to pull together a good learning environment.
However, one thing to bare in mind is that some users may secretly be having a far worse experience than their colleagues.
It is also common for these people to suffer in silence, or to wait until they are asked for their opinions on the system before they bring up any issues.<br><br>It is because of these very factors that you should probably consider employing a parallel implementation.
This is exactly what John decided to do with Tamagoyaki Inc's implementation of Git.
Whilst a parallel implementation does take duplicate effort in some areas, it also allows the team to return to their original system, should insurmountable obstacles present themselves.
However, a parallel implementation should never be an excuse not to eventually shift over to the new system, unless serious issues are discovered.<br><hr><div id="calloutblock"><h3>Terminology - Parallel Implementation</h3><br>Parallel implementation means keeping your old system running, whilst bringing up a new one.
It incurs extra effort in many areas, such as system administration, backups and system usage, but it allows people to evaluate a product in a real life situation.
Usually people will have completed all of their preliminary testing before moving onto Parallel implementation.
It would be assumed that you were fairly certain that your were going to move forward with a final implementation, before taking the time of setting up and training people on the new system.<br><br>It does however allow people to continue with the day jobs, without the risk of issues with the new system completely blocking them from working.
This is often a critical factor when implementing a new system.
If the system is successful, over time, the users will migrate away from the old system and start using the new system exclusively.
Care should also be taken that whilst in the midst of parallel implementation, both systems remain up to date at all times, this is often the trickiest part.
In Tamagoyaki Inc's case, because they were just using tarballs of their code base, it is easy for them to tar up a folder, as well as commit it to the repository.
</div><hr><br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"I'm sorry John, but I just can't do this anymore!"
Eugene was leaning over the partition wall, the keys that hung around his neck clattering loudly as he swayed.
"You hard core devs may be happy with all that command line junk, but I'm a GUI kinda guy. It doesn't come as easily for me as if does for you."<br><br>"You should learn how to use a computer properly then," shouted Klaus before laughing.<br><br>Eugene was livid, "You're such a damn elitist Klaus. I'm so glad I don't have to share a pod with you anymore, you zealot."
With that, Eugene was off, flinging open the door to the office area and stomping off to his desk.<br><br>"Nice one Klaus," said John,
"You know, you could be a little more tactful. We do still need sign off from him to complete this project."<br><br>Klaus shrugged.<br><br> * * * <br><br>"Listen Eugene, I think I have a way to help you out. There is a GUI component to Git that you can use."
John was trying his best, but five minutes of grovelling to Eugene, hadn't exactly paid off.<br><br>"I'll try your GUI, but if I don't like it, I'm not signing off."
He was serious too.
"I don't have time to waste learning this system, I never needed versioning before, why should I need it now."<br><br>"We have to work together on things now Eugene," began John,
"You know there is a merger looming, right?"<br><br>Eugene looked up, a little stunned.<br><br>"We have to show we can function well as a team, that we have everything in hand. Let's leave the integration till the end of the week, to give you a little more time to get used to things."<br><br>"OK" said Eugene,
"I'll give it my best shot"
</div><hr><br>Sometimes, dealing with resistance to new systems is hard.
In Tamagoyaki Inc, John was blessed with the fact that only one developer didn't like the system he had picked.
Fortunately, the developer in question was only really concerned with the lack of a GUI, something that Git actually provides anyway.<br><br>It is very important to listen to users issues and questions.
Often they may discover a big hole in your initial planning which you would never have seen.
Never dismiss a concern before looking into it as it can be difficult for one person to understand the entire process in place during development, no matter how well documented it is.
Going through a period of User Acceptance Testing is crucial before complete adoption is even considered.<br><br>Let us take a while to explore the build in GUI that Git comes bundled with.<br><h3>A little bit of graphics</h3><br>Whilst using a GUI can be faster for some operations, it is also worth noting that with very few exceptions, GUIs are often less feature rich than their CLI counterparts.
It is very time consuming to write a GUI that can deal with every command option a user desires, so often the GUI will handle the most common use cases, leaving the CLI to handle special cases.<br><br>Git is no exception to this rule.
Whilst the GUI component is a very capable tool indeed, it does lack most of the advanced functionality that can be found on the command line.
In fact, there are even some of the basic parameters to some of the commands that we have used earlier, that are not available in the GUI counterpart.<br><br>We can invoke the GUI by running the <code class="ncode">git gui</code> command.
We will be presented with a window similar to that in Figure 1.
Note that in this case, we are running it against our test repository that we have been working on through previous chapters.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d1.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 1</strong><br>Initial Git GUI view</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>This initial window is composed of four key areas
<div style="padding-left:10px;"><ol><li><strong>Unstaged</strong> - This area on the screen shows all of the items present in the working copy which are unstaged, that is to say they have not yet been added to the index and so will not be included if a commit were to take place.</li>
<li><strong>Staged</strong> - This area on the screen shows all of the items present in the index or staging area.
Everything listed here will be included if a commit takes place.</li>
<li><strong>Content View</strong> - This region of the window will show the contents of an item if it is selected in either the Unstaged or Staged areas.
If the file is already tracked, then the window will show a diff between the last committed version and the chosen version.</li>
<li><strong>Commit</strong> - From the commit section of the screen, the commit message can be written, the commit performed, the directory rescanned for changes, as well as other operations.</li>
</ol></div><br>If we take a closer look at the <strong>Unstaged</strong> area of the screen, we see something interesting.
This is shown in Figure 2.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d2.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 2</strong><br>Unstaged section</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>This is the only file in our working copy which contains unstaged changes.
That should not be surprising as this file has never been added to the repository so it is not considered <strong>tracked</strong> by Git.
If you remember, it was actually a temporary file that we piped some output to in an earlier chapter.
If we click on the filename of this file, the <strong>Content View</strong> area changes to show Figure 3.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d3.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 3</strong><br>Content view of <code class="ncode">temp_file</code></div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>In the top banner section of the <strong>Content View</strong> we see an indication of the file's status.
In this case it is <strong>Untracked</strong> and <strong>not staged</strong>.
We can change this by clicking on the small blank page icon to the left of the file name in the <strong>Unstaged</strong> area of the screen, see Figure 4.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d4.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 4</strong><br>Staged section</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Now the file has moved into the <strong>Staged</strong> area of the screen as would be equivalent to us doing a <code class="ncode">git add temp_file</code>.
The file has been added to the index and is now ready for committing.
We also notice a difference in the <strong>Content View</strong> of <code class="ncode">temp_file</code>.
This can be seen in Figure 5.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d5.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 5</strong><br>Content view of <code class="ncode">temp_file</code></div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Now the bar reads that the file is <strong>Staged for commit</strong>, which is exactly what we expect.
We are now going to fill out a commit message, which can be seen in Figure 6, and press the <strong>Commit</strong> button, to initialise a commit into the repository.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d6.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 6</strong><br>Preparing for commit</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>It should be noted here that we could have performed multiple operations here, adding several files to the staging area before pressing that all important <strong>Commit</strong> button.
We will finish this section off by checking the status area at the very bottom of the screen.
In Figure 7, you should see that our latest operation has been summarised by the string <code class="ncode">Created commit 35243bf8: Added temp_file</code><br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d7.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 7</strong><br>Status message showing new commit ID</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br><h2>Day 2 - "Back to logging"</h2>
<h3>Visualisation to the max</h3>
With the basic operations down, as we discovered in Week 1, let us now move on to using the GUI to view the history of our database.
The visualiser that is bundled with Git is packed with features and can be invoked in one of two ways, either by running <code class="ncode">gitk</code> from the command line, or by choosing <strong><em>Repository - Visualize All Branch History</strong></em> or <strong><em>Repository - Visualize master's Branch History</strong></em>, the latter menu item is worded with the assumption that you are on the <strong>master</strong> branch of course.<br><br>Whichever way we begin an instance of <code class="ncode">gitk</code>, we are likely to end up with a screen like the one in Figure 8.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d8.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 8</strong><br>Initial <code class="ncode">gitk</code> view</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Let us spend a few minutes familiarising ourselves with the layout of the <code class="ncode">gitk</code> tool.
The window is split up into roughly seven different areas.
We will take a brief look at each of these below.<br><div style="padding-left:10px;"><ol><li><strong>History Graph</strong> - This area of the screen gives a graphical representation of the history of our repository.
Similar to the <code class="ncode">git log --graph</code> option that we used previously, the graph here is much more readable.</li>
<li><strong>Committer History</strong> - The committer history tells us the person who added the commit which is horizontally adjacent in the commit graph.</li>
<li><strong>Date History</strong> - The date history is very similar to the committer history section of the screen and shows us a simple view of the date of the commit which is horizontally adjacent.</li>
<li><strong>History Search</strong> - This section of the screen allows you to narrow down and highlight a subset of commits which meet a certain criteria.
It also allows you to navigate through these results.</li>
<li><strong>Commit Search</strong> - Once you have highlighted a commit, the commit search section allows you to find specific strings within that commit, including looking at just old or new lines to the repository.</li>
<li><strong>Content View</strong> - This window actually shows the data that was stored in the commit and allows you scroll through either changes or complete files.</li>
<li><strong>File System View</strong> - The file system view shows you a list of files that were either modified in a specified commit, or that were present in the commit.</li>
</ol></div><br>To start with, let us take a look at the graph that is present in <strong>History Graph</strong> section of the screen in Figure 9.
Essentially this is just a very simplified version of the graphs we were drawing in the previous chapter.
As you can see, the only information that appears to be missing from the graph is the commit ID, which can be obtained quite easily by clicking on the relevant commit and viewing the string presented just below the graph pane.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d9.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 9</strong><br>Graphical history of repository</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>The historical graph shows us all active branches, tags and commits.
From looking at this it is easy to see where our merges occurred and where the branch HEADs point to.
The branches are identified by green rectangles, and the tags as yellow labels.
Each circle on the graph is a commit and is linked to the panes on the right, where you can see the committer and date information.<br><br>If we select the <strong>master</strong> branch HEAD, which should be the top commit, (in fact on opening <code class="ncode">gitk</code> this should already be selected), we should see a pane similar to Figure 10 in the <strong>Content View</strong> section of the screen.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d10.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 10</strong><br>Content view of master HEAD</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Notice in this that we have two parents listed, which is what we would expect, as the last commit we did was that of a merge from <strong>zaney</strong> into <strong>master</strong>.
Notice also that below this, we get to see a diff output of exactly what changed during this merge.
Interestingly, it shows that <code class="ncode">newfile1</code> loses one line from parent <strong>ed2301b</strong> and another from parent <strong>7cc32db</strong>.
These are both replaced by the next line, which reads <code class="ncode">and some more awesome changes</code>.<br><br>The current commit is a little special as it is a merge.
If you choose any normal commit, you can use the <code class="ncode">Diff</code>, <code class="ncode">Old version</code> and <code class="ncode">New version</code> buttons to either show what the file used to look like (Old), what it looks like now (New), or the default view which is the Diff and shows the combination of the changes.<br><br>Above the <strong>File System View</strong> pan is a button to switch between <code class="ncode">Patch</code> and <code class="ncode">Tree</code> views.
By default, this is set to <code class="ncode">Patch</code> and changes what the <strong>Content View</strong> pane displays.
When set to <code class="ncode">Patch</code>, this shows us the changes between the old commit and the new one.
However, when we switch this to <code class="ncode">Tree</code> view the <strong>Content View</strong> pane changes to show the contents of a file selected from its pane, at the current commit.
In this way, it allows you to browse and display files from previous commits graphically and effortlessly.
Simply select the commit, selected <code class="ncode">Tree</code> mode, choose the file, et voila, it is presented in the <strong>Content View</strong> pane.<br><br>So as you can see, the <code class="ncode">gitk</code> tool is already quite powerful.
We are now going to take things a step further.
Remember in <strong>Week 3</strong> we had a way of searching the repository for the introduction of a string.
We can do the exact same thing with <code class="ncode">gitk</code>.<br><br>We are going to drop down the box which currently reads <code class="ncode">contains:</code> in the <strong>History Search</strong> pane and change it to <code class="ncode">add/removing string:</code>.
Then we are going to enter <code class="ncode">Change1</code> into the field on the right.
Your changes should look similar to Figure 11.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d11.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 11</strong><br>Searching for a string</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>After you have finished typing you should already have noticed a difference in the <strong>History Graph</strong> pane.
Notice how some commits are now highlighted in bold, as demonstrated in Figure 12?<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d12.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 12</strong><br>Search results</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>If you remember from Week 3, when we first ran the <code class="ncode">git log -SChange1</code> command, we were presented with only one commit.
That was titled, <code class="ncode">Made a few changes to first and second files</code>.
Our repository has moved on since then and we can see that that particular string, <code class="ncode">Change1</code> was added or removed in two other commits as well.
This was when we totally changed <code class="ncode">my_second_committed_file</code> and when we removed <code class="ncode">my_first_committed_file</code> a little later.
The <strong>Next</strong> and <strong>Previous</strong> buttons can be used to navigate through the search results.<br><br>Now that we have found the commits that contain the change to the string we are looking for.
The question is, where in the file does this change occur? We can now use the <strong>Commit Search</strong> pane to see this.
Typing <code class="ncode">Change1</code> into this search box will highlight the relevant text in the <code class="ncode">Content View</code> pane below.
It really is as easy as that.<br><br>Whilst it is a great idea to remember and use the command line arguments and parameters, it is also useful to know that these other tools are available.
GUI tools should not be frowned upon, as some command line purists do.
GUI tools are as much a part of the development process as their command line counterparts.
Both have their uses and the most important lesson of all is to know when to use which.
This lesson will most likely come with experience and time, or as a friend of mine used to put it, old age.<br><h3>Customising the visualisation</h3><br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Eugene," called Klaus as the tools developer walked past him.
"Could I borrow you for a second?"<br><br>"I guess," said Eugene coldly.
"What is it that you want exactly?"<br><br>"Well," Klaus began,
"I started using the GUI tools a little and found something you might consider interesting. I know you spend a lot of time switching between different versions of our code looking for various functions and things and I found this cool tool in the GUI."<br><br>Eugene breathed in deeply.
Knowing Eugene, it wouldn't be anything amazing, but nevertheless, his interest had been piqued.
</div><hr><br>The <code class="ncode">gitk</code> tool has a pretty awesome feature called <em>views</em>.
Sometimes it may be necessary to keep track of everything a certain person has done.
Or maybe see anything that has happened in the last week.
You may even be interested in people adding certain strings to the repository.
The <em>views</em> feature allows you to do just that.
By setting up a view, you can filter the results that are displayed in <code class="ncode">gitk</code>, byt simply switching to it.<br><br>In the example we are going to go back to the search we made previously and filter the history for any changes to <code class="ncode">my_first_committed_file</code> that add or remove the string <code class="ncode">Change1</code>.
First we are going to load the dialog box, by using the menu <strong><em>View - New View...</strong></em>.
The resulting dialog is displayed below and we have already filled in the required information.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d13.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 13</strong><br>Setting up a <em>view</em></div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>We changed the <strong>View Name</strong> to be <code class="ncode">Change1</code>.
This is simply an identifier that will allow us to choose our view in the future.
We have also ticked the <strong>Remember this view</strong>.
Ticking this box ensures that the view is remembered once we close <code class="ncode">gitk</code>.
Sometimes, this behaviour is not desired, but in our case we want this view to be available every time we start <code class="ncode">gitk</code>.<br><br>There are many options which we can set, but in our case we have chosen to simply add <code class="ncode">Change1</code> to the <strong>Changes to files:</strong> section.
This is equivalent to the search that we performed earlier.
We have also filtered the files which are included in the results, by putting, <code class="ncode">my_first_committed_file</code> in the <strong>Enter files and directories to be included</strong> box.<br><br>The result of this view is shown in Figure 14.
Notice that instead of all the commits being shown, we are just shown the two that we are interested in.
Both of these commits are referred to earlier in the chapter, when we ran the search manually in <code class="ncode">gitk</code><br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d14.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 14</strong><br>View results</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>This ends our tour of the <code class="ncode">gitk</code> utility.
Hopefully you have seen that it can actually present a large amount of information in a very compact and usable way.
As such it should not be forgotten about and should remain part of your arsenal of Git tools.<br><h2>Day 4 - "Advanced Techniques"</h2>
<h3>Getting more done graphically</h3>
Whilst <code class="ncode">git gui</code> can perform commits.
It is interesting to note that it can do a whole lot more.
One feature, which can be exceedingly useful is the <strong>File Browser</strong>.
This is invoked by using the <strong><em>Repository - Browse Branch's Files...</strong></em> menu item.<br><br>We can now select the point at which we want to browse the repository.
By default we are presented with a list of the branches present in the repository.
Note we can also choose tags, by selecting the appropriate option in the radio box.
We can also put things like <code class="ncode">HEAD</code> and <code class="ncode">HEAD~1</code> into the <strong>Revision Expression:</strong> text field.<br><br>The dialog box is shown in Figure 15.
Notice also that when we hover over the branch names, we are presented with a small pop up, telling us who made the last commit to the branch and what the commit message was.
Clicking the <strong>Browse</strong> button will take us to the next window, where we can choose the file we wish to view.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d15.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 15</strong><br>Point in history dialog</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>The file choosing dialog is rather plain.
Just double clicking on a file will start the <code class="ncode">git gui blame</code> tool.
Though primarily used as a way to see who, or what was responsible for a specific change to a line, this tool is also useful for seeing how a file has changed over time.
The file chooser dialog is shown in Figure 16.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d16.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 16</strong><br>File chooser</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Once selected, the file is displayed in its own window.
The window is split into two sections.
The top part of the window displays the actual content of the file, along with some commit IDs on the left.
In the lower part of the window, more information on a specific commit is shown.
This window is shown in Figure 17.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d17.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 17</strong><br>File viewer</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Clicking on a line in the view above, will turn that section green and will display the information related to that commit in the lower pane, along with the complete commit message.
It will also highlight all other lines in the current file that were also modified in that commit.
As shown in Figure 18.<br><br>Already this is a very powerful tool, much like the <code class="ncode">gitk</code> too for visualising the history of the repository, <code class="ncode">git gui blame</code> is also very useful for working through the events that led to the current version of a particular file.
In larger files, being able to click on a portion and have it highlight every other line in that file that was changed in that commit can be extremely useful.
By right clicking on the file, we can also choose the <strong>Show History Context</strong>, which will load <code class="ncode">gitk</code> and move the commit history pane to show the commit we are currently interested in.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d18.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 18</strong><br>File viewer, highlighting a commit</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>You should have noticed by now that each line has a commit ID associated with it, two in fact.
These are in fact links, and by clicking on these, we can wind the history of the file, back to that point, so that it shows not the state at which it originally did, but now the state as it was in the selected commit.
This is shown in Figure 19.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w5-d19.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 19</strong><br>Going back to a previous commit</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Again this is a hugely powerful tool.
You can navigate back to the current version of the file, or if you have clicked on several to get to your current point, review a history of your path, by clicking on the green arrow at the top of the screen.
You will be presented with a drop down menu, and from here you can choose which point you wish to return to.<br><h3>Our last stop</h3>
We have shown a number of things that Git can do in its GUI form.
We are not going to dwell on the graphical interface any further as you should already be familiar with the <strong>Merge</strong> and <strong>Branch</strong> menu items, which are present.
The have a number of options which are also available from the command line.<br><br>The <strong>Branch</strong> menu allows you to do the familiar procedures, such as checkout, create, rename and delete.
It also provides a limited reset feature.
The <strong>Merge</strong> menu provides shortcuts for running a merge, as well as aborting it.<br><br>It is here that we are going part with our newest tool in order to return to the command line interface once more.
We have one more trick up our sleeve and this will be presented in the <em>After Hours</em> section for the week.
As previously stated, the GUI tools form an important part of your version control arsenal.
Never be afraid to use them.
Remember, at the end of the day, you should be focussed on getting the job done and using whichever tools you require to do just that.<br><br><h2>Summary - John's Notes</h2>
<h3>Commands</h3>
<div style="padding-left:10px;"><ul><li><code class="ncode">git gui</code> - Invokes the Git GUI tool</li>
<li><code class="ncode">gitk</code> - Starts an instance of the graphical history tool for Git</li>
<li><code class="ncode">git gui blame &lt;path&gt;</code> - Opens the blame window for a specific file</li>
</ul></div><br><h3>Terminology</h3>
<div style="padding-left:10px;"><ul><li><strong>Blame</strong> - A way of find the commit that caused an issue in the repository.</li>
</ul></div>

<h1>After Hours Week 5</h1>
<h2>"Splitting up commits the easy way"</h2>
<h3>Taking commits that little bit further</h3>
Sometimes, putting everything in a single commit just is not a good idea.
Imagine you have pulled in number of updates to your working directory.
You may want to split these up.
It is true that you could simply <code class="ncode">git add</code> only the files you want to include in the commit.
However, what happens when you have change four or five different things in the same file, and you want to split that commit up into five different commits.<br><br>There are two ways you can approach this.
The first is to copy the file in question out of the working directory, reset the working copy back to the last committed and copy your changes in line by line.
This can be time consuming and frustrating and when you are working on many files, it can be totally impractical.
What we need is a way to include or exclude certain lines of a file.<br><br>To demonstrate this we are going to create a new branch called <strong>fantasy</strong> and we are going to make several changes to a few files.
We are then going to show how the same process can be achieved by using both the GUI and the command line.<br><br>So let us start by creating our branch and making some changes as shown below.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;fantasy</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;'fantasy'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"This&nbsp;is&nbsp;line&nbsp;1"&nbsp;&gt;&nbsp;newfile1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"This&nbsp;is&nbsp;line&nbsp;2"&nbsp;&gt;&gt;&nbsp;newfile1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"This&nbsp;is&nbsp;line&nbsp;3"&nbsp;&gt;&gt;&nbsp;newfile1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"This&nbsp;is&nbsp;line&nbsp;4"&nbsp;&gt;&gt;&nbsp;newfile1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"This&nbsp;is&nbsp;a&nbsp;new&nbsp;line"&nbsp;&gt;&gt;&nbsp;newfile2</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"This&nbsp;is&nbsp;another&nbsp;new&nbsp;line"&nbsp;&gt;&gt;&nbsp;newfile2</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Let us now just run a <code class="ncode">git diff</code> to see exactly what the changes are.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile1&nbsp;b/newfile1</code><br&nbsp;/>
<code>index&nbsp;44640b2..0eccf1a&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile1</code><br&nbsp;/>
<code>+++&nbsp;b/newfile1</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>-A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>-and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;1</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;2</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;3</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;4</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile2&nbsp;b/newfile2</code><br&nbsp;/>
<code>index&nbsp;3545c1d..40efcce&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile2</code><br&nbsp;/>
<code>+++&nbsp;b/newfile2</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>&nbsp;and&nbsp;a&nbsp;new&nbsp;awesome&nbsp;feature</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;a&nbsp;new&nbsp;line</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;another&nbsp;new&nbsp;line</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now, we could just do <code class="ncode">git commit -a</code> and be done with it, but what if we really wanted to split this information up into four commits? We will introduce a new parameter to our <code class="ncode">git add</code> tool from before.
We are going to use the <code class="ncode">git add -p</code> or <code class="ncode">git add --patch</code>.
This will allow us to interactively edit the hunks before they are committed.
To begin with, let us run <code class="ncode">git add -p</code> and see what it is we need to do.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;-p</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile1&nbsp;b/newfile1</code><br&nbsp;/>
<code>index&nbsp;44640b2..0eccf1a&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile1</code><br&nbsp;/>
<code>+++&nbsp;b/newfile1</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>-A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>-and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;1</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;2</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;3</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;4</code><br&nbsp;/>
<code>Stage&nbsp;this&nbsp;hunk&nbsp;[y,n,q,a,d,/,e,?]?</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We are given the options of <code class="ncode">y,n,q,a,d,/,e,?</code>.
At first glance, this may seem rather daunting.
Let us choose the <code class="ncode">?</code> and see what help is presented to us.<br><br><div id="codeblock"><code>Stage&nbsp;this&nbsp;hunk&nbsp;[y,n,q,a,d,/,e,?]?&nbsp;?</code><br&nbsp;/>
<code>y&nbsp;-&nbsp;stage&nbsp;this&nbsp;hunk</code><br&nbsp;/>
<code>n&nbsp;-&nbsp;do&nbsp;not&nbsp;stage&nbsp;this&nbsp;hunk</code><br&nbsp;/>
<code>q&nbsp;-&nbsp;quit,&nbsp;do&nbsp;not&nbsp;stage&nbsp;this&nbsp;hunk&nbsp;nor&nbsp;any&nbsp;of&nbsp;the&nbsp;remaining&nbsp;ones</code><br&nbsp;/>
<code>a&nbsp;-&nbsp;stage&nbsp;this&nbsp;and&nbsp;all&nbsp;the&nbsp;remaining&nbsp;hunks&nbsp;in&nbsp;the&nbsp;file</code><br&nbsp;/>
<code>d&nbsp;-&nbsp;do&nbsp;not&nbsp;stage&nbsp;this&nbsp;hunk&nbsp;nor&nbsp;any&nbsp;of&nbsp;the&nbsp;remaining&nbsp;hunks&nbsp;in&nbsp;the&nbsp;file</code><br&nbsp;/>
<code>g&nbsp;-&nbsp;select&nbsp;a&nbsp;hunk&nbsp;to&nbsp;go&nbsp;to</code><br&nbsp;/>
<code>/&nbsp;-&nbsp;search&nbsp;for&nbsp;a&nbsp;hunk&nbsp;matching&nbsp;the&nbsp;given&nbsp;regex</code><br&nbsp;/>
<code>j&nbsp;-&nbsp;leave&nbsp;this&nbsp;hunk&nbsp;undecided,&nbsp;see&nbsp;next&nbsp;undecided&nbsp;hunk</code><br&nbsp;/>
<code>J&nbsp;-&nbsp;leave&nbsp;this&nbsp;hunk&nbsp;undecided,&nbsp;see&nbsp;next&nbsp;hunk</code><br&nbsp;/>
<code>k&nbsp;-&nbsp;leave&nbsp;this&nbsp;hunk&nbsp;undecided,&nbsp;see&nbsp;previous&nbsp;undecided&nbsp;hunk</code><br&nbsp;/>
<code>K&nbsp;-&nbsp;leave&nbsp;this&nbsp;hunk&nbsp;undecided,&nbsp;see&nbsp;previous&nbsp;hunk</code><br&nbsp;/>
<code>s&nbsp;-&nbsp;split&nbsp;the&nbsp;current&nbsp;hunk&nbsp;into&nbsp;smaller&nbsp;hunks</code><br&nbsp;/>
<code>e&nbsp;-&nbsp;manually&nbsp;edit&nbsp;the&nbsp;current&nbsp;hunk</code><br&nbsp;/>
<code>?&nbsp;-&nbsp;print&nbsp;help</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>-A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>-and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;1</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;2</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;3</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;4</code><br&nbsp;/>
<code>Stage&nbsp;this&nbsp;hunk&nbsp;[y,n,q,a,d,/,e,?]?</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So it appears that Git is offering us the opportunity to either
<div style="padding-left:10px;"><ul><li>Stage it</li>
<li>Do not stage it</li>
<li>Quit,</li>
<li>Stage it and all remaining hunks</li>
<li>Do not stage it or any of the remaining ones</li>
<li>Search for a regex</li>
<li>Edit the hunk</li>
</ul></div><br>In fact, though the help mentioned a <strong>split</strong> command, we do not have this option available to us, due to the nature of our hunk.
Instead, if we wish to split this hunk, we are going to have to edit it manually.
To do this we will choose the <code class="ncode">e</code> option.<br><br>Here we are left in our chosen text editor, to either add, modify or remove lines from the hunk.
In our case, we are going to delete a few lines.
We only want to leave the first line of additions.
Just because we delete the others does not mean they are deleted from the working copy.
Remember, we are not editing the actual files here.
Just the hunks that are going to be staged.<br><br><div id="codeblock"><code>#&nbsp;Manual&nbsp;hunk&nbsp;edit&nbsp;mode&nbsp;--&nbsp;see&nbsp;bottom&nbsp;for&nbsp;a&nbsp;quick&nbsp;guide</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>-A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>-and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;1</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;2</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;3</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;4</code><br&nbsp;/>
<code>#&nbsp;---</code><br&nbsp;/>
<code>#&nbsp;To&nbsp;remove&nbsp;'-'&nbsp;lines,&nbsp;make&nbsp;them&nbsp;'&nbsp;'&nbsp;lines&nbsp;(context).</code><br&nbsp;/>
<code>#&nbsp;To&nbsp;remove&nbsp;'+'&nbsp;lines,&nbsp;delete&nbsp;them.</code><br&nbsp;/>
<code>#&nbsp;Lines&nbsp;starting&nbsp;with&nbsp;#&nbsp;will&nbsp;be&nbsp;removed.</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;If&nbsp;the&nbsp;patch&nbsp;applies&nbsp;cleanly,&nbsp;the&nbsp;edited&nbsp;hunk&nbsp;will&nbsp;immediately&nbsp;be</code><br&nbsp;/>
<code>#&nbsp;marked&nbsp;for&nbsp;staging.&nbsp;If&nbsp;it&nbsp;does&nbsp;not&nbsp;apply&nbsp;cleanly,&nbsp;you&nbsp;will&nbsp;be&nbsp;given</code><br&nbsp;/>
<code>#&nbsp;an&nbsp;opportunity&nbsp;to&nbsp;edit&nbsp;again.&nbsp;If&nbsp;all&nbsp;lines&nbsp;of&nbsp;the&nbsp;hunk&nbsp;are&nbsp;removed,</code><br&nbsp;/>
<code>#&nbsp;then&nbsp;the&nbsp;edit&nbsp;is&nbsp;aborted&nbsp;and&nbsp;the&nbsp;hunk&nbsp;is&nbsp;left&nbsp;unchanged.</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>After the deletes, the editors file should look like this.<br><br><div id="codeblock"><code>#&nbsp;Manual&nbsp;hunk&nbsp;edit&nbsp;mode&nbsp;--&nbsp;see&nbsp;bottom&nbsp;for&nbsp;a&nbsp;quick&nbsp;guide</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>-A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>-and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;1</code><br&nbsp;/>
<code>#&nbsp;---</code><br&nbsp;/>
<code>#&nbsp;To&nbsp;remove&nbsp;'-'&nbsp;lines,&nbsp;make&nbsp;them&nbsp;'&nbsp;'&nbsp;lines&nbsp;(context).</code><br&nbsp;/>
<code>#&nbsp;To&nbsp;remove&nbsp;'+'&nbsp;lines,&nbsp;delete&nbsp;them.</code><br&nbsp;/>
<code>#&nbsp;Lines&nbsp;starting&nbsp;with&nbsp;#&nbsp;will&nbsp;be&nbsp;removed.</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;If&nbsp;the&nbsp;patch&nbsp;applies&nbsp;cleanly,&nbsp;the&nbsp;edited&nbsp;hunk&nbsp;will&nbsp;immediately&nbsp;be</code><br&nbsp;/>
<code>#&nbsp;marked&nbsp;for&nbsp;staging.&nbsp;If&nbsp;it&nbsp;does&nbsp;not&nbsp;apply&nbsp;cleanly,&nbsp;you&nbsp;will&nbsp;be&nbsp;given</code><br&nbsp;/>
<code>#&nbsp;an&nbsp;opportunity&nbsp;to&nbsp;edit&nbsp;again.&nbsp;If&nbsp;all&nbsp;lines&nbsp;of&nbsp;the&nbsp;hunk&nbsp;are&nbsp;removed,</code><br&nbsp;/>
<code>#&nbsp;then&nbsp;the&nbsp;edit&nbsp;is&nbsp;aborted&nbsp;and&nbsp;the&nbsp;hunk&nbsp;is&nbsp;left&nbsp;unchanged.</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Once we quit our editor, we are then asked about the next hunk.
In our case, we are going to apply all of the changes to our second file during this commit.
To do this we are going to use the <code class="ncode">a</code> option.<br><br><div id="codeblock"><code>diff&nbsp;--git&nbsp;a/newfile2&nbsp;b/newfile2</code><br&nbsp;/>
<code>index&nbsp;3545c1d..40efcce&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile2</code><br&nbsp;/>
<code>+++&nbsp;b/newfile2</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>&nbsp;and&nbsp;a&nbsp;new&nbsp;awesome&nbsp;feature</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;a&nbsp;new&nbsp;line</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;another&nbsp;new&nbsp;line</code><br&nbsp;/>
<code>Stage&nbsp;this&nbsp;hunk&nbsp;[y,n,q,a,d,/,e,?]?&nbsp;a</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>At first glance, we do not appear to have been left with any indication that anything has taken place.
In order to perform a check we shall run our obligatory <code class="ncode">git diff</code>, both between the working copy and the index, and between the index and the last commit.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile1&nbsp;b/newfile1</code><br&nbsp;/>
<code>index&nbsp;f702b65..0eccf1a&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile1</code><br&nbsp;/>
<code>+++&nbsp;b/newfile1</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;This&nbsp;is&nbsp;line&nbsp;1</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;2</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;3</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;4</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So above, we can see that the difference between the working copy and the index, or staging area, is the last three lines that we are not ready to commit yet.
Below we can see the difference between the staging area and the last commit to the repository.
This includes the three lines that we included during our interactive commit preparation.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff&nbsp;--cached</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile1&nbsp;b/newfile1</code><br&nbsp;/>
<code>index&nbsp;44640b2..f702b65&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile1</code><br&nbsp;/>
<code>+++&nbsp;b/newfile1</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>-A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>-and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;1</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile2&nbsp;b/newfile2</code><br&nbsp;/>
<code>index&nbsp;3545c1d..40efcce&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile2</code><br&nbsp;/>
<code>+++&nbsp;b/newfile2</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>&nbsp;and&nbsp;a&nbsp;new&nbsp;awesome&nbsp;feature</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;a&nbsp;new&nbsp;line</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;another&nbsp;new&nbsp;line</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We can now commit in the normal way, and continue to edit the working copy to stage the sections we require.
The following output is shortened for brevity.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'Added&nbsp;first&nbsp;line'</code><br&nbsp;/>
<code>[fantasy&nbsp;03bd20c]&nbsp;Added&nbsp;first&nbsp;line</code><br&nbsp;/>
<code>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;3&nbsp;insertions(+),&nbsp;2&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;-p</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile1&nbsp;b/newfile1</code><br&nbsp;/>
<code>index&nbsp;f702b65..0eccf1a&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile1</code><br&nbsp;/>
<code>+++&nbsp;b/newfile1</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;This&nbsp;is&nbsp;line&nbsp;1</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;2</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;3</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;4</code><br&nbsp;/>
<code>Stage&nbsp;this&nbsp;hunk&nbsp;[y,n,q,a,d,/,e,?]?&nbsp;e</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'Added&nbsp;second&nbsp;line'</code><br&nbsp;/>
<code>[fantasy&nbsp;302e3fa]&nbsp;Added&nbsp;second&nbsp;line</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;-p</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We have gone through the process of editing each hunk for each commit and have performed the commits.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log</code><br&nbsp;/>
<code>commit&nbsp;a59e73b1dc571318a1154aa4c2fc591ab6f1f395</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Wed&nbsp;Apr&nbsp;13&nbsp;23:56:39&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Added&nbsp;fourth&nbsp;line</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;3ca3d627a54418be4c2e9d9196db6ce62e2b93ff</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Wed&nbsp;Apr&nbsp;13&nbsp;23:56:13&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Added&nbsp;third&nbsp;line</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;302e3fa5f880a2a503235667b4c96d4dcdaa11be</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Wed&nbsp;Apr&nbsp;13&nbsp;23:55:57&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Added&nbsp;second&nbsp;line</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;03bd20cb8a78a28f003ab402492cf7055f21bb2e</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Wed&nbsp;Apr&nbsp;13&nbsp;23:55:32&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Added&nbsp;first&nbsp;line</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Next we are going to see how to perform exactly the same procedure using <code class="ncode">git gui</code>.
For a start, we are going to reset our branch HEAD and our index back to their state before we made the last four commits, however we are going to leave the working copy files in the state they were after these last four commits.
This is called a <strong>mixed</strong> reset, as it modifies the staging area and the HEAD, but does not touch the working files.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;--oneline</code><br&nbsp;/>
<code>a59e73b&nbsp;Added&nbsp;fourth&nbsp;line</code><br&nbsp;/>
<code>3ca3d62&nbsp;Added&nbsp;third&nbsp;line</code><br&nbsp;/>
<code>302e3fa&nbsp;Added&nbsp;second&nbsp;line</code><br&nbsp;/>
<code>03bd20c&nbsp;Added&nbsp;first&nbsp;line</code><br&nbsp;/>
<code>d50ffb2&nbsp;Merged&nbsp;in&nbsp;zaney</code><br&nbsp;/>
<code>ed2301b&nbsp;Removed&nbsp;third&nbsp;file</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;reset&nbsp;--mixed&nbsp;d50ffb2</code><br&nbsp;/>
<code>Unstaged&nbsp;changes&nbsp;after&nbsp;reset:</code><br&nbsp;/>
<code>M	newfile1</code><br&nbsp;/>
<code>M	newfile2</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we will run a diff, just to be sure.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile1&nbsp;b/newfile1</code><br&nbsp;/>
<code>index&nbsp;44640b2..0eccf1a&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile1</code><br&nbsp;/>
<code>+++&nbsp;b/newfile1</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>-A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>-and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;1</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;2</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;3</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;line&nbsp;4</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile2&nbsp;b/newfile2</code><br&nbsp;/>
<code>index&nbsp;3545c1d..40efcce&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile2</code><br&nbsp;/>
<code>+++&nbsp;b/newfile2</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,4&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>&nbsp;and&nbsp;a&nbsp;new&nbsp;awesome&nbsp;feature</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;a&nbsp;new&nbsp;line</code><br&nbsp;/>
<code>+This&nbsp;is&nbsp;another&nbsp;new&nbsp;line</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>If we now run our <code class="ncode">git gui</code> command, we will see the changes that are present, once we click on one of the files in the left hand portion of the screen.
Let us start with <code class="ncode">newfile2</code> as we want every change from that file present in this commit.
Figure 1 shows what <code class="ncode">git gui</code> looks like at this stage.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af5-d1.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 1</strong><br>Changes to <code class="ncode">newfile2</code></div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>If we right click on one of the green lines, remembering that green is short for an <strong>addition</strong>, we get a menu which we have not seen before.
Among other things, this menu has the ability to stage a specific line or hunk for commit.
In our case we are going to hit the <strong>Stage Hunk For Commit</strong> and then move on to the next file, <code class="ncode">newfile1</code>.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af5-d2.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 2</strong><br>Changes to <code class="ncode">newfile1</code></div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Now we are looking at <code class="ncode">newfile1</code>, we can use the <strong>Stage Line For Commit</strong> to add specific lines into the staging area.
The file is shown in Figure 2.
As our file is so small, we can run into problems if we just choose lines at random and stage them.
This is because it is hard for Git to find context around which to associate the change.
The context is the area immediately surrounding the change we are making.
In order to reduce the risk of the error occurring, we are simply going to start at the top, and select the first three lines for committing, by right clicking on each on in turn and choosing the <strong>Stage Line For Commit</strong> option from the menu.<br><br>We have the changes that we expect ready to be committed.
If we want to check one last time that they are right, we can use the <strong>Staged Changes</strong> pane on the left to choose the file and inspect the diff.
Once we are happy we can use the <strong>Commit</strong> area of the window to type our commit message and emblazon our changes forever.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af5-d3.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 3</strong><br>Changes to <code class="ncode">newfile1</code> after staging</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Figure 3, shows what our file looks like after the first commit.
Interestingly, as our file is so small, you will probably find that <code class="ncode">git gui</code> throws a corrupt patch error if you try to just commit the next line.
As we mentioned earlier, it is always a good idea to know how to use the command line tools for precisely this reason.
Often you are dealing with special cases, that the GUI just can not handle.
In these cases, you may find you need to switch to the command line interface, to get the job done.<br><br>Let us now move back to our <strong>master</strong> branch and remove the <strong>fantasy</strong> branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-D&nbsp;fantasy</code><br&nbsp;/>
<code>Deleted&nbsp;branch&nbsp;fantasy&nbsp;(was&nbsp;29ceede).</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice that because we used the capitol <code class="ncode">-D</code> parameter, we were not asked if we were sure we wanted to delete the <strong>fantasy</strong> branch.<br><br>So in the <em>After Hours</em> section this week, we have found two ways to do the same complex task, one graphical and one command based.
Staging commits in this way may seem rather odd, but it will help you to keep your commits exceedingly exact.
Whilst this may not matter on a personal project, for Tamagoyaki Inc, grouping the right lines together in a commit will be an extremely useful process to have available.


<h1>Week 6</h1>
<h2>Day 1 - "My private little stash"</h2>
<h3>Getting interrupted</h3>
We're getting close to the point where we can really start using Git as we originally intended, the team at Tamagoyaki Inc.
are also getting much more acquainted with the operations of both version control and Git in particular.
Unfortunately things don't always go as smoothly as we would like.
The following scenario demonstrates just this.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Yeh but Martha, I need you to work on this fix now! Not in five minutes."<br><br>"Klaus I'm kinda in the middle of something else yet, and I'm not ready to commit," said Martha, feeling a little concerned.
She was used to Klaus making demands on his time, but she had spent a while working on this particular fix for John and she just wasn't ready to finish up yet.<br><br>"You could always use the stash feature."
It was Rob again, it seemed as if this young user had cottoned on to Git quicker than most of the seasoned developers."<br><br>Klaus seemed unimpressed, "What the heck does that do?"<br><br>"Allows you to move your changes to somewhere else until you are ready to finish them."<br><br>"Please Rob," started Martha,
"Can you show me what you mean? Sounds exactly like what I need"
</div><hr><br>Sometimes you could be in the middle of something when another really important task comes up.
When this happens you are often required to drop everything and carry on with another task.
Often this can be quite difficult.
You may be in a development branch, but unable or unwilling to make a commit at this stage.
So how can we deal with this?<br><br>Well, one way of dealing with this situation, and this is not necessarily the best way, is to do the steps outlined below;<br><div style="padding-left:10px;"><ol><li>Make a new branch called something like WIP</li>
<li>Pull changes into this new branch</li>
<li>Commit changes into WIP branch</li>
<li>Switch back to the branch we need to work on</li>
<li>Make our changes and commit them</li>
<li>Merge in our WIP branch on top with the <code class="ncode">--no-commit</code> option</li>
<li>Delete the WIP branch</li>
<li>Continue development in our original branch</li>
</ol></div><br>That may seem like a lot of work.
OK, the benefit is a fairly awesome one, but at the cost of considerable command line hackery to get there.
It would be nice if there was an easy way to do the above, and though someone of you may be screaming something like <em>shell script</em> right about now, you can rest your fingers.
We actually have another tool in the Git toolbox to help us out.<br><br>The <code class="ncode">git stash</code> command is used for exactly these situations.
Let us make a quick example of how to use it in our test repository.
To begin with we are going to make a few changes to the <strong>master</strong> branch, before we are interrupted.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Already&nbsp;on&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"Number&nbsp;strings&nbsp;rule&nbsp;1234"&nbsp;&gt;&gt;&nbsp;another_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So now we are interrupted and we have to make some important, and urgent changes to our <strong>master</strong> branch.
The example that follows is one way that we could use the <code class="ncode">git stash</code> command to help us out.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;stash</code><br&nbsp;/>
<code>Saved&nbsp;working&nbsp;directory&nbsp;and&nbsp;index&nbsp;state&nbsp;WIP&nbsp;on&nbsp;master:&nbsp;d50ffb2&nbsp;Merged&nbsp;in&nbsp;zaney</code><br&nbsp;/>
<code>HEAD&nbsp;is&nbsp;now&nbsp;at&nbsp;d50ffb2&nbsp;Merged&nbsp;in&nbsp;zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"Some&nbsp;mega&nbsp;important&nbsp;changes"&nbsp;&gt;&gt;&nbsp;newfile1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Important&nbsp;Update'</code><br&nbsp;/>
<code>[master&nbsp;9cb2af2]&nbsp;Important&nbsp;Update</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So using the <code class="ncode">git stash</code> command, we have squirrelled all of our developmental changes away into a <em>stash</em>.
Now we have completed the mega important change that just could not wait, we are ready to pull our changes back from the stash.
First let us see just what the stash contains.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;stash&nbsp;list</code><br&nbsp;/>
<code>stash@{0}:&nbsp;WIP&nbsp;on&nbsp;master:&nbsp;d50ffb2&nbsp;Merged&nbsp;in&nbsp;zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;stash&nbsp;show&nbsp;stash@{0}</code><br&nbsp;/>
<code>&nbsp;another_file&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;stash&nbsp;show&nbsp;stash@{0}&nbsp;-p</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/another_file&nbsp;b/another_file</code><br&nbsp;/>
<code>index&nbsp;dba885d..b3a5cc5&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/another_file</code><br&nbsp;/>
<code>+++&nbsp;b/another_file</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;New&nbsp;stuff</code><br&nbsp;/>
<code>+Number&nbsp;strings&nbsp;rule&nbsp;1234</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, the <code class="ncode">-p</code> option to the <code class="ncode">git stash show</code> command shows us exactly what is contained in the stash.
We can apply this stash by running the following;<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;stash&nbsp;apply&nbsp;stash@{0}</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Changed&nbsp;but&nbsp;not&nbsp;updated:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;checkout&nbsp;--&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;discard&nbsp;changes&nbsp;in&nbsp;working&nbsp;directory)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	modified:&nbsp;&nbsp;&nbsp;another_file</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;Untracked&nbsp;files:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;include&nbsp;in&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	my_third_committed_file</code><br&nbsp;/>
<code>#	temp_file</code><br&nbsp;/>
<code>no&nbsp;changes&nbsp;added&nbsp;to&nbsp;commit&nbsp;(use&nbsp;"git&nbsp;add"&nbsp;and/or&nbsp;"git&nbsp;commit&nbsp;-a")</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Continued&nbsp;Development'</code><br&nbsp;/>
<code>[master&nbsp;37950f8]&nbsp;Continued&nbsp;Development</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;stash&nbsp;list</code><br&nbsp;/>
<code>stash@{0}:&nbsp;WIP&nbsp;on&nbsp;master:&nbsp;d50ffb2&nbsp;Merged&nbsp;in&nbsp;zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Our stash has been applied to the current branch, in our case <strong>master</strong>, and we have gone ahead and committed these changes into the repository.
In this case we didn't have anything else to add to the index before we went ahead and committed it.<br><br>Interestingly though, our stash still exists.
If we had used the <code class="ncode">git stash pop</code> command instead of the <code class="ncode">git stash apply</code>, our stash would have been removed.
Of course we can have multiple stashes in our repository.
For completeness sake, let us learn how to manually remove a stash, and take a look at how our repository looks with our semi-graphical <code class="ncode">git log</code><br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;stash&nbsp;drop&nbsp;stash@{0}</code><br&nbsp;/>
<code>Dropped&nbsp;stash@{0}&nbsp;(193f27172fc0df278105b981815c7718204030d8)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;--graph&nbsp;--pretty=oneline&nbsp;--all&nbsp;--abbrev-commit&nbsp;--decorate</code><br&nbsp;/>
<code>*&nbsp;37950f8&nbsp;(HEAD,&nbsp;master)&nbsp;Continued&nbsp;Development</code><br&nbsp;/>
<code>*&nbsp;9cb2af2&nbsp;Important&nbsp;Update</code><br&nbsp;/>
<code>*&nbsp;&nbsp;&nbsp;d50ffb2&nbsp;Merged&nbsp;in&nbsp;zaney</code><br&nbsp;/>
<code>|\</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;7cc32db&nbsp;(zaney)&nbsp;Made&nbsp;another&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;a27d49e&nbsp;Made&nbsp;an&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>*&nbsp;|&nbsp;ed2301b&nbsp;Removed&nbsp;third&nbsp;file</code><br&nbsp;/>
<code>*&nbsp;|&nbsp;&nbsp;&nbsp;b119573&nbsp;Merge&nbsp;branch&nbsp;'wonderful'</code><br&nbsp;/>
<code>|\&nbsp;\</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;|&nbsp;cfbecab&nbsp;(wonderful)&nbsp;Fantastic&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>|&nbsp;|/</code><br&nbsp;/>
<code>*&nbsp;|&nbsp;4ac9201&nbsp;Updated&nbsp;third&nbsp;file</code><br&nbsp;/>
<code>|/</code><br&nbsp;/>
<code>*&nbsp;9710177&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>*&nbsp;55fb69f&nbsp;(v2.0)&nbsp;Added&nbsp;two&nbsp;new&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;4a155e4&nbsp;Removed&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;a022d4d&nbsp;(tag:&nbsp;v1.0b,&nbsp;v1.0a)&nbsp;Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;9938a0c&nbsp;Finished&nbsp;adding&nbsp;initial&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;163f061&nbsp;(v0.9)&nbsp;Made&nbsp;a&nbsp;few&nbsp;changes&nbsp;to&nbsp;first&nbsp;and&nbsp;second&nbsp;files</code><br&nbsp;/>
<code>*&nbsp;cfe23cb&nbsp;My&nbsp;First&nbsp;Ever&nbsp;Commit</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So using the <code class="ncode">git stash drop</code> command, you can see that it is fairly simple to drop a single stash from the list.
<br><h2>Day 2 - "What?! No backup?"</h2>
<h3>Attack of the clones</h3>
We now know about basic branching and merging.
At this stage, there is on important topic we must cover briefly, and this is subject of cloning.
Cloning allows you to make a complete copy of your repository, including all of its history and all of the branches.
Let us take a look at a situation which could make use of cloning.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"So John," started Rob,
"Just how are we backing up the repository at the moment?"<br><br>John thought for a moment before replying.
He knew what Rob was getting at, but he hadn't expected Rob to bring the question up in front of Markus.
In truth he had forgotten all about it.
He turned to Markus.<br><br>"I'll be honest Markus. Currently the repository isn't being backed up, but then we are running in parallel with the old system, so it wouldn't be the end of the world if we lost it."<br><br>Markus nodded and smiled.
It seemed that John had gotten away with it for now and with that, Klaus shot Rob a piercing glance.<br><br>"Team," began Markus,
"we need a definitive way of backing up the new Git repository, and I'd like it done before the end of the day."
He pointed at a document on the table.
"This project document has been approved by Wayne, and in there it states we will have a defined backup strategy. Please don't let me down."<br><br> * * * <br><br>"Rob you really got to be careful about things like that," Klaus said to one of the younger members of the team.
"You really showed John up in there."<br><br>"Yeh," said Rob,
"I realise that now."
He stood with his back against the wall and tapped his fingers against the painted surface.
"I was wondering, do you think John would let me look at the backup system for him as a way of apologising."<br><br>Klaus smiled, it seemed Rob was finally understanding things,
"Go ask him," said Klaus,
"He's so snowed under with the BurnForce release that he'll probably let you implement it too"<br><br>"Right" nodded Rob and off he went.
</div><hr><br>So cloning is an excellent way of taking a copy of our repository, in essence it is a simple way of taking a backup of our repository and then with a little more work, we can keep that clone up to date.
Obviously we could just take the files and copy them, but a better way of doing this is by utilising the <code class="ncode">git clone</code> command.
When cloning a repository, we take then entire structure and replicate it, creating an exact copy of the data in an alternative location.
Well, that's what cloning means isn't it?<br><br>The git clone tool doesn't just copy the data though, it does several other things.
Let us create a clone of our test repository to another local location.
In this case, we are going to clone the repository into a folder called <code class="ncode">coderepo-cl</code>.<br><br><div id="codeblock"><code>john@satsuki:~$&nbsp;git&nbsp;clone&nbsp;coderepo&nbsp;coderepo-cl</code><br&nbsp;/>
<code>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/home/john/coderepo-cl/.git/</code><br&nbsp;/>
<code>john@satsuki:~$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><br><div id="codeblock"><code>john@satsuki:~$&nbsp;cd&nbsp;coderepo-cl</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;ls</code><br&nbsp;/>
<code>another_file&nbsp;&nbsp;newfile1&nbsp;&nbsp;newfile2</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>nothing&nbsp;to&nbsp;commit&nbsp;(working&nbsp;directory&nbsp;clean)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Let us take a few moments to see what has happened here.
It would appear that our data has been copied successfully.
If you were to run a <code class="ncode">git log</code> on this dir, you would see all the previous log messages for all our previous commits.
You can also see that if we run <code class="ncode">git status</code> that we are on the same branch here that we were in our repository when we left it.
In this case, we are in the <strong>master</strong> branch.<br><br>So this could be sufficient enough to serve as a backup of our repository, but we will actually find a better way to do this a little later.<br><h2>Day 3 - "Is this clone for real?"</h2>
<h3>Not entirely as expected</h3>
We now have a clone of the repository and we can start to look at how we can play with branches and see how the two are different.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Klaus, this doesn't make sense though. I cloned my repo, but my branches have vanished," started Rob, rather worriedly.<br><br>"I'm sure they haven't gone anywhere," shouted John.<br><br>Rob's reply was quick and certain, "They have! Run a git branch on your clone and see for yourself"<br><br>"Oh!"<br><br>Rob smiled the smug smile of a man who is pleased he was right.<br><br> * * * <br><br>"Rob?" asked John tentatively, aware of his previous state of anguish.<br><br>His reply indicated a less than stressed demeanour, "Sup, dude?".<br><br>John was pleasantly surprised, "Did you sort out the branch issue?"<br><br>Rob began walking over to John, "Yeh, try running git branch with the r parameter."<br></div><hr><br>You may be thinking that we now have a detached copy of the other branches in our repository.
That's not exactly accurate.
Let us run the command that Rob suggested and see what is happening.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;branch</code><br&nbsp;/>
<code>*&nbsp;master</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;branch&nbsp;-r</code><br&nbsp;/>
<code>&nbsp;&nbsp;origin/HEAD&nbsp;-&gt;&nbsp;origin/master</code><br&nbsp;/>
<code>&nbsp;&nbsp;origin/master</code><br&nbsp;/>
<code>&nbsp;&nbsp;origin/wonderful</code><br&nbsp;/>
<code>&nbsp;&nbsp;origin/zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Whilst we have all the objects in our repository, we do not yet have our branches set up locally.
They are available, but they have not yet been set up locally.
To explain this we need to introduce the concept of remote tracking branches.
We are familiar with local branches.
Local branches allowed us to make commits locally in a safe and separated environment.
Remote tracking branches are links to remote branches which allow us to track the development of that branch and bring it in to a local one if we so desire.<br><br>Let us take a look at what we can do with these remote tracking branches.
Notice in the output above, we have the word <code class="ncode">origin</code> in front of the branch names.
When we clone a repository, Git automatically sets up what is called a <em>remote</em>.
We can view this by using the <code class="ncode">git remote</code> tool.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;remote</code><br&nbsp;/>
<code>origin</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;remote&nbsp;-v</code><br&nbsp;/>
<code>origin	/home/john/coderepo&nbsp;(fetch)</code><br&nbsp;/>
<code>origin	/home/john/coderepo&nbsp;(push)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see from the output above, the <strong>origin</strong> remote definition points to the original folder that our repository came from.
So now we know that when referring to <code class="ncode">origin/master</code>, we are really talking about the <strong>master</strong> branch which is located at the remote location <strong>origin</strong>.<br><br>We are going to spend a little while now learning about remote branches and how they differ to local branches.
Let us spend a few minutes trying some of our normal operations against a remote branch.
The first operation we are going to try is a diff.
We are going to run a diff between our current <strong>master</strong> branch and the <strong>wonderful</strong> branch as it stands in the original repository, so we should be diffing between <code class="ncode">master</code> and <code class="ncode">origin/wonderful</code>.
For brevity, we are also going to limit the changes shown to those which affect <code class="ncode">newfile1</code> only, by appending <code class="ncode"> -- &lt;filename&gt;</code> to the command.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;diff&nbsp;master&nbsp;origin/wonderful&nbsp;--&nbsp;newfile1</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile1&nbsp;b/newfile1</code><br&nbsp;/>
<code>index&nbsp;f32a0e6..ef20984&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile1</code><br&nbsp;/>
<code>+++&nbsp;b/newfile1</code><br&nbsp;/>
<code>@@&nbsp;-1,3&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;A&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>-and&nbsp;some&nbsp;more&nbsp;awesome&nbsp;changes</code><br&nbsp;/>
<code>-Some&nbsp;mega&nbsp;important&nbsp;changes</code><br&nbsp;/>
<code>+and&nbsp;some&nbsp;more&nbsp;changes</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So we can see that our diff command completed successfully.
Note that this command requires no connection to our <strong>origin</strong> repository, as all of the data has been cloned locally, more on this later.<br><br>Let us run another command now and learn a little more about what the remote reference <strong>origin</strong> really means.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;remote&nbsp;show&nbsp;origin</code><br&nbsp;/>
<code>*&nbsp;remote&nbsp;origin</code><br&nbsp;/>
<code>&nbsp;&nbsp;Fetch&nbsp;URL:&nbsp;/home/john/coderepo</code><br&nbsp;/>
<code>&nbsp;&nbsp;Push&nbsp;&nbsp;URL:&nbsp;/home/john/coderepo</code><br&nbsp;/>
<code>&nbsp;&nbsp;HEAD&nbsp;branch:&nbsp;master</code><br&nbsp;/>
<code>&nbsp;&nbsp;Remote&nbsp;branches:</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;Local&nbsp;branch&nbsp;configured&nbsp;for&nbsp;'git&nbsp;pull':</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;merges&nbsp;with&nbsp;remote&nbsp;master</code><br&nbsp;/>
<code>&nbsp;&nbsp;Local&nbsp;ref&nbsp;configured&nbsp;for&nbsp;'git&nbsp;push':</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;pushes&nbsp;to&nbsp;master&nbsp;(up&nbsp;to&nbsp;date)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Though this command introduces some terms that we are not yet familiar with yet, like push, pull and fetch, we can see that the <strong>origin</strong> remote has been set up to <em>track</em> three branches called, <strong>master</strong>, <strong>wonderful</strong> and <strong>zaney</strong>.
So although these branches are not yet usable in the way a local branch would be, it is comforting to know that Git does know about them.
Let us continue playing with the remote branch and run a <code class="ncode">git log</code> command against it.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;log&nbsp;origin/master&nbsp;--&nbsp;newfile1</code><br&nbsp;/>
<code>commit&nbsp;9cb2af2a00fd2253060e6bf8cc6c377b3d55ecea</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Tue&nbsp;Apr&nbsp;19&nbsp;16:43:59&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Important&nbsp;Update</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;d50ffb2fa536d869f2c4e89e8d6a48e0a29c5cc1</code><br&nbsp;/>
<code>Merge:&nbsp;ed2301b&nbsp;7cc32db</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Apr&nbsp;1&nbsp;07:42:04&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Merged&nbsp;in&nbsp;zaney</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Again, this requires no connection to the <strong>origin</strong> repository at all and works as expected.
Let us try something really funky now, let us try checking out a remote branch so that we can view the file system.
We are now going to try checking out the remote branch called <strong>wonderful</strong>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;checkout&nbsp;origin/wonderful</code><br&nbsp;/>
<code>Note:&nbsp;checking&nbsp;out&nbsp;'origin/wonderful'.</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>You&nbsp;are&nbsp;in&nbsp;'detached&nbsp;HEAD'&nbsp;state.&nbsp;You&nbsp;can&nbsp;look&nbsp;around,&nbsp;make&nbsp;experimental</code><br&nbsp;/>
<code>changes&nbsp;and&nbsp;commit&nbsp;them,&nbsp;and&nbsp;you&nbsp;can&nbsp;discard&nbsp;any&nbsp;commits&nbsp;you&nbsp;make&nbsp;in&nbsp;this&nbsp;</code><br&nbsp;/>
<code>state&nbsp;without&nbsp;impacting&nbsp;any&nbsp;branches&nbsp;by&nbsp;performing&nbsp;another&nbsp;checkout.</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>If&nbsp;you&nbsp;want&nbsp;to&nbsp;create&nbsp;a&nbsp;new&nbsp;branch&nbsp;to&nbsp;retain&nbsp;commits&nbsp;you&nbsp;create,&nbsp;you&nbsp;may</code><br&nbsp;/>
<code>do&nbsp;so&nbsp;(now&nbsp;or&nbsp;later)&nbsp;by&nbsp;using&nbsp;-b&nbsp;with&nbsp;the&nbsp;checkout&nbsp;command&nbsp;again.&nbsp;Example:</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;new_branch_name</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>HEAD&nbsp;is&nbsp;now&nbsp;at&nbsp;cfbecab...&nbsp;Fantastic&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Interesting.
This is not what we are used to seeing.
When we have checked out branches before, we have always been presented with a <code class="ncode">Switched to branch 'xxxxxx'</code> message.
Now we are seeing a funny message about having a detached HEAD.
This is because we are not actually on a branch.
We can make changes as we are advised, we can even make commits, but these will not actually become integrated into any branches.
In essence these commits would be left dangling and after time, because no branch points to them, they would get deleted by garbage collection routines.<br><br>Running the <code class="ncode">git branch</code> command below confirms our suspicions.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;branch&nbsp;-v</code><br&nbsp;/>
<code>*&nbsp;(no&nbsp;branch)&nbsp;cfbecab&nbsp;Fantastic&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;37950f8&nbsp;Continued&nbsp;Development</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So we really need to figure out how to make these branches exist locally so that we can commit to them and retain those commits.
To do this we use the <code class="ncode">git branch</code> tool again, but we use it in a slightly different manner.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;wonderful&nbsp;origin/wonderful</code><br&nbsp;/>
<code>Branch&nbsp;wonderful&nbsp;set&nbsp;up&nbsp;to&nbsp;track&nbsp;remote&nbsp;branch&nbsp;wonderful&nbsp;from&nbsp;origin.</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;'wonderful'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We are now on a local instance of the <strong>wonderful</strong> branch.
Let us take a minute to understand what that means.
As Git is a distributed environment, our local <strong>wonderful</strong> branch, is not going to be synchronised with the remote end automatically.
It would require effort on our part.
What this does mean though, is that we are able to begin committing to this branch and experimenting with it.<br><h2>Day 4 - "Help I'm no longer up to date?"</h2>
<h3>Pulling changes, not teeth</h3>
With a remote tracking branch, we can pull in the changes from the remote repository.
In our case, the remote repository is in the <code class="ncode">coderepo</code> directory that we created at the start of the book.
In the <code class="ncode">coderepo-cl</code> directory we have a separate, self-contained copy of the repository.
At the moment, because no changes have occurred to either, they contain exactly the same data.<br><br>By running the <code class="ncode">git remote</code> tool again, we can see which branches are set up locally to track their remote counterparts in <strong>origin</strong>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;remote&nbsp;show&nbsp;origin</code><br&nbsp;/>
<code>*&nbsp;remote&nbsp;origin</code><br&nbsp;/>
<code>&nbsp;&nbsp;Fetch&nbsp;URL:&nbsp;/home/john/coderepo</code><br&nbsp;/>
<code>&nbsp;&nbsp;Push&nbsp;&nbsp;URL:&nbsp;/home/john/coderepo</code><br&nbsp;/>
<code>&nbsp;&nbsp;HEAD&nbsp;branch:&nbsp;master</code><br&nbsp;/>
<code>&nbsp;&nbsp;Remote&nbsp;branches:</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;Local&nbsp;branches&nbsp;configured&nbsp;for&nbsp;'git&nbsp;pull':</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;merges&nbsp;with&nbsp;remote&nbsp;master</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;merges&nbsp;with&nbsp;remote&nbsp;wonderful</code><br&nbsp;/>
<code>&nbsp;&nbsp;Local&nbsp;refs&nbsp;configured&nbsp;for&nbsp;'git&nbsp;push':</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;pushes&nbsp;to&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;(up&nbsp;to&nbsp;date)</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;pushes&nbsp;to&nbsp;wonderful&nbsp;(up&nbsp;to&nbsp;date)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>What we are going to do now is make some changes to our original repository and see how we can view those changes and indeed pull them into our current local working repository, or clone.
Note that in the following code examples we have switched back to working on our original repository, in the <code class="ncode">coderepo</code> folder.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;cd&nbsp;../coderepo</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch</code><br&nbsp;/>
<code>*&nbsp;master</code><br&nbsp;/>
<code>&nbsp;&nbsp;wonderful</code><br&nbsp;/>
<code>&nbsp;&nbsp;zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;wonderful</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'wonderful'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;merge&nbsp;master</code><br&nbsp;/>
<code>Updating&nbsp;cfbecab..37950f8</code><br&nbsp;/>
<code>Fast-forward</code><br&nbsp;/>
<code>&nbsp;another_file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;my_third_committed_file&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-</code><br&nbsp;/>
<code>&nbsp;newfile1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;++-</code><br&nbsp;/>
<code>&nbsp;newfile2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;+-</code><br&nbsp;/>
<code>&nbsp;4&nbsp;files&nbsp;changed,&nbsp;4&nbsp;insertions(+),&nbsp;3&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"These&nbsp;changes&nbsp;are&nbsp;in&nbsp;the&nbsp;origin"&nbsp;&gt;&gt;&nbsp;newfile3</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;newfile3</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Added&nbsp;a&nbsp;new&nbsp;file'</code><br&nbsp;/>
<code>[wonderful&nbsp;1c3206a]&nbsp;Added&nbsp;a&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;newfile3</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, we have switched back to working on our old <strong>origin</strong> and have bought <strong>wonderful</strong> to be in line with master and have added a new file and committed the changes.
Now let us go back to our clone and see if we can see those changes.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;cd&nbsp;../coderepo-cl/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;diff&nbsp;wonderful&nbsp;origin/</code><br&nbsp;/>
<code>origin/HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin/master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origin/wonderful&nbsp;&nbsp;&nbsp;origin/zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;diff&nbsp;wonderful&nbsp;origin/wonderful</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>That seems a little odd at first glance.
We have tried to view a diff between our local <strong>wonderful</strong> branch and the remote <strong>origin/wonderful</strong> branch.
Interestingly, Git is telling us that there is no difference.
Hang on though, we just made some changes above.<br><br>Remember before we discussed the fact that our clone was disconnected from the <strong>origin</strong> copy? What this means is that unless we ask Git, it won't update details about what is present in the remote copy.
Once this is up to date, we can pull the changes into our local copy of the remote branch? Interestingly there are actually two ways to do this.<br><br>The first method is by running a <code class="ncode">git pull</code> command.
If you remember the output from the <code class="ncode">git remote show origin</code>, you may remember that it showed that there was a local branch configured for <code class="ncode">'git pull'</code> and the details it gave for the <strong>wonderful</strong> branch were as follows; <code class="ncode">wonderful merges with remote wonderful</code>.
What this means, is that when we run a <code class="ncode">git pull</code> from inside the <strong>wonderful</strong> branch, Git will automatically contact the remote repository, update the list of changes and merge them into the local branch if possible.<br><br>We mentioned that there were two methods to perform the procedure.
Whilst the first one is to use <code class="ncode">git pull</code>, the second one actually achieves an almost identical result, but by running two commands instead of one.
In point of fact, these two commands are executed by the <code class="ncode">git pull</code> command.
Running them as two separate commands allows us to understand a little more about what is happening.
Let us run the command and then explain what we have done.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;fetch&nbsp;origin</code><br&nbsp;/>
<code>remote:&nbsp;Counting&nbsp;objects:&nbsp;4,&nbsp;done.</code><br&nbsp;/>
<code>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100remote:&nbsp;Total&nbsp;3&nbsp;(delta&nbsp;1),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)</code><br&nbsp;/>
<code>Unpacking&nbsp;objects:&nbsp;100From&nbsp;/home/john/coderepo</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;cfbecab..1c3206a&nbsp;&nbsp;wonderful&nbsp;&nbsp;-&gt;&nbsp;origin/wonderful</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;diff&nbsp;wonderful&nbsp;origin/wonderful</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/another_file&nbsp;b/another_file</code><br&nbsp;/>
<code>index&nbsp;dba885d..b3a5cc5&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/another_file</code><br&nbsp;/>
<code>+++&nbsp;b/another_file</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;New&nbsp;stuff</code><br&nbsp;/>
<code>+Number&nbsp;strings&nbsp;rule&nbsp;1234</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code>...</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;merge&nbsp;origin/wonderful</code><br&nbsp;/>
<code>Updating&nbsp;cfbecab..1c3206a</code><br&nbsp;/>
<code>Fast-forward</code><br&nbsp;/>
<code>&nbsp;another_file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;my_third_committed_file&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-</code><br&nbsp;/>
<code>&nbsp;newfile1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;++-</code><br&nbsp;/>
<code>&nbsp;newfile2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;+-</code><br&nbsp;/>
<code>&nbsp;newfile3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;5&nbsp;files&nbsp;changed,&nbsp;5&nbsp;insertions(+),&nbsp;3&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;my_third_committed_file</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;newfile3</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, the two commands that we used were <code class="ncode">git fetch</code> and the more familiar <code class="ncode">git merge</code>.
The <code class="ncode">git fetch</code> command literally visits the remote repository, in our case we asked for <strong>origin</strong>, and finds which objects are new.
These are then copied to the local clone, and the HEADs of the various remote branches are updated.
We now rerun our <code class="ncode">git diff</code>, only this time, we see a great many more changes than before.
Finally we initiate a <code class="ncode">git merge</code> to pull the changes from the now up to date remote branch to our local one.<br><br>We could have used the <code class="ncode">git pull</code> command here, and if we had supplied no parameters to it, it would have achieved the exact same outcome.
The only difference would have been running one command instead of two.
Please note, that there are occasions when you would require one over the other, but as an introduction, this should be sufficient.<br><h2>Day 5 - "I'm putting my foot down"</h2>
<h3>Pushing back!</h3>
We now know a lot about remote locations right? We are ready to start collaborating with someone.
Let us first see how Tamagoyaki are getting on with things.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"But I know I have the remote right Simon, it's giving some weird error about refusing to update it."
Rob was getting more than a little cross now.<br><br>"Maybe you got the command wrong?" asked Simon.<br><br>Rob slammed his hands down on the keyboard,
"Well then you come over here and type it, but I don't understand how hard it is to write git push."
He shook his head, "I even checked using the git remote tool and the push is apparently all set up."<br><br>"Are you trying to push to a non-bare repository?" Chirped Klaus.
He had been listening to the discussion escalate from mild annoyance to key shattering intrusion.
"You can't push to a non-bare repository, else everything gets out of sync."<br><br>"What do you mean bare?" asked Rob.<br><br>Klaus smiled and his head appeared over the cubicle.
"Come over here genius and I'll show you," he said with the slightest amount of gloat at being one of the only people to know something about Git that Rob didn't.
</div><hr><br>Bare? Non-bare? At first glance, this may seem confusing.
It isn't exactly an intuitive word to describe a repository but what Klaus mentioned was absolutely true.
In Git, if you want to push changes back to a repository, instead of pulling them, the repository that you push to should be what is called a <em>bare</em> repository.
What this means is that the repository has no working copy.<br><hr><div id="calloutblock"><h3>Note - Pushing to a non-bare repository</h3>
As mentioned, pushing to a non-bare repository is not a good idea.
When you push to a repository, you update the objects in the objects database.
This will affect commits, blobs and trees.
We should make a distinction here.
We are really only worried about pushing to a branch which is currently checked out.
Pushing to a non-bare repository will mean that the index will get changed, as it should reflect what the branch looks like at HEAD.<br><br>Now this causes a problem when we are trying to see what has been modified in the working directory when compared to the HEAD.
As our working copy will contain older versions of the files than are in the index, it will appear as if many more changes have occurred and we risk undoing those changes.
For these reasons, it is much simpler just to push only to bare repositories.
</div><hr><br>At first glance this may seem like a rather odd thing to want.
Why would we want a repository that doesn't have a working tree? The simple answer is that a <em>bare</em> repository allows us to be able to push changes into it.
Let us recreate the error message that Rob was talking about.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;echo&nbsp;"This&nbsp;is&nbsp;another&nbsp;update&nbsp;to&nbsp;newfile3"&nbsp;&gt;&gt;&nbsp;newfile3</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Added&nbsp;more&nbsp;to&nbsp;newfile3'</code><br&nbsp;/>
<code>[wonderful&nbsp;dbf1e9a]&nbsp;Added&nbsp;more&nbsp;to&nbsp;newfile3</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We have made a modification to the <strong>wonderful</strong> branch.
So let us now try to push that back to the <strong>origin</strong> remote repository with the <code class="ncode">git push</code> command.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;push</code><br&nbsp;/>
<code>Counting&nbsp;objects:&nbsp;5,&nbsp;done.</code><br&nbsp;/>
<code>Compressing&nbsp;objects:&nbsp;100Writing&nbsp;objects:&nbsp;100Total&nbsp;3&nbsp;(delta&nbsp;1),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)</code><br&nbsp;/>
<code>Unpacking&nbsp;objects:&nbsp;100remote:&nbsp;error:&nbsp;refusing&nbsp;to&nbsp;update&nbsp;checked&nbsp;out&nbsp;branch:&nbsp;refs/heads/wonderful</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;By&nbsp;default,&nbsp;updating&nbsp;the&nbsp;current&nbsp;branch&nbsp;in&nbsp;a&nbsp;non-bare&nbsp;repository</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;is&nbsp;denied,&nbsp;because&nbsp;it&nbsp;will&nbsp;make&nbsp;the&nbsp;index&nbsp;and&nbsp;work&nbsp;tree&nbsp;inconsistent</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;with&nbsp;what&nbsp;you&nbsp;pushed,&nbsp;and&nbsp;will&nbsp;require&nbsp;'git&nbsp;reset&nbsp;--hard'&nbsp;to&nbsp;match</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;the&nbsp;work&nbsp;tree&nbsp;to&nbsp;HEAD.</code><br&nbsp;/>
<code>remote:&nbsp;error:</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;You&nbsp;can&nbsp;set&nbsp;'receive.denyCurrentBranch'&nbsp;configuration&nbsp;variable&nbsp;to</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;'ignore'&nbsp;or&nbsp;'warn'&nbsp;in&nbsp;the&nbsp;remote&nbsp;repository&nbsp;to&nbsp;allow&nbsp;pushing&nbsp;into&nbsp;</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;its&nbsp;current&nbsp;branch;&nbsp;however,&nbsp;this&nbsp;is&nbsp;not&nbsp;recommended&nbsp;unless&nbsp;you&nbsp;</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;arranged&nbsp;to&nbsp;update&nbsp;its&nbsp;work&nbsp;tree&nbsp;to&nbsp;match&nbsp;what&nbsp;you&nbsp;pushed&nbsp;in&nbsp;some</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;&nbsp;other&nbsp;way.</code><br&nbsp;/>
<code>remote:&nbsp;error:</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;To&nbsp;squelch&nbsp;this&nbsp;message&nbsp;and&nbsp;still&nbsp;keep&nbsp;the&nbsp;default&nbsp;behaviour,&nbsp;set</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;'receive.denyCurrentBranch'&nbsp;configuration</code><br&nbsp;/>
<code>remote:&nbsp;error:&nbsp;variable&nbsp;to&nbsp;'refuse'.</code><br&nbsp;/>
<code>To&nbsp;/home/john/coderepo</code><br&nbsp;/>
<code>&nbsp;!&nbsp;[remote&nbsp;rejected]&nbsp;wonderful&nbsp;-&gt;&nbsp;wonderful&nbsp;(branch&nbsp;is&nbsp;currently&nbsp;checked&nbsp;out)</code><br&nbsp;/>
<code>error:&nbsp;failed&nbsp;to&nbsp;push&nbsp;some&nbsp;refs&nbsp;to&nbsp;'/home/john/coderepo'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Bingo! There is the error we were looking for.
In order to get round this, we are going to create another clone of the repository in <code class="ncode">coderepo</code>.
This time however, we are going to pass an option to it when we create it.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;cd&nbsp;..</code><br&nbsp;/>
<code>john@satsuki:~$&nbsp;git&nbsp;clone&nbsp;coderepo&nbsp;coderepo-bk&nbsp;--bare</code><br&nbsp;/>
<code>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/home/john/coderepo-bk/</code><br&nbsp;/>
<code>john@satsuki:~$&nbsp;cd&nbsp;coderepo-bk/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-bk$&nbsp;ls</code><br&nbsp;/>
<code>branches&nbsp;&nbsp;config&nbsp;&nbsp;description&nbsp;&nbsp;HEAD&nbsp;&nbsp;hooks&nbsp;&nbsp;info&nbsp;&nbsp;objects</code><br&nbsp;/>
<code>packed-refs&nbsp;&nbsp;refs</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-bk$&nbsp;cd&nbsp;..</code><br&nbsp;/>
<code>john@satsuki:~$&nbsp;cd&nbsp;coderepo-cl/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, creating the clone with the <code class="ncode">--bare</code> option has had a definite effect on the structure of the clone itself.
In fact, the contents of the <code class="ncode">coderepo-bk</code> folder look remarkably similar to the <code class="ncode">.git</code> folder found in our normal working tree.
They are in fact, one and the same.
We have removed the need for a separate <code class="ncode">.git</code> folder because we do not require a working tree.
Therefore, the contents of the <code class="ncode">.git</code> folder and placed in the root <code class="ncode">coderepo-bk</code> folder.<br><br>We are getting closer to making our push.
We have created a <em>bare</em> repository, which we should now be able to push to.
The problem is, we have not yet defined our new repository as a remote location in the <code class="ncode">coderepo-cl</code> repository.
This is something we will do now and to do this, we will use our <code class="ncode">git remote</code> tool once more, this time employing the <code class="ncode">add</code> parameter.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;remote&nbsp;add&nbsp;backup</code><br&nbsp;/>
<code>&nbsp;/home/john/coderepo-bk</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;remote&nbsp;show&nbsp;backup</code><br&nbsp;/>
<code>*&nbsp;remote&nbsp;backup</code><br&nbsp;/>
<code>&nbsp;&nbsp;Fetch&nbsp;URL:&nbsp;/home/john/coderepo-bk</code><br&nbsp;/>
<code>&nbsp;&nbsp;Push&nbsp;&nbsp;URL:&nbsp;/home/john/coderepo-bk</code><br&nbsp;/>
<code>&nbsp;&nbsp;HEAD&nbsp;branch:&nbsp;wonderful</code><br&nbsp;/>
<code>&nbsp;&nbsp;Remote&nbsp;branches:</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;(next&nbsp;fetch&nbsp;will&nbsp;store&nbsp;in&nbsp;remotes/backup)</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;new&nbsp;(next&nbsp;fetch&nbsp;will&nbsp;store&nbsp;in&nbsp;remotes/backup)</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;(next&nbsp;fetch&nbsp;will&nbsp;store&nbsp;in&nbsp;remotes/backup)</code><br&nbsp;/>
<code>&nbsp;&nbsp;Local&nbsp;refs&nbsp;configured&nbsp;for&nbsp;'git&nbsp;push':</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;pushes&nbsp;to&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;(up&nbsp;to&nbsp;date)</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;pushes&nbsp;to&nbsp;wonderful&nbsp;(fast-forwardable)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We have created a remote called backup.
As you can see, some interrogation of the remote repository has taken place.
It is already aware of the branches present in our remote location.
Let us do a <code class="ncode">git fetch</code> to update the local references.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;fetch&nbsp;backup</code><br&nbsp;/>
<code>From&nbsp;/home/john/coderepo-bk</code><br&nbsp;/>
<code>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;backup/master</code><br&nbsp;/>
<code>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;&nbsp;-&gt;&nbsp;backup/wonderful</code><br&nbsp;/>
<code>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;backup/zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;remote&nbsp;show&nbsp;backup</code><br&nbsp;/>
<code>*&nbsp;remote&nbsp;backup</code><br&nbsp;/>
<code>&nbsp;&nbsp;Fetch&nbsp;URL:&nbsp;/home/john/coderepo-bk</code><br&nbsp;/>
<code>&nbsp;&nbsp;Push&nbsp;&nbsp;URL:&nbsp;/home/john/coderepo-bk</code><br&nbsp;/>
<code>&nbsp;&nbsp;HEAD&nbsp;branch:&nbsp;wonderful</code><br&nbsp;/>
<code>&nbsp;&nbsp;Remote&nbsp;branches:</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;Local&nbsp;refs&nbsp;configured&nbsp;for&nbsp;'git&nbsp;push':</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;pushes&nbsp;to&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;(up&nbsp;to&nbsp;date)</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;pushes&nbsp;to&nbsp;wonderful&nbsp;(fast-forwardable)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we can see that all of the remote references for our <strong>backup</strong> remote have been updated.
If we run a diff against our local <strong>wonderful</strong> branch and the remote branch <strong>backup/wonderful</strong>, we can see the differences.<br><hr><div id="calloutblock"><h3>Note - Pushing your tags</h3>
By default tags are not pushed when using the <code class="ncode">git push</code> command.
If we want our tags to be push to the remote repository as well, we need to append the <code class="ncode">--tags</code> parameter to the <code class="ncode">git push</code> command.<br><br>In contrast, using <code class="ncode">git pull</code> will automatically pull down any tags which refer to any objects that have been pulled.
This behaviour can be overridden by using the <code class="ncode">--no-tags</code> parameter with <code class="ncode">git pull</code>.
</div><hr><br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;diff&nbsp;wonderful&nbsp;backup/wonderful</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile3&nbsp;b/newfile3</code><br&nbsp;/>
<code>index&nbsp;7268b97..638113c&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile3</code><br&nbsp;/>
<code>+++&nbsp;b/newfile3</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;These&nbsp;changes&nbsp;are&nbsp;in&nbsp;the&nbsp;origin</code><br&nbsp;/>
<code>-This&nbsp;is&nbsp;another&nbsp;update&nbsp;to&nbsp;newfile3</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;branch&nbsp;-v</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>There we go! Those are the changes we just committed to the local repository.
The last thing we need to do is to initiate a <code class="ncode">git push</code>.
We are going to have to define which remote we wish to push to now for two reasons.
The first is that now we have two remotes, and so Git would not know if we meant <strong>origin</strong> or <strong>backup</strong>.
The second reason is that by default, the <strong>wonderful</strong> branch is set up to push to the <strong>origin</strong> remote.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;push&nbsp;backup</code><br&nbsp;/>
<code>Counting&nbsp;objects:&nbsp;5,&nbsp;done.</code><br&nbsp;/>
<code>Compressing&nbsp;objects:&nbsp;100Writing&nbsp;objects:&nbsp;100Total&nbsp;3&nbsp;(delta&nbsp;1),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)</code><br&nbsp;/>
<code>Unpacking&nbsp;objects:&nbsp;100To&nbsp;/home/john/coderepo-bk</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;1c3206a..dbf1e9a&nbsp;&nbsp;wonderful&nbsp;-&gt;&nbsp;wonderful</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>There we go, we have now managed to push our changes to a remote location.
In this case, we have pushed an update from the <strong>wonderful</strong> branch to the <strong>backup/wonderful branch</strong>.
If we wanted to, we could have pushed our repository to a new branch name, or indeed any of the existing branch names.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;push&nbsp;backup&nbsp;wonderful:newbranch</code><br&nbsp;/>
<code>Total&nbsp;0&nbsp;(delta&nbsp;0),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)</code><br&nbsp;/>
<code>To&nbsp;/home/john/coderepo-bk</code><br&nbsp;/>
<code>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;-&gt;&nbsp;newbranch</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;remote&nbsp;show&nbsp;backup</code><br&nbsp;/>
<code>*&nbsp;remote&nbsp;backup</code><br&nbsp;/>
<code>&nbsp;&nbsp;Fetch&nbsp;URL:&nbsp;/home/john/coderepo-bk</code><br&nbsp;/>
<code>&nbsp;&nbsp;Push&nbsp;&nbsp;URL:&nbsp;/home/john/coderepo-bk</code><br&nbsp;/>
<code>&nbsp;&nbsp;HEAD&nbsp;branch&nbsp;(remote&nbsp;HEAD&nbsp;is&nbsp;ambiguous,&nbsp;may&nbsp;be&nbsp;one&nbsp;of&nbsp;the&nbsp;following):</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;newbranch</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful</code><br&nbsp;/>
<code>&nbsp;&nbsp;Remote&nbsp;branches:</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;newbranch&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;Local&nbsp;refs&nbsp;configured&nbsp;for&nbsp;'git&nbsp;push':</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;pushes&nbsp;to&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;(up&nbsp;to&nbsp;date)</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;pushes&nbsp;to&nbsp;wonderful&nbsp;(up&nbsp;to&nbsp;date)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>By specifying the local and remote branch using the <code class="ncode">local:remote</code> syntax, we have told Git to push our local <strong>wonderful</strong> branch to the remote branch called <strong>newbranch</strong>.
As the <strong>newbranch</strong> did not exist in the remote <strong>backup</strong> repository, it was created, as can be seen above.<br><hr><div id="calloutblock"><h3>Note - Killing a remote branch</h3>
Now that we have made branches on the remote end, it is a good idea to know how to delete them also.
After all, if all you ever did was push new branches, pretty soon you may end up with a lot of rubbish in your repository.
To delete a remote branch, all that you need to do is to use the following syntax.<br><br><div id="codeblock"><code>git&nbsp;push&nbsp;&lt;remote&gt;&nbsp;:&lt;branchname&gt;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice that we are using the same syntax as before, but not specifying a local branch name, just the remote.
Git interprets this as a call to delete the remote branch.<br><br>If you have a clone of a remote repository and a remote branch is removed, you may see a message like the following if you run <code class="ncode">git remote show &lt;remote&gt;</code>;<br><br><div id="codeblock"><code>&nbsp;refs/remotes/&lt;remote&gt;/&lt;branchname&gt;&nbsp;stale&nbsp;(use&nbsp;'git&nbsp;remote&nbsp;prune'&nbsp;to&nbsp;remove)</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So we can run <code class="ncode">git remote prune</code> to remove local references to remote branches that no longer exist.
If you have created a tracking branch of this remote branch, this will remain unaffected.
</div><hr><br>So this ends the Week.
We have learnt a lot more about how to play with branches and remotes.
In the <em>After Hours</em> section, we will take a deeper look at remote branches and how they are configured and represented in Git.<br><br><h2>Summary - John's Notes</h2>
<h3>Commands</h3>
<div style="padding-left:10px;"><ul><li><code class="ncode">git stash</code> - Short for <code class="ncode">git stash save</code>, creates a stash of local modifications</li>
<li><code class="ncode">git stash apply &lt;stash_name&gt;</code> - Applies a stash back onto a branch</li>
<li><code class="ncode">git stash drop &lt;stash_name&gt;</code> - Remove a stash from the stash list</li>
<li><code class="ncode">git stash list</code> - Show a list of current stashes</li>
<li><code class="ncode">git stash show &lt;stash_name&gt;</code> - Show information about a specific stash</li>
<li><code class="ncode">git stash show &lt;stash_name&gt; -p</code> - Show the contents of a stash</li>
<li><code class="ncode">git clone &lt;local&gt; &lt;remote&gt;</code> - Clone a Git repository, from the local to the remote location.</li>
<li><code class="ncode">git branch -r</code> - Show all remote branch references</li>
<li><code class="ncode">git remote</code> - Show a list of remote repositories</li>
<li><code class="ncode">git remote -v</code> - Show a more detailed list of remote repositories</li>
<li><code class="ncode">git diff &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt; -- &lt;file&gt;</code> - Show the differences between the two branches, one local, one remote, for a particular file.</li>
<li><code class="ncode">git remote show &lt;remote&gt;</code> - Show detailed information about tracked branches for the specified remote repository</li>
<li><code class="ncode">git log &lt;remote&gt;/&lt;branch&gt; -- &lt;file&gt;</code> - Show the log of the remote branch specified for a particular file</li>
<li><code class="ncode">git checkout &lt;remote&gt;/&lt;branch&gt;</code> - Checkout a remote branch, leaving the local working tree in a detached HEAD state</li>
<li><code class="ncode">git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code> - Create and switch to a new branch, which is set up to track a remote branch specified</li>
<li><code class="ncode">git fetch &lt;remote&gt;</code> - Fetch updates to the remote branch specified including all objects and branches</li>
<li><code class="ncode">git pull</code> - When configured, fetches and merges a remote branch into the currently checked out branch.</li>
<li><code class="ncode">git clone &lt;local&gt; &lt;remote&gt; --bare</code> - Creates a bare repository, suitable for pushing into</li>
<li><code class="ncode">git push</code> - When configured, pushes all changes up to the configured remote branch</li>
<li><code class="ncode">git push &lt;remote&gt; &lt;local_brch&gt;:&lt;remote_brch&gt;</code> - Pushes a local branch to a remote location with a different name</li>
</ul></div><br><h3>Terminology</h3>
<div style="padding-left:10px;"><ul><li><strong>Stash</strong> - A temporary storage of local modifications that can be brought back onto the branch at a later date</li>
<li><strong>Remote</strong> - A copy of a repository, or part of a repository in a remote location</li>
<li><strong>Pull</strong> - Merging changes from a remote branch into a current local one</li>
<li><strong>Push</strong> - Pushing changes from a local branch into a remote one</li>
<li><strong>Fetch</strong> - Pull into the local repository, all new objects and update all branch HEADs to point to the same commits as the remote location</li>
</ul></div>

<h1>After Hours Week 6</h1>
<h2>"Tug of war"</h2>
<h3>Taking the push with the pull</h3>
We have spoken in fairly great length about how remote repositories work.
We have seen how the <code class="ncode">git remote</code> tool is used to create the various references to remote repositories, but we have no real understanding about what this means in terms of Git's internals.
Just in the same way a branch is a single file that contains a pointer to a reference, a remote repository has to be handled within Git somehow.<br><br>As it happens, Git again uses a reasonably simplistic design when creating remote references.
To take a look at this in detail, we need to once again delve into the <code class="ncode">.git</code> directory.
Seeing as our original repository does not contain any remotes for now, we are going to use our <code class="ncode">coderepo-cl</code> folder as an example.
Hopefully, if you have been following the text, you have not deleted this directory yet.
If you have, do not worry, just follow the operations we completed in Week 6, or read on and use the text in the book.<br><br>If you remember, we created two clones of our original repository.
Once was a simple clone called <code class="ncode">coderepo-cl</code> and the other was a bare repository called <code class="ncode">coderepo-bk</code>.
The <code class="ncode">coderepo-cl</code> and the <code class="ncode">coderepo-bk</code> repositories were both cloned from <code class="ncode">coderepo</code>, but it was <code class="ncode">coderepo-cl</code> that was configured to pull from one and push to the other.
Running a simple <code class="ncode">git remote -v</code> command, confirms this configuration.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;remote&nbsp;-v</code><br&nbsp;/>
<code>backup	/home/john/coderepo-bk&nbsp;(fetch)</code><br&nbsp;/>
<code>backup	/home/john/coderepo-bk&nbsp;(push)</code><br&nbsp;/>
<code>origin	/home/john/coderepo&nbsp;(fetch)</code><br&nbsp;/>
<code>origin	/home/john/coderepo&nbsp;(push)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We can get even more information by running the <code class="ncode">git remote show</code> tool with the remote name as a parameter.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;git&nbsp;remote&nbsp;show&nbsp;origin</code><br&nbsp;/>
<code>*&nbsp;remote&nbsp;origin</code><br&nbsp;/>
<code>&nbsp;&nbsp;Fetch&nbsp;URL:&nbsp;/home/john/coderepo</code><br&nbsp;/>
<code>&nbsp;&nbsp;Push&nbsp;&nbsp;URL:&nbsp;/home/john/coderepo</code><br&nbsp;/>
<code>&nbsp;&nbsp;HEAD&nbsp;branch:&nbsp;master</code><br&nbsp;/>
<code>&nbsp;&nbsp;Remote&nbsp;branches:</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracked</code><br&nbsp;/>
<code>&nbsp;&nbsp;Local&nbsp;branches&nbsp;configured&nbsp;for&nbsp;'git&nbsp;pull':</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;merges&nbsp;with&nbsp;remote&nbsp;master</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;merges&nbsp;with&nbsp;remote&nbsp;wonderful</code><br&nbsp;/>
<code>&nbsp;&nbsp;Local&nbsp;refs&nbsp;configured&nbsp;for&nbsp;'git&nbsp;push':</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;pushes&nbsp;to&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;(up&nbsp;to&nbsp;date)</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;wonderful&nbsp;pushes&nbsp;to&nbsp;wonderful&nbsp;(up&nbsp;to&nbsp;date)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>How though, is this data set up and configured from within Git itself?
Looking at the <code class="ncode">.git/config</code> file, we can see a glimpse of this.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo-cl$&nbsp;cat&nbsp;.git/config</code><br&nbsp;/>
<code>[core]</code><br&nbsp;/>
<code>	repositoryformatversion&nbsp;=&nbsp;0</code><br&nbsp;/>
<code>	filemode&nbsp;=&nbsp;true</code><br&nbsp;/>
<code>	bare&nbsp;=&nbsp;false</code><br&nbsp;/>
<code>	logallrefupdates&nbsp;=&nbsp;true</code><br&nbsp;/>
<code>[remote&nbsp;"origin"]</code><br&nbsp;/>
<code>	fetch&nbsp;=&nbsp;+refs/heads/*:refs/remotes/origin/*</code><br&nbsp;/>
<code>	url&nbsp;=&nbsp;/home/john/coderepo</code><br&nbsp;/>
<code>[branch&nbsp;"master"]</code><br&nbsp;/>
<code>	remote&nbsp;=&nbsp;origin</code><br&nbsp;/>
<code>	merge&nbsp;=&nbsp;refs/heads/master</code><br&nbsp;/>
<code>[branch&nbsp;"wonderful"]</code><br&nbsp;/>
<code>	remote&nbsp;=&nbsp;origin</code><br&nbsp;/>
<code>	merge&nbsp;=&nbsp;refs/heads/wonderful</code><br&nbsp;/>
<code>[remote&nbsp;"backup"]</code><br&nbsp;/>
<code>	url&nbsp;=&nbsp;/home/john/coderepo-bk</code><br&nbsp;/>
<code>	fetch&nbsp;=&nbsp;+refs/heads/*:refs/remotes/backup/*</code><br&nbsp;/>
<code>john@satsuki:~/coderepo-cl$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see there are two relevant sections, these are the <code class="ncode">remote</code> and <code class="ncode">branch</code> stanzas.
The <code class="ncode">remote</code> stanzas are there to define certain elements of the remote repository, 
whilst the <code class="ncode">branch</code> stanzas describe elements and settings for the branches that we are tracking.
Let us look at the relevant elements that we have set out in <code class="ncode">config</code> file for each type of stanza.<br><br>We will start by looking at the <code class="ncode">remote</code> stanza. We have two settings here in our configuration.
The first is <code class="ncode">url</code> and the second is <code class="ncode">fetch</code>.
The <code class="ncode">url</code> setting tells Git the location of the remote repository defined by the name outlined within the quotation marks.
In our example, the remote we first encounter is called <strong>origin</strong> and has a url of <code class="ncode">/home/john/coderepo</code>.<br><br>You will notice that there is also a second setting called <code class="ncode">fetch</code>.
This setting tells Git which branches, or HEADs we are interested in. In the default configuration, we ask Git to fetch all branch HEADs.
This also has an effect on which objects are downloaded.
Git will look at all of the branch HEADs and work backwards to find out which commit objects need to be downloaded.<br><br>In the <code class="ncode">refs/</code> folder there are two other folders by default called <code class="ncode">tags</code> and <code class="ncode">remotes</code>.
With the default configuration as above, these references will not be fetched,
and commits that are only pointed to by these references will not be downloaded either.<br><br>Looking at the <code class="ncode">branch</code> settings, we can see that there are a few more settings here that describe how Git responds to certain commands when inside a certain branch.
In both the cases above, Git will automatically use remote of <strong>origin</strong> as the remote to use when performing operations.
This means that when we run a <code class="ncode">git pull</code>, we do not have to specify a remote to pull from.
Obviously if we wanted to, we could change this and have <strong>wonderful</strong>, for example, update from a different remote repository.<br><br>The last setting in this file that we will concern ourselves with is the <code class="ncode">merge</code> setting.  
When we are in the named branch, this setting defines the upstream version of the named branch and is used for merging and can affect pulling and rebasing too.<br><br>We can set these settings and any of the others in the <code class="ncode">config</code> file manually,
using the <code class="ncode">git config</code> tool, which we used in a previous chapter.<br><h2>"Referring to objects"</h2>
<h3>The Git spelling bee</h3>
It is now most definitely time we spoke about other ways to represent commit hashes.  
More details can be found about this in the Git manual, but it is definitely worth spending a few minutes looking at the ways in which we can specify objects in the repository.
As you have seen in previous chapters, we have used branch names, commits hashes and tags to specify commits, but it is also possibly to use a variety of other methods to do so.
We are going to use the <code class="ncode">git rev-parse</code> command again to return us an object hash from our description of an object.
These descriptions are ways to <em>spell</em> objects.<br><div style="padding-left:10px;"><ul><li><code class="ncode">&lt;SHA1&gt;</code> - This is most common way to specify an object.
The <code class="ncode">&lt;SHA1&gt;</code> is the 40 character identifier that Git generates for each object.
As you have seen before, we do not have to specify the entire SHA1 hash, just the beginning portion that is unique.</li>
<li><code class="ncode">&lt;refname&gt;</code> - We use this type of referencing a lot when checking out branches.  
The <code class="ncode">&lt;refname&gt;</code> is a symbolic name.
An example of this would be <strong>master</strong>, which actually refers to <strong>refs/heads/master</strong>, which you have seen in the <code class="ncode">.git</code> directory.
HEAD is also a <code class="ncode">&lt;refname&gt;</code>.  In general, Git will search through a number of directories to find the <code class="ncode">&lt;refname&gt;</code> that is being referred to;
<div style="padding-left:10px;"><ul><li><code class="ncode">.git/&lt;name&gt;</code></li>
<li><code class="ncode">refs/&lt;name&gt;</code></li>
<li><code class="ncode">refs/tags/&lt;refname&gt;</code></li>
<li><code class="ncode">refs/heads/&lt;name&gt;</code></li>
<li><code class="ncode">refs/remotes/&lt;name&gt;</code></li>
<li><code class="ncode">refs/remotes/&lt;name&gt;/HEAD</code></li>
</ul></div>
So if we used <strong>master</strong> as our <code class="ncode">&lt;refname&gt;</code>, Git would search in <code class="ncode">.git</code> root directory first,
then into <code class="ncode">refs</code>, followed by <code class="ncode">refs/tags</code>, and finishing with <code class="ncode">refs/heads</code>.</li>
<li><code class="ncode">&lt;refname&gt;@{date\</code>} - Now we find a more interesting way of specifying references.
We can use something like <strong>master@{yesterday</strong>}, to show us the closeset commit to match that date time.  
There are more complicated date specifications we can use as well, such as <strong>master@{"last week"</strong>}, or <strong>master@{"3 hours 2 minutes and 10 seconds ago"</strong>}.
We can even put in a specific date and time like so; <strong>master@{"2011-02-26 14:30:00"</strong>}</li>
<li><code class="ncode">&lt;refname&gt;@{&lt;n&gt;\</code>} - This curious definition returns the commit that <code class="ncode">&lt;refname&gt;</code> referred to <code class="ncode">&lt;n&gt;</code> times in the past.
It uses the <em>reflog</em>, which has been discussed before, to discover what commit <code class="ncode">&lt;refname&gt;</code> pointed to.
Be careful when using this reference.  It does not mean the commit that <code class="ncode">&lt;refname&gt;</code> pointed <code class="ncode">&lt;n&gt;</code> commits ago in the tree.
If you have been doing resets and other things, these items show up in the <em>reflog</em>.</li>
<li><code class="ncode">&lt;rev&gt;^&lt;n&gt;</code> - Is a way of asking Git to traverse an object for it's parents and so <code class="ncode">&lt;rev&gt;</code> or <code class="ncode">&lt;rev&gt;^ 1</code> means the first parent of a commit object.
An example of this would be <code class="ncode">master^2</code>.</li>
<li><code class="ncode">&lt;rev&gt;~&lt;n&gt;</code> - Is a way of asking Git to traverse an object for it's <code class="ncode">&lt;n&gt;</code>th grand-parent, following only first parents.
This will take a little understanding and it is advised that you read the man page online for more information about what this really means.</li>
<li><code class="ncode">&lt;rev&gt;^{/&lt;text&gt;\</code>} - This definition actually initiates a search for the youngest commit where the commit message matches the regular expression after the slash.
<code class="ncode">master^{/bug\</code>} is an example of the usage of this reference definition.</li>
<li><code class="ncode">&lt;rev&gt;:&lt;path&gt;</code> - This allows us to obtain the object hash for the file specified at the <code class="ncode">&lt;rev&gt;</code>.
We could then use the <code class="ncode">git show</code> command to view that file.
As an example <code class="ncode">git show HEAD~ 3:readme.txt</code> would show us the file <code class="ncode">readme.txt</code> as it was three grandparents back from HEAD.</li>
</ul></div><br>All of these are valid ways to refer to commits and in some cases objects and trees too.
Imagine a situation where you wanted to view a file called <code class="ncode">readme.txt</code> that was three commits back from a tag of <code class="ncode">v44</code>.
Using our new knowledge, we could use <code class="ncode">git show v44~ 3:readme.txt</code>.
There are several other ways of referring to commits, but these are out of the scope of this chapter.
If you would like more information, refer to the man page for <code class="ncode">git rev-parse</code>.


<h1>Week 7</h1>
<h2>Day 1 - "Networking with a difference"</h2>
<h3>Pushing across a LAN</h3>
Now we have a complete copy of our repository in another location.
At the moment we have created this clone on the same machine that our original is.
This isn't really a very good idea for backup purposes.
Git supplies several means with which to talk to a remote machine, but by far the most common of these is to utilise the SSH protocol.
SSH is a secure, encrypted way to communicate with a remote repository.
Which is a must for pushing to an important repository that people are going to pull information from.<br><br>If we assume that for a moment that our user <em>john</em> has now moved to another machine and now wishes to clone a repository that he had on his original machine to this new one.
The commands are identical to that which we used before.
We are going to assume that <em>john</em> already has SSH access to the machine.
In this way, we can issue the commands as follows.<br><br><div id="codeblock"><code>john@akira:~$&nbsp;git&nbsp;clone&nbsp;ssh://john@satsuki/home/john/coderepo&nbsp;coderepo-ne</code><br&nbsp;/>
<code>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/home/john/coderepo-ne/.git/</code><br&nbsp;/>
<code>john@akira's&nbsp;password:</code><br&nbsp;/>
<code>remote:&nbsp;Counting&nbsp;objects:&nbsp;53,&nbsp;done.</code><br&nbsp;/>
<code>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100Receiving&nbsp;objects:&nbsp;100Resolving&nbsp;deltas:&nbsp;100remote:&nbsp;Total&nbsp;53&nbsp;(delta&nbsp;10),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)</code><br&nbsp;/>
<code>john@akira:~$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we have done exactly as before and cloned our repository to a local folder called <code class="ncode">coderepo-ne</code> from the remote URL <code class="ncode">ssh://john@satsuki/home/john/coderepo</code>.
Notice the use of <code class="ncode">ssh://</code> to denote the specification of the SSH protocol.
We have also put the users name in the URL of the remote path.
If the SSH server was running on a different port to usual, that is, on a port other than 22, we could have also added a port number preceded by a colon after the hostname.<br><br>SSH isn't the only protocol that Git can use.
We have already looked at two; local and SSH.
In fact, Git supports a further two protocols and these are HTTP/S and Git's own GIT protocol.
We are going to take a quick look at the Git protocol next, before moving on to HTTP/S.<br><h3>The Git Protocol</h3>
The GIT protocol is the fastest transfer protocol out there for Git repositories.
This should come as no surprise, since it was developed exclusively for use within a Git environment.
It does however have a relatively large drawback.
The drawback is that it provides absolutely no authentication.
For this reason, enabling the GIT protocol on a repository and running the server back-end, (described later), will allow anyone who can talk to the servers port complete read access to the repository.<br><br>If you are serving a large repository on the Internet for example, this could actually be rather beneficial and will allow you to serve pulls quickly and efficiently.
However, though it is possible to enable <em>pushing</em> using the GIT protocol, the lack of security would mean that anyone who could see the server and connect to the port, usually 9418, could make changes to the repository.
This is usually entirely undesirable and as such people will often couple a read-only GIT protocol with a writable SSH protocol for the developers that need push access.<br><h3>The HTTP/S Protocol</h3>
Just as with the GIT protocol, Git can support the HTTP/HTTPS protocol as well.
Setting up this is usually as simple as creating a bare clone of your repository, keeping it up to date, usually via a post-update-hook, which is described later in the book, and simply allowing clients access to this server area.<br><br>Note that the above is only to provide read-only access over HTTP.
It is possible to allow write access, i.e.&nbsp;pushing, over HTTPS, but this is more complicated to set up and is outside the scope of this book.<br><h3>Protocol decision</h3>
Tamagoyaki are about to embark on their decision making process regarding which protocols to use and how to perform their collaboration between themselves and their external partners.
They are going to have to take multiple things into consideration, such as security, speed, administration and storage.
When you begin to implement the Git system yourself, you too will have to think about these decisions and answer questions like:<br><div style="padding-left:10px;"><ul><li>Who is going to require access to the repository?</li>
<li>How many people are going to require access to the repository?</li>
<li>Is the information sensitive, either from an IP perspective or from a customer point of view?</li>
<li>How large is the data that we are hosting?</li>
<li>How large is the change set?</li>
<li>Do we need a QA area?</li>
<li>Do we need a Production area?</li>
</ul></div><br>This is just a short list of the questions that you will need to consider when implementing a full on Git environment.
The beauty of the Git system though, is that it is flexible and very difficult to box yourself into a corner, where a decision made early on prohibits a different approach later on.<br><h2>Day 2 - "Now let's work together"</h2>
<h3>Pure collaboration</h3>
We are now armed with a much clearer idea of how Git works and indeed we are now in a position to actually implement the developmental model that the team of Tamagoyaki need in order to collaborate on their projects.
It should be noted that although we have reached the point of being able to work together on a project, this is not where out discussions about Git will end.
We still have a number of topics to cover and these will be visited as required during the subsequent implementation of Git at Tamagoyaki.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"So I still maintain that we follow the original plan," said Rob.
"Each person has their own repository and is the master of their own commits"<br><br>John shook his head.
"On a small scale," he began,
"that might work."
He paused for a breath.
"But we need to think about scalability too. Whilst I don't think all development work should be in one repository, I also don't think the best way to go is to have a repo for every person."<br><br>"I know it's a rarity, but I gotta agree with John." Klaus spoke whilst idly stabbing his pen lightly into a blob of what looked like modelling clay.
"Think what the chimp would say to it too."<br><br>Martha furrowed her brow,
"The chimp?" she asked.<br><br>John turned to look at Martha and almost regretted having to inform her of yet another of Klaus' pet names.
"That's what Klaus calls Jimmy in IT."<br><br>Martha looked a little horrified,
"Klaus, that's an awful thing to say."<br><br>"What? He spends all day monkeying around in the 'datacenter'. I've never really seen him do any real work at all."
Klaus was looking at Martha who now had one eyebrow raised.
He had used air quotes when voicing the word 'datacenter'.
"Plus he calls it a datacenter, but I've seen inside, it's more like a cupboard with a PC in it."<br><br>"You need to show a little more respect Klaus," Martha threw back, a little more aggressively than she had intended.<br><br>"Guys!! Guys!!" John shouted.
"Can we get back to the topic at hand and deal with Klaus later?"<br><br>The room fell silent for a while, until the comments had transitioned from immediate to short term memory.
"How about doing it by team?"
It was Eugene speaking now.
"You know, kinda like a Mob repository. Each team will have their own repository and the branches inside will belong to the different team members and be named accordingly so. Then we would have a company repository which would hold the projects and would have dev, qa and released branches."<br><br>"You know that's not a bad idea Eugene." Klaus said, trying to redeem himself.
"You da man. How about a hi-five."<br></div><hr><br>The idea of having a Mob repository is not anything new.
Many people decide to split up their teams in this way especially within a company.
For larger repositories it makes a lot of sense as not only does it help to keep development altogether in one place, but it also saves on space and administration overhead.
Managing many smaller repositories is often a lot more time consuming than managing several larger ones.<br><br>However you should always look at the situation and the scenario carefully to see which is going to suit you best.
For Tamagoyaki, there is the prospect of the teams growing soon and so they require a way to get the data organised fairly quickly and effortlessly.
Having many small repositories would likely confuse new members to the team, so the decision to move forward with team based and site based repositories makes sense.<br><br>Tamagoyaki are proposing to have a single repository which will be the <em>blessed</em> repository we discussed way back at the beginning of the book.
This repository will likely hold three branches.
These will relate to development, quality assurance and releases.
To this end it will allow one team to gain access to features that the other teams are working on, via the development branch.
It will allow a QA manager to work on the quality assurance branch and finally, it will allow someone to push these changes through to the released branch.<br><br>The idea is that all development work stays in the development branch.
For Tamagoyaki Inc.
this branch will likely contain mostly finished, but largely untested works.
The teams will work together inside their mob repositories to create new functionality.
Once they are happy, their team leader will push their changes up into the development branch on the <em>blessed</em> repository.
This branch is not guaranteed to be stable.
Sometimes things will break but the development branch is a place that all of the work of the various teams comes together.<br><br>Once the teams hit feature freeze, the point at which they will no longer take any more new features into the code base, they will ask the QA manager to create a <strong>QA</strong> branch.
Bug fixes for current issues will be committed here and when all bugs have been fixed and the code is ready to be released, the release branch will be synced with a specific commit of the <strong>QA</strong> branch.<br><br>If this all sounds a little confusing, we will take a few minutes to digest what we have come up with and draw a few diagrams.
The beauty of Git is that it is so configurable and so by design supports almost limitless workflows.
Unfortunately this can also be a drawback because no two Git setups are generally alike.
The set up of Git is totally customised to the situation or scenario at hand.
In our case, we have merged together two of the workflow models that we presented in the early chapters.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w7-d1.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 1</strong><br>Our workflow</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>We are using a <em>blessed</em> repository with which to store our crown jewels.
This is the repository that contains our main <strong>release</strong> branch.
This branch will always contain reliable stable releases.
Sure, it may contain history of how we reached the stable release, but on a checkout, it will be a solid, buildable, pristine, tagged release.
This repository also contains our <strong>QA</strong> branch.
This is the branch that upon checkout would contain a fairly polished version of the product, but it may still have a few bugs and issues.
Then we have our development branch.
This is where the integration managers from the various teams would pull the code from their teams into a single code base, ready for the QA manager to begin his testing.
This setup may not work for you.
You may require more levels, you may require less.
The fact of the matter is that Git allows you to make that distinction.<br><br>For the developers, we have the team mob repositories.
These repositories will contain multiple branches that the various team members will push to, so that the integration managers are able to pull those changes into the <strong>dev</strong> branch on the <em>blessed</em> repository.<br><br>One item we have not yet touched upon is how to bring changes in from one branch to another.
We have one method which we met earlier, called <em>Merging</em>.
However there are other options open to us, such as patching and rebasing.
Why are they important you might ask? Sometimes merging is not the best way to approach the situation.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
John was beginning to get a little frustrated now.
Some members of the team were clearly not understanding what he was saying and he was fighting hard not to raise his voice.
"It is just messy for me to review is all I am saying. I would much prefer not to have to see all those merge commits in the history when you are developing a simple feature."<br><br>"We could always look at using a rebase." Martha seemed anxious to calm John down.
"I haven't really played with it enough yet, but rebase could be what we are looking for."<br><br>"What does rebase do when it's at home." Sneered Klaus, rolling his eyes.<br><br>Martha picked up the red board pen from the board room table and gingerly took off the lid.
She walked over to the whiteboard.
"For small topics or features," she began,
"where you are not going to have to publish it or you need to take a long time developing, it would make sense to use rebase."
She began drawing little diagrams with circles on the board.
"Rebasing will allow you to take your branch, pick up all the development you have done, update the branch underneath to bring it in-line with your blessed dev branch for example, and then replay your development on top."<br><br>"Won't that change your history? Isn't that a big big no no?"<br><br>"Yes it will change your history, and that's why for some things it isn't appropriate. But it may be just the ticket for what we are trying to do."<br><br>John smiled.
He was beginning to feel like the team members were starting to embrace Git's potential.
</div><hr><br>As you know, each time you merge you create a merge commit.
Whilst this is not a problem, it can leave the tree looking messy.
If you are working on a small feature in a branch, and you want to get the latest features and updates from the dev branch, but you do not want the hassle and untidiness of generating a ton of merge commits.
The best way to get round this is to use the rebase tool.<br><br>As mentioned, the rebase tool can find a common ancestor between two branches, pick up the new commits on your new branch, update the branch underneath and the replay your commits on top.
Figure 2, shows a fairly standard commit tree.
We have made commits <strong>A</strong> and <strong>B</strong>, and then we branch off and create <strong>C</strong> and <strong>D</strong>.
It could well be that the <strong>master</strong> branch containing <strong>A</strong> and <strong>B</strong> actually came from an external source, and we are looking to do some development in our own branch locally.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w7-d2.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 2</strong><br>Standard commit tree example</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Now what will inevitably happen is that some more development will continue in the source project, which is represented in the Figure below by commits <strong>E</strong> and <strong>F</strong>.
This is shown below in Figure 3.
In our use case, we actually want these new changes to be present during our development.
Let us see how we can handle this.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w7-d3.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 3</strong><br>Continued development</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>We could quite happily merge the <strong>master</strong> branch into our own, but that would result in a merge commit being added, plus the fact that as we go further down the line, our development work would be interlaced with various updates from the <strong>master</strong>.
A better way to handle this sometimes, is by using the rebase tool which will achieve the results displayed below in Figure 4.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w7-d4.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 4</strong><br>A rebase in action</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>As you can see we have a slight alteration to the diagram.
Commits <strong>C</strong> and <strong>D</strong> have little ticks next to them.
This is to indicate that they are actually not the same commits as before.
You may be wondering why? Think about it for a few minutes.
In Git, every commits SHA-1 hash is based not only on the contents of that commit, but also on the parent.
In this way, if we move these commits, then their SHA-1 hashes are going to change.
Our notation is simply stating that although the contents of these commits is the same, they are the <strong>C</strong> and <strong>D</strong> that we remember, their identifier will change.<br><br>Remember our discussion about changing the past? This is very relevant here.
Rebasing is the ultimate way to change the past.
Over the next few days, we are going to demonstrate a number of ways that rebase can aid you in your development and produce a clean and structured commit history.
However, care must be taken not to rebase something which others have already pulled.
Remember, with great power, comes great responsibility.<br><br>Let us now turn out attention to actually looking at an example of the rebase tool.
We are going to take our example repository and create a branch.
Then we are going to do some work on the <strong>master</strong> branch and try rebasing our changes.<br><h2>Day 3 - "Rebasing our commitments"</h2>
<h3>Rebase examples</h3>
We are now going to go back to our <code class="ncode">coderepo</code> folder.
This is the one we cloned from in Week 6 to create the <code class="ncode">coderepo-cl</code> repository.
When we left this repository, we were at commit <strong>1c3206a</strong>.
If you have played with the repository at all, it would be a good opportunity for you to bring the wonderful branch to that point.
We are also going to Fast Forward the master branch to that same point to.
Before reading on, try to remember what commands we would use to do this and then check below to see if you are right.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;wonderful</code><br&nbsp;/>
<code>Already&nbsp;on&nbsp;'wonderful'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;reset&nbsp;--hard&nbsp;1c3206a</code><br&nbsp;/>
<code>HEAD&nbsp;is&nbsp;now&nbsp;at&nbsp;1c3206a&nbsp;Added&nbsp;a&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So we begin by ensuring that we are on the <strong>wonderful</strong> branch.
Then we perform a hard reset, to ensure that the HEAD of <strong>wonderful</strong> points to the commit <strong>1c3206a</strong>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;merge&nbsp;wonderful</code><br&nbsp;/>
<code>Updating&nbsp;37950f8..1c3206a</code><br&nbsp;/>
<code>Fast-forward</code><br&nbsp;/>
<code>&nbsp;newfile3&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;newfile3</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Next we use the <code class="ncode">git merge</code> command as before to bring the <strong>master</strong> branch in line with the <strong>wonderful</strong> branch.
As there have been no more commits to <strong>master</strong> since we worked on <strong>wonderful</strong>, it means that once again, the merge can be a simple Fast Forward merge, allowing us to simple change which commit HEAD points to within the <strong>master</strong> branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-v</code><br&nbsp;/>
<code>&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;1c3206a&nbsp;Added&nbsp;a&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>*&nbsp;wonderful&nbsp;1c3206a&nbsp;Added&nbsp;a&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7cc32db&nbsp;Made&nbsp;another&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Finally, we run a <code class="ncode">git branch</code> command to confirm that the branches point to the same commit.
Remember there are other ways we could have achieved this, using <code class="ncode">git log</code> for example.
Now that we can see they point to the same place, we can continue with our introduction to the <code class="ncode">git rebase</code> command.
We will start by making some commits to the <strong>wonderful</strong> branch and see how we can update our underlying master branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"New&nbsp;Changes"&nbsp;&gt;&gt;&nbsp;another_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Updated&nbsp;another&nbsp;file'</code><br&nbsp;/>
<code>[wonderful&nbsp;c0e2f5b]&nbsp;Updated&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"More&nbsp;New&nbsp;Changes"&nbsp;&gt;&gt;&nbsp;another_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Updated&nbsp;another&nbsp;file'</code><br&nbsp;/>
<code>[wonderful&nbsp;8c6a66b]&nbsp;Updated&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"More&nbsp;Super&nbsp;New&nbsp;Changes"&nbsp;&gt;&gt;&nbsp;another_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Updated&nbsp;another&nbsp;file&nbsp;again'</code><br&nbsp;/>
<code>[wonderful&nbsp;b91ec84]&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;gitk&nbsp;--all</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Before we continue, there is a problem in the trenches.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Ahh dang it" shouted Simon.
"That's really not very helpful to anyone."<br><br>"What's up?" said Martha over the cubicle wall.
She stood up, knocking a pile of papers over that were hanging precariously on the edge of the desk.
They scattered across the floor creating a white dividing line down the middle of the office.
She mutter something under her breath.
John and Simon began to help tidy the papers up whilst Simon started stating his problem.<br><br>"Well, I commit two commits that used the same commit message, I really wasn't thinking. Plus the fact that they should really have been one commit."<br><br>"Just reset back and do the work again," shouted an eavesdropping Klaud unhelpfully.
A round of raised eyebrows circled the paper-stackers.<br><br>"You could use rebase." Martha was standing next to the desk now and was arranging the stack in a more suitable position on the desk.<br><br>"How so?" John looked at Martha inquisitively.<br><br>Martha giggled.
"Rebase can do a lot more than just replaying commits you know. Some of the more simpler tasks are ... well ... let me show you."
</div><hr><br>Looking at our example commits, it would appear that we have made the same mistake as Simon.
Our commits, <strong>c0e2f5b</strong> and <strong>8c6a66b</strong> have got the same commit message.
Not very helpful at all.
Let us see how <code class="ncode">git rebase</code> can help us out here.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;rebase&nbsp;-i&nbsp;HEAD~3</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We have told Git to run the <code class="ncode">rebase</code> command using the <code class="ncode">-i</code> parameter.
This will put Git into <em>interactive</em> mode.
We have also asked Git to rebase the last three commits.
The <code class="ncode">HEAD~3</code> is used like before to tell us to go back three commits from the HEAD references.
When we run this command, we are presented with a text file in our default text editor.<br><br><div id="codeblock"><code>pick&nbsp;c0e2f5b&nbsp;Updated&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>pick&nbsp;8c6a66b&nbsp;Updated&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>pick&nbsp;b91ec84&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>#&nbsp;Rebase&nbsp;1c3206a..b91ec84&nbsp;onto&nbsp;1c3206a</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;Commands:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;p,&nbsp;pick&nbsp;=&nbsp;use&nbsp;commit</code><br&nbsp;/>
<code>#&nbsp;&nbsp;r,&nbsp;reword&nbsp;=&nbsp;use&nbsp;commit,&nbsp;but&nbsp;edit&nbsp;the&nbsp;commit&nbsp;message</code><br&nbsp;/>
<code>#&nbsp;&nbsp;e,&nbsp;edit&nbsp;=&nbsp;use&nbsp;commit,&nbsp;but&nbsp;stop&nbsp;for&nbsp;amending</code><br&nbsp;/>
<code>#&nbsp;&nbsp;s,&nbsp;squash&nbsp;=&nbsp;use&nbsp;commit,&nbsp;but&nbsp;meld&nbsp;into&nbsp;previous&nbsp;commit</code><br&nbsp;/>
<code>#&nbsp;&nbsp;f,&nbsp;fixup&nbsp;=&nbsp;like&nbsp;"squash",&nbsp;but&nbsp;discard&nbsp;this&nbsp;commit's&nbsp;log&nbsp;message</code><br&nbsp;/>
<code>#&nbsp;&nbsp;x,&nbsp;exec&nbsp;=&nbsp;run&nbsp;command&nbsp;(the&nbsp;rest&nbsp;of&nbsp;the&nbsp;line)&nbsp;using&nbsp;shell</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;If&nbsp;you&nbsp;remove&nbsp;a&nbsp;line&nbsp;here&nbsp;THAT&nbsp;COMMIT&nbsp;WILL&nbsp;BE&nbsp;LOST.</code><br&nbsp;/>
<code>#&nbsp;However,&nbsp;if&nbsp;you&nbsp;remove&nbsp;everything,&nbsp;the&nbsp;rebase&nbsp;will&nbsp;be&nbsp;aborted.</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>At the top of the file, you can see the last three commits, along with their commit message, prefixed by the word pick.
We will get to what this really means in a few minutes, but as you can see there are a large number of options within the rebase interactive system.
If we closed the file and left it unchanged, the rebase would end without altering anything.
The options are fairly self explanitory but they allow us to change many elements of a commit or a series of commits.<br><br>In our case, we can use this to reword the second commit, <strong>8c6a66b</strong>.
We are going to modify the lines above to look like the ones below.<br><br><div id="codeblock"><code>pick&nbsp;c0e2f5b&nbsp;Updated&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>r&nbsp;8c6a66b&nbsp;Updated&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>pick&nbsp;b91ec84&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice that we replaced the beginning of the second line, original starting with <code class="ncode">pick</code>, with the letter <code class="ncode">r</code>.
Using the list of available functions above, we can easily see that the <code class="ncode">r</code> corresponds to the <em>reword</em> function, which will allow us to change the wording that we have used for that particular commit.
On saving this and closing this file, Git quickly presents us with another editor window.
This time the window contains a more familiar commit message setup.
We will modify it to show the same as below, and then close the editor.<br><br><div id="codeblock"><code>Updated&nbsp;another&nbsp;file&nbsp;2nd&nbsp;time</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>#&nbsp;Please&nbsp;enter&nbsp;the&nbsp;commit&nbsp;message&nbsp;for&nbsp;your&nbsp;changes.&nbsp;Lines&nbsp;starting</code><br&nbsp;/>
<code>#&nbsp;with&nbsp;'#'&nbsp;will&nbsp;be&nbsp;ignored,&nbsp;and&nbsp;an&nbsp;empty&nbsp;message&nbsp;aborts&nbsp;the&nbsp;commit.</code><br&nbsp;/>
<code>#&nbsp;Not&nbsp;currently&nbsp;on&nbsp;any&nbsp;branch.</code><br&nbsp;/>
<code>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD^1&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;another_file</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;Untracked&nbsp;files:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;include&nbsp;in&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp_file</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>After Git completes working on the rebase, we are presented with the result of our operation.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;rebase&nbsp;-i&nbsp;HEAD~3</code><br&nbsp;/>
<code>[detached&nbsp;HEAD&nbsp;7c35dde]&nbsp;Updated&nbsp;another&nbsp;file&nbsp;2nd&nbsp;time</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>Successfully&nbsp;rebased&nbsp;and&nbsp;updated&nbsp;refs/heads/wonderful.</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So Git has completed the operation, and by running an abbreviated <code class="ncode">git log</code> command, we can see that the fruits of our labour have resulted in the second commit having its working changed.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;--graph&nbsp;--pretty=oneline&nbsp;--all&nbsp;--abbrev-commit&nbsp;--decorate&nbsp;-n&nbsp;4</code><br&nbsp;/>
<code>*&nbsp;aeb5679&nbsp;(HEAD,&nbsp;wonderful)&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>*&nbsp;7c35dde&nbsp;Updated&nbsp;another&nbsp;file&nbsp;2nd&nbsp;time</code><br&nbsp;/>
<code>*&nbsp;c0e2f5b&nbsp;Updated&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>*&nbsp;1c3206a&nbsp;(master)&nbsp;Added&nbsp;a&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><hr><div id="calloutblock"><h3>Note - Rebasing and the hashes</h3>
If you have been paying attention to the SHA-1 hashes as we have been moving through this last piece on rebasing, you may have noticed something interesting.
Though there are commits that we have not altered at all, the commit IDs have indeed changed.
If we take the example where we re-worded the second commit, it is clear to see that subsequent commits have their IDs changed.
In the example, we modified commit <strong>8c6a66b</strong>, but we left <strong>b91ec84</strong> untouched.
In the resulting tree, both have had their IDs changed.<br><br>The reason for this is simple, remember we are replaying commits.
In a sense we are re-committing the changes that were made during that commit.
As we have stated previously, Git is cryptographically secure.
By this we mean that each commit relies on the commit that preceeds it.
So, if we change the ID of a preceeding commit, all subsequent ones have to change also.
</div><hr><br>Let us try this rebase again.
This time we will use the squash option to merge the two similar commits into one.
We will run the same command as before; <code class="ncode">git rebase -i HEAD~3</code>.
This time we will use the <code class="ncode">s</code> prefix to the line to choose <em>squashing</em> as our method.
We could have used the word <code class="ncode">squash</code> instead of <code class="ncode">s</code>, but for the laziness in all of us, we will opt for the single letter versions for now.<br><br><div id="codeblock"><code>pick&nbsp;c0e2f5b&nbsp;Updated&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>s&nbsp;7c35dde&nbsp;Updated&nbsp;another&nbsp;file&nbsp;2nd&nbsp;time</code><br&nbsp;/>
<code>pick&nbsp;aeb5679&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>#&nbsp;Rebase&nbsp;1c3206a..aeb5679&nbsp;onto&nbsp;1c3206a</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now when we save and close the file, we are presented with a slightly different screen.
As we are squashing several commits together into one, we need to choose a commit message.
The message needs to be descriptive enough that it will accturately let a developer see what has been updated in this single commit.
We will delete these lines and replace them with the comment <code class="ncode">Updated another file with 2 edits</code>.<br><br><div id="codeblock"><code>#&nbsp;This&nbsp;is&nbsp;a&nbsp;combination&nbsp;of&nbsp;2&nbsp;commits.</code><br&nbsp;/>
<code>#&nbsp;The&nbsp;first&nbsp;commit's&nbsp;message&nbsp;is:</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>Updated&nbsp;another&nbsp;file</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>#&nbsp;This&nbsp;is&nbsp;the&nbsp;2nd&nbsp;commit&nbsp;message:</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>Updated&nbsp;another&nbsp;file&nbsp;2nd&nbsp;time</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>After completion, Git shows us that the rebase has been successful.<br><br><div id="codeblock"><code>[detached&nbsp;HEAD&nbsp;1ffe37f]&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;2&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>Successfully&nbsp;rebased&nbsp;and&nbsp;updated&nbsp;refs/heads/wonderful.</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>By using the <code class="ncode">git log</code> message, we can see that the two commits have indeed been replaced by one.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;--graph&nbsp;--pretty=oneline&nbsp;--all&nbsp;--abbrev-commit&nbsp;--decorate&nbsp;-n&nbsp;4</code><br&nbsp;/>
<code>*&nbsp;4d91aab&nbsp;(HEAD,&nbsp;wonderful)&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>*&nbsp;1ffe37f&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>*&nbsp;1c3206a&nbsp;(master)&nbsp;Added&nbsp;a&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>*&nbsp;37950f8&nbsp;Continued&nbsp;Development</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Actually that's pretty cool," commented Simon, after Martha had shown him how to use rebase to squash and reword.
She smiled, but said nothing.
Martha had an uncanny knack for knowing when there was going to be another question.
"So, just how would we use git rebase for keeping a development tree up to date?"<br><br>Martha ruffled Simon's hair.
She liked his youthful enthusiasm.
"How about we take a crack at that tomorrow eh?"
</div><hr><br><h2>Day 4 - "Starting to get rebased"</h2>
<h3>Using rebase with branches</h3>
Up until now we have used <code class="ncode">git rebase</code> to work on our current branch, modifying a few things here and there.
This is actually one of the simplest things that rebase can perform, and as hinted to in our workflow design, we can actually use <code class="ncode">git rebase</code> to perform something called <em>Continuous Integration</em>.<br><br>As we stated before, one of the most interesting uses of using <code class="ncode">git rebase</code> is to update your branch with changes from another, whilst keeping your development intact.
The great part about it is that there is no messy merging, your commits appear at the end of the tree which makes things nice and tidy.
Let us go back to our example and add some more commits to the <strong>master</strong> branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;touch&nbsp;cont_dev</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"New&nbsp;info"&nbsp;&gt;&gt;&nbsp;cont_dev</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;cont_dev</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Start&nbsp;new&nbsp;dev'</code><br&nbsp;/>
<code>[master&nbsp;1968324]&nbsp;Start&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;cont_dev</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"A&nbsp;cool&nbsp;function"&nbsp;&gt;&gt;&nbsp;cont_dev</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Finished&nbsp;new&nbsp;dev'</code><br&nbsp;/>
<code>[master&nbsp;f8d5100]&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;logg&nbsp;-n5</code><br&nbsp;/>
<code>*&nbsp;f8d5100&nbsp;(HEAD,&nbsp;master)&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>*&nbsp;1968324&nbsp;Start&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;4d91aab&nbsp;(wonderful)&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;1ffe37f&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>|/</code><br&nbsp;/>
<code>*&nbsp;1c3206a&nbsp;Added&nbsp;a&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>You may have noticed that we seem to have introduced a new command here called <code class="ncode">git logg</code>.
The command seems to do exactly the same as our <code class="ncode">git log --graph --pretty=oneline --all --abbrev-commit --decorate</code> command.
For more information about what we have done here, see the callout called <strong>An alias in our midst</strong>.<br><hr><div id="calloutblock"><h3>Information - An alias in our midst</h3>
Some times, you will get tired of typing the same old long string of parameters into Git.
Though some people tend to frown upon using them, aliases can significantly increase your productivity, by allowing you to shortcut annoyingly long commands.
You may have noticed our <code class="ncode">git log --graph --pretty=oneline --all --abbrev-commit --decorate</code> command from before.
It is awfully long.
Let us create an alias called <code class="ncode">git logg</code>.<br><br>There are multiple ways to do this, but we are going to get a little down and dirty and edit the <code class="ncode">.git/config</code> file in our repository.
You will find a few <em>stanzas</em> which start like this <code class="ncode">[core]</code>, followed by a number of lines.
If you don't already have one, use the editor to add <code class="ncode">[alias]</code> at the end of the file, so that your file has a section looking like the following.<br><br><div id="codeblock"><code>[alias]</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logg&nbsp;=&nbsp;log&nbsp;--graph&nbsp;--pretty=oneline&nbsp;--all&nbsp;--abbrev-commit&nbsp;--decorate</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Once saved, we can use <code class="ncode">git logg</code> just like any other Git command.
As you can see from the example in the text, we can even append more parameters that the parent command <code class="ncode">git log</code> usually accepts.
So we can do things like <code class="ncode">git logg -n5</code> to get only five entries.
</div><hr><br>So we have two development trees, our <strong>master</strong> which is what our development work is based on, and our <strong>wonderful</strong> branch, which is where we are performing our development work.
The task now is to update the <strong>wonderful</strong> branch, with all of the changes that have taken place in <strong>master</strong>.
To do this, we use the <code class="ncode">git rebase</code> tool once more, but this time in a slightly different manner.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;wonderful</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'wonderful'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;rebase&nbsp;master</code><br&nbsp;/>
<code>First,&nbsp;rewinding&nbsp;head&nbsp;to&nbsp;replay&nbsp;your&nbsp;work&nbsp;on&nbsp;top&nbsp;of&nbsp;it...</code><br&nbsp;/>
<code>Applying:&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>Applying:&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;logg&nbsp;-n5</code><br&nbsp;/>
<code>*&nbsp;5167cce&nbsp;(HEAD,&nbsp;wonderful)&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>*&nbsp;551086e&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>*&nbsp;f8d5100&nbsp;(master)&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>*&nbsp;1968324&nbsp;Start&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>*&nbsp;1c3206a&nbsp;Added&nbsp;a&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We started by checking out the <strong>wonderful</strong>.
With the <code class="ncode">git rebase master</code> command, we told Git to take all of the changes in our topic branch called <strong>wonderful</strong>, and replay them on top of the new <strong>master</strong>.
We could have also used the command <code class="ncode">git rebase master topic</code> which would actually have done the original <code class="ncode">git checkout</code> for us.<br><br>Notice again, that our commit IDs have changed.
The contents, in this case, remain identical, as we have not hit upon any conflicts during out rebase.
If we had, we would have to have resolved that, and then run the <code class="ncode">git rebase --continue</code>, or <code class="ncode">git rebase --abort</code> to abort the rebase completely.<br><br>So, our wonderful branch is now sat on top of the new development changes and instead of having two diverging branch heads, we now have a single branch which <strong>wonderful</strong> extends from.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Martha!" Simon shouted across the office at the seemingly new Git expert.
"HELP!!"<br><br>Martha got up from her seat.
It hadn't been fifteen minutes since she had shown Simon how to rebase branches and now he was calling her again.
At first she had tried to ignore it, but the waves of SOS had plunged through the headphones and reverberated round her head one too many times.
She placed the music on hold and put the headphones on the desk.<br><br>"What's up Simon?" she asked, smiling at John who was chuckling to himself at his desk.<br><br>"Well, I kinda rebased, but I wish I hadn't now, cos it all went wrong. How can I go back?"
</div><hr><br>It's an interesting question.
How would we move back again? We have rewritten history, how could we possibly hope to go back again? We have discussed before how most things in Git are never really immediately gone, even if we delete them.
Does this apply here too? Of course it does.
Remember that a branch is really just defined by which commit the HEAD points to.
Let us draw a few diagrams to show how the tree of commits looks before and after our rebase.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w7-d5.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 5</strong><br>Our repository before the rebase</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Figure 5 shows our repository before we perform the rebase.
We can quite clearly see that there are two branches, diverging from the common ancestor, <strong>1c3206a</strong>.
In Figure 6, we see the repository after the rebase has taken place.
Notice that the two commits that <em>were</em> forming the <strong>wonderful</strong> branch are now coloured in grey.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w7-d6.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 6</strong><br>Our repository after the rebase</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>The grey commits are no longer referenced.
No branche HEADs point to them, and no other commits rely upon them.
In short they have been orphaned, or are left <em>dangling</em>.
A dangling commit has no references left pointing to it.
Remember each commit relies on its parent.
Therefore because the HEAD of <strong>wonderful</strong> now points to <strong>5167cce</strong>, and that in turn points to <strong>551086e</strong>.
The original commit line is unchanged.<br><br>Thinking back to previous weeks, we have had a similar situation before.
If we know the commit ID that we wish to return to, there really is nothing more complicated than issuing a <code class="ncode">git reset</code>.
The only tricky part is knowing the commit you wish to return to.<br><br>We do however have a weapon at our disposal.
The <code class="ncode">git log</code> tool can be used with the <code class="ncode">-g</code>.
This parameter forces the Git to refer to the <em>reflog</em> for entries, instead of traversing the usualy tree.
If you remember, the reflog is our key to seeing what happened in the past.
It holds a list of all the previous HEADs of each branch.
By supplying the branch name, we can see everything that happened to the <strong>wonderful</strong> branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;-g&nbsp;wonderful&nbsp;-n2</code><br&nbsp;/>
<code>commit&nbsp;5167cce7864ca71420ce5dc37ec9b3f931727db3</code><br&nbsp;/>
<code>Reflog:&nbsp;wonderful@{0}&nbsp;(John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;)</code><br&nbsp;/>
<code>Reflog&nbsp;message:&nbsp;rebase&nbsp;finished:&nbsp;refs/heads/wonderful&nbsp;onto&nbsp;f8d5100142b43ffaba9bb</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Wed&nbsp;Jul&nbsp;6&nbsp;09:30:40&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;4d91aab57aaad020e62486805e25d0d6f06fdc3e</code><br&nbsp;/>
<code>Reflog:&nbsp;wonderful@{1}&nbsp;(John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;)</code><br&nbsp;/>
<code>Reflog&nbsp;message:&nbsp;rebase&nbsp;-i&nbsp;(finish):&nbsp;refs/heads/wonderful&nbsp;onto&nbsp;1c3206a</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Wed&nbsp;Jul&nbsp;6&nbsp;09:30:40&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, the log shows that we recently completed two rebases.
The first resulted in an ID of <strong>4d91aab</strong> and the second resulted in <strong>5167cce</strong>.
As it happens, we are trying to get back to the end of that first rebase, before we ran the second.
So if we run the reset against that ID, we should return to our pre-rebased state.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;reset&nbsp;--hard&nbsp;4d91aab</code><br&nbsp;/>
<code>HEAD&nbsp;is&nbsp;now&nbsp;at&nbsp;4d91aab&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;logg&nbsp;-n5</code><br&nbsp;/>
<code>*&nbsp;f8d5100&nbsp;(master)&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>*&nbsp;1968324&nbsp;Start&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;4d91aab&nbsp;(HEAD,&nbsp;wonderful)&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;1ffe37f&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>|/</code><br&nbsp;/>
<code>*&nbsp;1c3206a&nbsp;Added&nbsp;a&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, even though the commit messages are identical, the history of them differs.
Obviously now, it is our rebased version which is left dangling and if it continues to go unused, it will eventually be deleted.
Of course it is also possible to create a branch to point to the dangling commit.
In this way it would never get deleted.
Let us just see how we could achieve this.<br><br>Armed with the knowledge that the commit we are looking for is <strong>5167cce</strong>, we can run the <code class="ncode">git branch</code> command and specify a starting point.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;keeprebase&nbsp;5167cce</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-v</code><br&nbsp;/>
<code>&nbsp;&nbsp;keeprebase&nbsp;5167cce&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f8d5100&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>*&nbsp;wonderful&nbsp;&nbsp;4d91aab&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7cc32db&nbsp;Made&nbsp;another&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;logg&nbsp;-n7</code><br&nbsp;/>
<code>*&nbsp;5167cce&nbsp;(keeprebase)&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>*&nbsp;551086e&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>*&nbsp;f8d5100&nbsp;(master)&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>*&nbsp;1968324&nbsp;Start&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;4d91aab&nbsp;(HEAD,&nbsp;wonderful)&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;1ffe37f&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>|/</code><br&nbsp;/>
<code>*&nbsp;1c3206a&nbsp;Added&nbsp;a&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-w7-d7.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 7</strong><br>Our repository after the recovery</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Notice our branch is now created and looking at the log, it contains the same two commits and the tree looks as we would expect.
We have our <code class="ncode">another_file</code> updates in both branches.<br><h2>Day 5 - "I could rebase the world"</h2>
<h3>Migrating commits</h3>
We are almost at the end our our journey with the rebase tool and have one more stop before we start looking at other features of Git.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
Rob was sitting with his head on the table.
Every few seconds he would lift it up before thumping it down again.
It was obvious to everyone in the office that Rob had done something wrong.
In the end it was John who broke the rhythmic bass drum.
He pulled up a chair next to the desk.<br><br>"Come on Rob," started John, "What's eating you?"<br><br>"Well, I have been working away, committing to a branch, but it wasn't the right one."
He looked like he was almost in tears.<br><br>John frowned, "Can't you just move a new branch forward and then rewind the other one?"<br><br>"No." His voice was tired and weary.
"The ancestor of the branch isn't right. I thought I had branched from master, but I'd actually branched from a dev branch. Now I can't find a way to bring my commits back. Short of cherry picking each one, but I have over fifty of them. Guess it's time to start scripting."<br><br>John smiled and shook his head, "Don't worry Rob, I have a better plan"
</div><hr><br>Cherry picking is a method of copying the contents of one commit into another and is something that we will pick up on later, but we will first look at our final use of rebase.
Imagine the scenario painted above.
You made a branch, have been merrily committing for hours, before realising that actually you branched from the wrong place.<br><br>In Git, this isn't a problem.
Things get complicated if you've been doing more advanced operations during this period, but if you have been simply adding commits, we can use rebase to migrate that tree of commits to a different ancestor.<br><br>Take the example we have been working on, currently we have a <strong>master</strong> branch and a <strong>wonderful</strong> branch, and these differ.
Let us say we are currently sitting on the <strong>wonderful</strong> branch, but we thought we were on the <strong>branch</strong> and we created a new branch called develop.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;develop</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;'develop'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now let us commit a few files and see what we can do about fixing our problem.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"new&nbsp;dev&nbsp;work"&nbsp;&gt;&gt;&nbsp;newfile3</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a</code><br&nbsp;/>
<code>[develop&nbsp;eb7f633]&nbsp;Some&nbsp;new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"newer&nbsp;dev&nbsp;work"&nbsp;&gt;&gt;&nbsp;newfile2</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a</code><br&nbsp;/>
<code>[develop&nbsp;5e0964b]&nbsp;More&nbsp;new&nbsp;deving</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Let us use our little log alias and see the work we just did on our <strong>"master"</strong> branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;logg&nbsp;-n8</code><br&nbsp;/>
<code>*&nbsp;5e0964b&nbsp;(HEAD,&nbsp;develop)&nbsp;More&nbsp;new&nbsp;deving</code><br&nbsp;/>
<code>*&nbsp;eb7f633&nbsp;Some&nbsp;new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>*&nbsp;4d91aab&nbsp;(wonderful)&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>*&nbsp;1ffe37f&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;5167cce&nbsp;(keeprebase)&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;551086e&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;f8d5100&nbsp;(master)&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;1968324&nbsp;Start&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>|/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Whoops! The commits were supposed to be on a branch that stemmed from <strong>master</strong>, not one that stems from <strong>wonderful</strong>.
This is where <code class="ncode">git rebase</code> comes to our assistance once more.
With one command, we can move those commits to a branch that stems from <strong>master</strong>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;rebase&nbsp;--onto&nbsp;master&nbsp;wonderful&nbsp;develop</code><br&nbsp;/>
<code>First,&nbsp;rewinding&nbsp;head&nbsp;to&nbsp;replay&nbsp;your&nbsp;work&nbsp;on&nbsp;top&nbsp;of&nbsp;it...</code><br&nbsp;/>
<code>Applying:&nbsp;Some&nbsp;new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>Applying:&nbsp;More&nbsp;new&nbsp;deving</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;logg&nbsp;-n8</code><br&nbsp;/>
<code>*&nbsp;aed985c&nbsp;(HEAD,&nbsp;develop)&nbsp;More&nbsp;new&nbsp;deving</code><br&nbsp;/>
<code>*&nbsp;af3c6d7&nbsp;Some&nbsp;new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;5167cce&nbsp;(keeprebase)&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;551086e&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>|/</code><br&nbsp;/>
<code>*&nbsp;f8d5100&nbsp;(master)&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>*&nbsp;1968324&nbsp;Start&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;4d91aab&nbsp;(wonderful)&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;1ffe37f&nbsp;Updated&nbsp;another&nbsp;file&nbsp;with&nbsp;2&nbsp;edits</code><br&nbsp;/>
<code>|/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice in the output above that we have used our <code class="ncode">git rebase</code> tool with a new <code class="ncode">--onto master</code> parameter.
Basically the syntax is stating that we would like to take the commits between <strong>wonderful</strong> and <strong>develop</strong> and place them onto <strong>master</strong> instead.<br><br>To clean up our repository, we are going to delete our <strong>keeprebase</strong> branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-D&nbsp;keeprebase</code><br&nbsp;/>
<code>Deleted&nbsp;branch&nbsp;keeprebase&nbsp;(was&nbsp;5167cce).</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We have reached the end of our tour with the rebase tool.
It is exceedingly powerful and is definitely one of the tools that you should understand before using.
As stated before, do not forget the fact that rebasing changes history.
In all cases that we have used rebase, commit IDs have been changed and therefore you must be very careful when using it.<br><br><h2>Summary - John's Notes</h2>
<h3>Commands</h3>
<div style="padding-left:10px;"><ul><li><code class="ncode">git rebase -i HEAD~3</code> - Runs the rebase tool interactively for the last three commits</li>
<li><code class="ncode">git rebase &lt;branchA&gt; &lt;branchB&gt;</code> - Lift all commits between the common ancestor of branchA and branchB and replay them on top of branchB</li>
<li><code class="ncode">git branch &lt;branch_name&gt; &lt;startpoint&gt;</code> - Create a new branch starting from a definte start point</li>
<li><code class="ncode">git rebase --onto master &lt;branchC&gt;  &lt;branchA&gt; &lt;branchB&gt;</code> - Lift all commits between the common ancestor of branchA and branchB and replay them on top of branchC</li>
</ul></div><br><h3>Terminology</h3>
<div style="padding-left:10px;"><ul><li><strong>SSH</strong> - A type of secure network protocol</li>
<li><strong>HTTP</strong> - The protocol that is used to serve internet pages</li>
<li><strong>Rebase</strong> - Used primarily for lifting commits and reapplying them to another base branch</li>
</ul></div>

<h1>After Hours Week 7</h1>
<h2>"Network Communicating"</h2>
The last week began by looking at some networking communication.
In the After Hours section this week, we are going to look at two tools which are used for network communication.<br><h3>Brewing a website - in an instant</h3>
The <em>Instaweb</em> tool allows you to spawn a web service quickly and easily, using a web daemon of your choice.
The <em>Instaweb</em> tool actually uses <code class="ncode">gitweb</code> which is a more permanent solution for obtaining the same functionality as <em>Instaweb</em>.
If you have never played with web services before it would be worth spending a few minutes understanding a little about how web daemons work.
This tool is not available on the Windows platform, but it can be used on both MacOS and Linux.<br><em>Instaweb</em> allows us to browse our repository from the comfort of a web browser.
We also have another benefit to running this from a web server.
We can allow people to access our repository to look around without giving them the ability to change anything or make any commits.<br><br>Before we run <code class="ncode">git instaweb</code>, we need to ensure that we have a web daemon available to us.
<em>Instaweb</em> automatically creates a configuration file for the web daemon of your choice, runs the daemon on a custom network port,
and loads a browser automatically pointing to the URL of the web instance you have just configured.
On our example machine, we have installed lighttpd as our choice of web daemon.
Once again it is advised to understand the implications of this before you do it.
On Ubuntu, this can be installed by running <code class="ncode">apt-get install lighttpd</code>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;instaweb</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>The tool is invoked by running <code class="ncode">git instaweb</code> and when started, you should be presented with a browser as pictured below.
In our case, lighttpd has been installed, and so Git will use that as its daemon.
Firefox is also the default browser on this machine and so this is the browser that Git will choose to display the web page in.
If we wanted to use an alternative browser, we could have supplied an argument with <code class="ncode">--browser</code>, like <code class="ncode">--browser chromium</code> for example.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af7-d1.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 1</strong><br>Instaweb's default page</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>The first thing to notice is that the description of the repository is unhelpful.
In Figure 1, it is shown as <code class="ncode">Unnamed repository; edit this...</code>.
It is easy to rectify this, by editing the <code class="ncode">.git/description</code> file.
We are going to use the <code class="ncode">echo</code> command from Linux, as we have throughout the book.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"Our&nbsp;test&nbsp;repository"&nbsp;&gt;&nbsp;.git/description&nbsp;</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>On refreshing the page, the description will be updated.
The next thing to notice is the url.
The screenshot shows our url to be <code class="ncode">http://127.0.0.1:1234/</code>, where <code class="ncode">127.0.0.1</code> is the local address of our Git machine and <code class="ncode">1234</code> is the port.<br><br>Before we start taking a look around the web interface, we should learn how to end the <em>Instaweb</em> session.
If we close the web browser, it does not end the <em>Instaweb</em> process.
In fact, we could load up firefox again, type in the URL <code class="ncode">http://127.0.0.1:1234/</code> and return to the home page of our Git repository.
To close the instance of <em>Instaweb</em> we run the following;<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;instaweb&nbsp;--stop</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now would be a good time to take a quick look at what running <code class="ncode">git instaweb</code> has done to our repository.
If we take a look inside the <code class="ncode">.git</code> folder, we can see that there is a new folder called <code class="ncode">gitweb</code>.
This folder contains configuration a log files for the <em>Instaweb</em> process.
The file we are most interested in is <code class="ncode">httpd.conf</code>.
Looking at the beginning of this file we should see something similar to the following.<br><br><div id="codeblock"><code>server.document-root&nbsp;=&nbsp;"/usr/share/gitweb"</code><br&nbsp;/>
<code>server.port&nbsp;=&nbsp;1234</code><br&nbsp;/>
<code>server.modules&nbsp;=&nbsp;(&nbsp;"mod_setenv",&nbsp;"mod_cgi"&nbsp;)</code><br&nbsp;/>
<code>server.indexfiles&nbsp;=&nbsp;(&nbsp;"gitweb.cgi"&nbsp;)</code><br&nbsp;/>
<code>server.pid-file&nbsp;=&nbsp;"/home/john/coderepo/.git/pid"</code><br&nbsp;/>
<code>server.errorlog&nbsp;=&nbsp;"/home/john/coderepo/.git/gitweb/lighttpd/error.log"</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Here we can see the beginning of the config file that Git has created for using with lighttpd.
If we had other web daemons installed, such as apache, we could override the default of lighttpd by supplying the <code class="ncode">--httpd apache2</code>.
Notice the port number which as been defined as <code class="ncode">1234</code>.
Let us run up <code class="ncode">git instaweb</code> again and see what other features the web interface offers.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af7-d2.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 2</strong><br>Instaweb's repository page (top)</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af7-d3.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 3</strong><br>Instaweb's repository page (bottom)</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Figures 2 and 3 show how the web interface looks when browsing our repository.
At the top of the page we see a history of commits along with a search box which works similar to the <code class="ncode">gitk</code> system which was discussed earlier.
At the bottom of the page, we see our <strong>tags</strong> and <strong>heads</strong>.
There are several link names which we will briefly describe now.<br><div style="padding-left:10px;"><ul><li><strong>shortlog</strong> - Gives a log of the commits, similar to that shown in Figure 2.</li>
<li><strong>commit</strong> - Returns a page that gives details about a specific commit.
The <strong>commit</strong> page is shown in Figure 4.</li>
<li><strong>commitdiff</strong> - Shows how the chosen diff has changed since its parent.  
This is similar to running our <code class="ncode">git diff HEAD~1..HEAD</code> command.</li>
<li><strong>tree</strong> - This page is a simple listing of the tree object which shows all files present in that particular commit.</li>
<li><strong>snapshot</strong> - Possibly one of the most useful links.
Clicking on this will initiate a download of the repositories filesystem at that particular point in time.</li>
<li><strong>log</strong> - Gives a listing of the full log messages.</li>
</ul></div><br>Let us take a little look around the interface.
Choosing the first commit in the list on the homepage and clicking on the <strong>commit</strong> link moves on to the commit page.
Here we can see detailed information about the commit.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af7-d4.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 4</strong><br>Instaweb's default page</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>The <strong>commit</strong>, <strong>tree</strong> and <strong>parent</strong> object hashes are displayed here fore reference.
The <strong>tree</strong> amd <strong>parent</strong> lines are clickable links which will take us to those relevant sections.
We are going to choose the <strong>tree</strong> link.
A screenshot of the resulting page is shown in Figure 5.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af7-d5.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 5</strong><br>Instaweb's default page</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>Going back and clicking on the snapshot link will initiate a download of the entire filesystem, at that point in the repository's life.
As shown in Figure 6.<br><center><table  border="0" cellpadding="0" cellspacing="0" class="image_float_left">
                    <tr>
                      <td style="padding:10px;"><img src="images/chaps/f-af7-d6.png" width="400" ></td>
                      <td class="fade_right">&nbsp;</td>
                    </tr>
                    <tr>
                      <td class="fade_bot_image"><div align="center"><strong>Figure 6</strong><br>Instaweb's default page</div></td>
                      <td class="fade_corner">&nbsp;</td>
                    </tr>
                  </table></center><br>This has been a very brief tour around the <code class="ncode">gitweb</code> system.
Hopefully you can see that this is a very useful tool to add to our Git suite.
If you are considering setting up a permanent web based view for your Git repository, you should not use <em>Instaweb</em>.
This tool is intended for quick and easy web access to a repository.
There are plenty of guides and tutorials available which explain the installation and configuration of <code class="ncode">gitweb</code>.<br><h3>Pushing and pulling with a daemon</h3>
The <code class="ncode">git instaweb</code> daemon is very useful indeed.
However, one function that it does not provide is the ability to clone or fetch from the URL.
Another tool which comes with the Git package is the <code class="ncode">git daemon</code> utility and it is this tool which is going to give us this functionality.
We spoke earlier about the GIT protocol and it just so happens that <code class="ncode">git daemon</code> uses the GIT protocol for transferring data.
Let us have a look at a simple example of using <code class="ncode">git daemon</code>.<br><br><div id="codeblock"><code>john@satsuki:~$&nbsp;git&nbsp;daemon&nbsp;--base-path=/home/john/coderepo</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice how this command has not exited.
This is because the process is still running, waiting for communication.
We can now log into another machine on the same network and clone the repository using our <code class="ncode">git clone</code> command.
We will supply the host name of the machine that we configured with <code class="ncode">git daemon</code>, and a directory for us to clone into.
Notice the presence of <code class="ncode">git://</code> instead of <code class="ncode">ssh://</code> as we used in our previous network cloning example.<br><br><div id="codeblock"><code>rob@mimi:~$&nbsp;cd&nbsp;/tmp</code><br&nbsp;/>
<code>rob@mimi:/tmp$&nbsp;mkdir&nbsp;source</code><br&nbsp;/>
<code>rob@mimi:/tmp$&nbsp;git&nbsp;clone&nbsp;git://satsuki/&nbsp;source</code><br&nbsp;/>
<code>Cloning&nbsp;into&nbsp;source...</code><br&nbsp;/>
<code>fatal:&nbsp;The&nbsp;remote&nbsp;end&nbsp;hung&nbsp;up&nbsp;unexpectedly</code><br&nbsp;/>
<code>rob@mimi:/tmp$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>That did not go as expected and resulted in a failed clone.
If we look back at the source machine we can see something interesteing has appeared.<br><br><div id="codeblock"><code>john@satsuki:~$&nbsp;git&nbsp;daemon&nbsp;--base-path=/home/john/coderepo</code><br&nbsp;/>
<code>[4687]&nbsp;'/home/john/coderepo/.git':&nbsp;repository&nbsp;not&nbsp;exported.</code><br&nbsp;/>
<code>john@satsuki:~$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>This is probably one of the most common of all errors when dealing with <code class="ncode">git daemon</code>.
By default, Git tries to protect your repositories and will not allow them to be exported unless you explicitly tell it to.
We have two ways of doing this.
We can append the <code class="ncode">--export-all</code> parameter to <code class="ncode">git daemon</code>, which will allow exporting of all repositories which are under the path described in <code class="ncode">--base-path</code>.
The second method is to explicitly tell Git on a repository by repository, that we would like for it to be exported, or more accurately that we would like to opportunity to export it.
We are going to do the latter of the two and we do this by creating a special file in the <code class="ncode">.git</code> directory, called <code class="ncode">git-daemon-export-ok</code>.<br><br>To add this file, we are going to need to stop the daemon by pressing the <strong>ctrl+c</strong> key combination.
Then we ran run the commands as shown below.<br><br><div id="codeblock"><code>john@satsuki:~$&nbsp;touch&nbsp;coderepo/.git/git-daemon-export-ok</code><br&nbsp;/>
<code>john@satsuki:~$&nbsp;git&nbsp;daemon&nbsp;--base-path=/home/john/coderepo<br></code><br&nbsp;/>
</div><br>Now we can go back to our second machine again and try to clone the repository as before.<br><br><div id="codeblock"><code>rob@mimi:/tmp$&nbsp;git&nbsp;clone&nbsp;git://satsuki/&nbsp;source</code><br&nbsp;/>
<code>Cloning&nbsp;into&nbsp;source...</code><br&nbsp;/>
<code>remote:&nbsp;Counting&nbsp;objects:&nbsp;71,&nbsp;done.</code><br&nbsp;/>
<code>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100remote:&nbsp;Total&nbsp;71&nbsp;(delta&nbsp;16),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)</code><br&nbsp;/>
<code>Receiving&nbsp;objects:&nbsp;100Resolving&nbsp;deltas:&nbsp;100rob@mimi:/tmp$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Et voila! Our repository has been cloned.
As we exported the root of our repository using the <code class="ncode">--base-path</code> parameter, we do not need to specify to the clone command which repository we are trying to clone.
If you remember we did have some other repositories in the home folder and if we had exported <code class="ncode">/home/john/</code>, instead of <code class="ncode">/home/john/coderepo</code>,
then we could have chosen any of the repositories that lay in the home folder by appending their names to the URL.
An example of this would be <code class="ncode">git://satsuki/coderepo/</code> or <code class="ncode">git://satsuki/coderepo-cl/</code>.<br><br>By default the <code class="ncode">git daemon</code> tool only allows people to fetch objects from the repository.
This is quite sensible because as you can see there is no authentication present with the GIT protocol at all.
You <em>can</em> enable pushing of objects to your repository using the GIT protocol, but this is only advised within a well trusted LAN environment.
Otherwise you are giving whoever else is on your network the capability to push whatever they want into your repository, which as you can understand is not a good idea.<br><br>We can run the daemon tool in the background by supplying the <code class="ncode">--detach</code> parameter.
However if you are unfamiliar to the Linux world, this requires some knowledge to stop the daemon again.
Running the daemon detached will result in your shell returning to the prompt, seemingly not have executed anything.
In fact the process has been moved to the background and no longer supports shell interaction.
The benefit of this is that you do not have to keep a shell window open to run it in.
The downside is that you can no longer end the process with the <strong>ctrl+c</strong> key combination.<br><br>You can hopefully see that by using the <code class="ncode">git daemon</code> tool, it is possible for us to allow other people on our network to have access to our repositories.
Whilst the <code class="ncode">git daemon</code> tool is very useful, it does have its disadvantages as stated, primarily in areas of version control.
However, seeing how efficient the GIT protocol is compared to its other counterparts, it often makes a fantastic device for making a repoitory available to pull from.<br><br>There are much more complicated configurations that can be performed with the daemon tool, but these are out of the scope of this chapter.
The manual page for <code class="ncode">git daemon</code> has some examples to get you started,
and even goes into the areas of virtual hosting to allow multiple Git <em>sites</em> to exist on one server.


<h1>Week 8</h1>
<h2>Day 1 - "Give a man a patch"</h2>
<h3>Collaborating with outsiders</h3>
We have spoken at great length now about rebasing and have seen that it is a very very powerful tool.
It can form part of your workflow in your development cycle.
However, always heed that warning that should send alarm bells ringing in the back of your mind about rebasing.
Rebasing changes the past. Rebasing changes history.
As such, it should be used a) with caution, and b) only by people who understand exactly what they are doing.<br><br>We are going to leave rebasing for a while now, take a quick look at a feature you really should know about
and then focus on some of the more advanced features of Git.
The following situation occurs fairly regularly for some people.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
John was stroking his chin and looking pensively out of the window when Simon approached his desk.
The manager hadn't seen him yet and Simon instinctively swayed a little back and forth, try to make himself known in as subtle a way as possible.
Klaus, who was watching from the corner of his eye took a more direct approach.
He took the out of date org chart down from the office divider, screwed it up into a ball and launched it at John's head.
It struck the manager squarely in the jaw causing him to almost tip from his awkwardly balanced chair.<br><br>John noticed Simon standing there and looked a little surprised.
He then noticed Klaus and in an instant understood the chain of events that had just taken place.
"Sorry Simon," started John, "I've been trying to figure out a problem all morning."<br><br>"It's no problem."  Simon pulled up a chair and sat down. "I was wondering if you had a few minutes to discuss Luigi?"<br><br> * * * <br><br>"Well as Luigi is a contractor, he's not going to get access to our repository here to perform commits directly.
And he doesn't have the capability, nor do I really want him, making our code available on the internet.
But he does have a clone of our repository from last week." John understood the problem.<br><br>"Right!"<br><br>"Have you heard of patching in Git?" asked John.<br><br>Simon looked at his shoes, "Can't say I have John, sorry."  <br><br>John smiled, "No worrys. What we can do is get Luigi to generate a patch of his changes.
We can then take that patch and apply it to our codebase.  Luigi can then just reset his clone when he comes into the office."
Simon nodded as John continued, "Go and ask Martha about it.  I think she's pretty hot on these types of things."<br><br>Klaus giggled, "Think she's hot eh John?"<br><br>The paper was returned.<br></div><hr><br>It is a good question though. Sometimes you may have a repository that is either publically available, or made available to a group of people.
You do not necessarily want to set up a remote tracking branch and pull changes in from every single contributor.
There are two primary reasons for this;
<div style="padding-left:10px;"><ol><li>There are a large number of people submitting small changes to the code.</li>
<li>There are difficulties in communicating between the two repositories either for security or general reasons.</li>
</ol></div><br>In these cases we need another way to apply changes from one branch into another.
Many larger open source projects allow contributors to email in patches.
Git does have some rather advanced ways of dealing with these types of scenarios.
We are going to scratch the surface and look at using three commands <code class="ncode">git apply</code>, <code class="ncode">git format-patch</code> and <code class="ncode">git am</code>.<br><br>First, let us find a way of generating a patch.
Let us take the example we have currently in our repository.
Imagine that the <strong>develop</strong> branch exists on another computer in a clone of our repository.
At some point in time, someone cloned our repository.
They have the HEAD of our repository at the same point as we do, but they have continued to do some development in a new branch called <strong>develop</strong>.
Now they are ready to give those changes back.<br><br>Firstly we are going to look at using the <code class="ncode">git diff</code> tool to generate a patch file which we can apply.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;develop</code><br&nbsp;/>
<code>Already&nbsp;on&nbsp;'develop'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff&nbsp;master&nbsp;develop</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile2&nbsp;b/newfile2</code><br&nbsp;/>
<code>index&nbsp;3545c1d..ff59f55&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile2</code><br&nbsp;/>
<code>+++&nbsp;b/newfile2</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,3&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>&nbsp;and&nbsp;a&nbsp;new&nbsp;awesome&nbsp;feature</code><br&nbsp;/>
<code>+newer&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile3&nbsp;b/newfile3</code><br&nbsp;/>
<code>index&nbsp;638113c..2e00739&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile3</code><br&nbsp;/>
<code>+++&nbsp;b/newfile3</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;These&nbsp;changes&nbsp;are&nbsp;in&nbsp;the&nbsp;origin</code><br&nbsp;/>
<code>+new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>That will generate us a diff from the <code class="ncode">develop</code> to the <code class="ncode">master</code> branch.
We could copy and paste that information from the terminal window into a file, but Linux offers us an easier way of doing this.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff&nbsp;master&nbsp;develop&nbsp;&gt;&nbsp;our_patch.diff</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;cat&nbsp;our_patch.diff&nbsp;</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile2&nbsp;b/newfile2</code><br&nbsp;/>
<code>index&nbsp;3545c1d..ff59f55&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile2</code><br&nbsp;/>
<code>+++&nbsp;b/newfile2</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,3&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>&nbsp;and&nbsp;a&nbsp;new&nbsp;awesome&nbsp;feature</code><br&nbsp;/>
<code>+newer&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile3&nbsp;b/newfile3</code><br&nbsp;/>
<code>index&nbsp;638113c..2e00739&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile3</code><br&nbsp;/>
<code>+++&nbsp;b/newfile3</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;These&nbsp;changes&nbsp;are&nbsp;in&nbsp;the&nbsp;origin</code><br&nbsp;/>
<code>+new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So we can see that the file itself has the information we are looking for.
Now we can use the <code class="ncode">git apply</code> tool to actually modify the files in <strong>master</strong> and bring in the changes that have happened in <strong>develop</strong>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;apply&nbsp;our_patch.diff</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile2&nbsp;b/newfile2</code><br&nbsp;/>
<code>index&nbsp;3545c1d..ff59f55&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile2</code><br&nbsp;/>
<code>+++&nbsp;b/newfile2</code><br&nbsp;/>
<code>@@&nbsp;-1,2&nbsp;+1,3&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;Another&nbsp;new&nbsp;file</code><br&nbsp;/>
<code>&nbsp;and&nbsp;a&nbsp;new&nbsp;awesome&nbsp;feature</code><br&nbsp;/>
<code>+newer&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile3&nbsp;b/newfile3</code><br&nbsp;/>
<code>index&nbsp;638113c..2e00739&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile3</code><br&nbsp;/>
<code>+++&nbsp;b/newfile3</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;These&nbsp;changes&nbsp;are&nbsp;in&nbsp;the&nbsp;origin</code><br&nbsp;/>
<code>+new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Updated&nbsp;with&nbsp;patch'</code><br&nbsp;/>
<code>[master&nbsp;81eee9f]&nbsp;Updated&nbsp;with&nbsp;patch</code><br&nbsp;/>
<code>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;2&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff&nbsp;develop&nbsp;master</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Of course doing things this way means that we still have to commit our changes.
Plus, all of the changes that we have made in the patch are committed in one block.
Sure, we could split that using some of the techniques in the After Hours sections, but then we may not always be aware of what should be split where.<br><h3>Can we have some order please?</h3>
There is another tool that can come to our rescue here.
It is primarily used for working with  mailboxes, but it also has some other uses which we will describe here.
Would it not be nice to be able to have each commit that we want to use as a patch in a separate patch file.
The file <code class="ncode">our_patch.diff</code> above contained two commits worth of data.
We have access to another tool in our fight against disparate systems.
This is the <code class="ncode">git format-patch</code> command.<br><br>First we will undo the changes we made previously by resetting the <strong>master</strong> branch back to its older position and deleting the <code class="ncode">our_patch.diff</code> file.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;reflog&nbsp;show&nbsp;master&nbsp;-n&nbsp;4</code><br&nbsp;/>
<code>81eee9f&nbsp;master@{0}:&nbsp;commit:&nbsp;Updated&nbsp;with&nbsp;patch</code><br&nbsp;/>
<code>f8d5100&nbsp;master@{1}:&nbsp;commit:&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>1968324&nbsp;master@{2}:&nbsp;commit:&nbsp;Start&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;reset&nbsp;--hard&nbsp;f8d5100</code><br&nbsp;/>
<code>HEAD&nbsp;is&nbsp;now&nbsp;at&nbsp;f8d5100&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;rm&nbsp;our_patch.diff</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We used the <code class="ncode">git reflog</code> command to show what the last four <strong>master</strong> HEAD values were.
Then we reset the branch back to the point before the <code class="ncode">git apply</code>.
Finally we deleted the patch.
Now let us see how to use the <code class="ncode">git format-patch</code> command to create multiple patch files.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;format-patch&nbsp;master..develop</code><br&nbsp;/>
<code>0001-Some-new-dev-work.patch</code><br&nbsp;/>
<code>0002-More-new-deving.patch</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>It would appear that the result of this command is that two files have been generated.
Let us confirm our suspicions and <code class="ncode">cat</code> the contents of them to ensure that they contain the data we expect.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;cat&nbsp;0001-Some-new-dev-work.patch&nbsp;</code><br&nbsp;/>
<code>From&nbsp;af3c6d730a8632d99b5626a7c0e921d14af21f50&nbsp;Mon&nbsp;Sep&nbsp;17&nbsp;00:00:00&nbsp;2001</code><br&nbsp;/>
<code>From:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;Thu,&nbsp;7&nbsp;Jul&nbsp;2011&nbsp;19:01:59&nbsp;+0100</code><br&nbsp;/>
<code>Subject:&nbsp;[PATCH&nbsp;1/2]&nbsp;Some&nbsp;new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>---</code><br&nbsp;/>
<code>&nbsp;newfile3&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>diff&nbsp;--git&nbsp;a/newfile3&nbsp;b/newfile3</code><br&nbsp;/>
<code>index&nbsp;638113c..2e00739&nbsp;100644</code><br&nbsp;/>
<code>---&nbsp;a/newfile3</code><br&nbsp;/>
<code>+++&nbsp;b/newfile3</code><br&nbsp;/>
<code>@@&nbsp;-1&nbsp;+1,2&nbsp;@@</code><br&nbsp;/>
<code>&nbsp;These&nbsp;changes&nbsp;are&nbsp;in&nbsp;the&nbsp;origin</code><br&nbsp;/>
<code>+new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>--&nbsp;</code><br&nbsp;/>
<code>1.7.4.1</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Woah! Hold on a minute. This does not seem to be a normal diff file at all.
In fact, that is absolutely right. This is a patch file and the two are not the same.
The patch file contains much more information than the simple diff file.
For a start we get information about which commit this patch came from, who created it, when and a subject.
In fact this looks almost like an email.  In fact it is created to resemble a format that would be easily emailable.<br><br>We have specified a range of commits to the <code class="ncode">git format-patch</code> command with the parameter <code class="ncode">master..develop</code>.
The format of that parameter should be familar from earlier chapters when we utilised it for commands like <code class="ncode">git diff</code> and <code class="ncode">git log</code>.
We could now take those files, email them to someone else and they could apply them.
Let us learn one more tool, and see how we would apply those patches when they had been received at the other end.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;am&nbsp;0001-Some-new-dev-work.patch</code><br&nbsp;/>
<code>Applying:&nbsp;Some&nbsp;new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;am&nbsp;0002-More-new-deving.patch</code><br&nbsp;/>
<code>Applying:&nbsp;More&nbsp;new&nbsp;deving</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;diff&nbsp;master..develop</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Of course this is just a simple example case and in actual usage there may be cases where conflicts and other complications occur.
Looking at a log output, we can see that the original dates and times of the commits are maintained and are not updated.
We can ignore this if we wish and use the <code class="ncode">--ignore-date</code> parameter to use the current date when committing the patch to the repository.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;-n4</code><br&nbsp;/>
<code>commit&nbsp;30900fe1b7e72411dabab8b02070f36e2431f704</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Jul&nbsp;7&nbsp;19:02:15&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;More&nbsp;new&nbsp;deving</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;a8281fb589e36389cc8cb0da7ebee225b4d1adfc</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Jul&nbsp;7&nbsp;19:01:59&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Some&nbsp;new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;f8d5100142b43ffaba9bbd539ba4fd92af79bf0e</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Jul&nbsp;7&nbsp;08:39:29&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>commit&nbsp;1968324ce2899883fca76bc25496bcf2b15e7011</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Jul&nbsp;7&nbsp;08:39:07&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Start&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Interestingly if we use our alias for the log command we see something maybe a little unexpected.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;logg&nbsp;-n6</code><br&nbsp;/>
<code>*&nbsp;30900fe&nbsp;(HEAD,&nbsp;master)&nbsp;More&nbsp;new&nbsp;deving</code><br&nbsp;/>
<code>*&nbsp;a8281fb&nbsp;Some&nbsp;new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;aed985c&nbsp;(develop)&nbsp;More&nbsp;new&nbsp;deving</code><br&nbsp;/>
<code>|&nbsp;*&nbsp;af3c6d7&nbsp;Some&nbsp;new&nbsp;dev&nbsp;work</code><br&nbsp;/>
<code>|/&nbsp;&nbsp;</code><br&nbsp;/>
<code>*&nbsp;f8d5100&nbsp;Finished&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>*&nbsp;1968324&nbsp;Start&nbsp;new&nbsp;dev</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice that the branch <strong>master</strong> has not been simply fast forwarded to that of commit of <strong>develop</strong>.
This is because we have not performed a merge, but in a sense we have manually made that changes to the files and created separate commits for them.
In this way the commits <strong>30900fe</strong> and <strong>a8281fb</strong> are not the same as their <strong>develop</strong> counterparts.<br><br>If you intend to use this workflow, it is worth spending some time reading the man page for <code class="ncode">git am</code> and <code class="ncode">git format-patch</code> as both of them hold valuable information regarding the customisation and handling of patches and emails.
Tamagoyaki Inc. are not going to use this workflow often and so just applying a few patches here and there from contractors using the methods is prefectly acceptable to them.
If you were a large open source establishment, or any company that accepts a large number of patches, you may want to take a closer look at how to work these.
Now it is time to move on to some more advanced topics within Git, but first a little cleanup.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;rm&nbsp;0001-Some-new-dev-work.patch&nbsp;</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;rm&nbsp;0002-More-new-deving.patch&nbsp;</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><h2>Day 2 - "Looking for problems"</h2>
<h3>A problem shared is a problem bisected</h3>
During most software development, bugs are introduced.
Sometimes these bugs are fixed immediately and sometimes they sit there in the code festering away for months on end until someone tests a specific case.
Of course it is always best to have test suites and run them regularly against the code base, but on occasions either the test case itself has a bug,
or the test case is written in such a way that a particular bug would never present itself.
Tamagoyaki Inc. have a fairly rigorous testing procedure.
Unfortunately it would seem that one particularly nasty bug has slipped through the cracks.
Cue a difficult discussion.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"But what I don't understand John, is that you now know what happened at every step in the process.
How can something like this break and you not know about it?"
As always Markus was getting snappy and as always John was having to bite his lip.<br><br>"It's not a question about not knowing about it," begain John, "The difficulty is knowing what change introduced the problem.
We are on such a rapid development schedule that too many things are changing at once."<br><br>"Well, this is one of the reasons you guys have spent the last two months getting this version control system running."
Markus got up and opened the door.  "I suggest you fix it."<br><br> * * * <br><br>"Markus is blaming us for introducing a bug?" Rob was pretty shocked as he and Simon chatted at the water cooler.<br><br>"More like, Markus believed that a version control system was going to solve all of our problems," replied Simon.<br><br>Rob squinted his face up as a car drove into the buildings car park, showering the room with reflected sunlight.
He shielded his eyes. "You know I heard there was a tool in Git for helping to find bugs.
Think I may take a look over lunch, you know, be a real hero."<br><br>They both chuckled.
</div><hr><br>It is true that Git does have a very powerful tool for helping to detect revisions that introduced bugs into the system.
The tool is called <code class="ncode">git bisect</code> and it is used to successively checkout revisions from the repository,
check them to see if the bug is present and then use that information to determine the revision that is most likely to have introduced the bug.<br><br>Let us assume that the bug in our repository is a fairly simple one.
For some bizarre reason our codebase is broken unless the word <code class="ncode">Addition</code> is present in one of the files.
If we run a simple Linux <code class="ncode">grep</code> command across the files, we can see that the word we are after is not there.
However, if we go back to tag <strong>v1.0a</strong> and run the same command, we can see that the word is there.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;grep&nbsp;"Addition"&nbsp;*</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;v1.0a&nbsp;</code><br&nbsp;/>
<code>Note:&nbsp;checking&nbsp;out&nbsp;'v1.0a'.</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>You&nbsp;are&nbsp;in&nbsp;'detached&nbsp;HEAD'&nbsp;state.&nbsp;You&nbsp;can&nbsp;look&nbsp;around,&nbsp;make&nbsp;experimental</code><br&nbsp;/>
<code>changes&nbsp;and&nbsp;commit&nbsp;them,&nbsp;and&nbsp;you&nbsp;can&nbsp;discard&nbsp;any&nbsp;commits&nbsp;you&nbsp;make&nbsp;in&nbsp;this</code><br&nbsp;/>
<code>state&nbsp;without&nbsp;impacting&nbsp;any&nbsp;branches&nbsp;by&nbsp;performing&nbsp;another&nbsp;checkout.</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>If&nbsp;you&nbsp;want&nbsp;to&nbsp;create&nbsp;a&nbsp;new&nbsp;branch&nbsp;to&nbsp;retain&nbsp;commits&nbsp;you&nbsp;create,&nbsp;you&nbsp;may</code><br&nbsp;/>
<code>do&nbsp;so&nbsp;(now&nbsp;or&nbsp;later)&nbsp;by&nbsp;using&nbsp;-b&nbsp;with&nbsp;the&nbsp;checkout&nbsp;command&nbsp;again.&nbsp;Example:</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;new_branch_name</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>HEAD&nbsp;is&nbsp;now&nbsp;at&nbsp;a022d4d...&nbsp;Messed&nbsp;with&nbsp;a&nbsp;few&nbsp;files</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;grep&nbsp;"Addition"&nbsp;*</code><br&nbsp;/>
<code>my_third_committed_file:Addition&nbsp;to&nbsp;the&nbsp;line</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice the warning about checking out a non-branch.
This is perfectly normal and should not worry you but please be aware that it is obviously best to have a clean working directory before starting any type of <code class="ncode">bisect</code> commands.
We can see that the string we are looking for is present in the file called <code class="ncode">my_third_committed_file</code>.
As our repository is very small, it would not take us long to go through and check each revision to see when this string was deleted.
In fact we have other tools available to search for the adding and removal of strings.
For now let us assume that the <em>bug</em> is more complicated than this.<br><br>Let us go back to the facts.
We know that the repository was <strong>good</strong> at tag <strong>v1.0a</strong>.
We also know that the repository is bad in its current state.
By feeding these details to the <code class="ncode">git bisect</code> command, we can begin a search for the bug.
What will happen at each stage is that Git will checkout a revision that it wants us to test and we tell Git if we think that revision is good or bad.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;bisect&nbsp;start</code><br&nbsp;/>
<code>Already&nbsp;on&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;bisect&nbsp;good&nbsp;v1.0a</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;bisect&nbsp;bad&nbsp;master</code><br&nbsp;/>
<code>Bisecting:&nbsp;9&nbsp;revisions&nbsp;left&nbsp;to&nbsp;test&nbsp;after&nbsp;this&nbsp;(roughly&nbsp;3&nbsp;steps)</code><br&nbsp;/>
<code>[ed2301ba223a63a5a930b536a043444e019460a7]&nbsp;Removed&nbsp;third&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So we invoke the tool by running <code class="ncode">git bisect start</code>.
After this we tell Git the things that we know. It was good at <strong>v1.0a</strong>, <code class="ncode">git bisect good v1.0a</code>.
However, it was bad at <strong>master</strong>, our current revision, <code class="ncode">git bisect bad master</code>.
After this, Git checks out revision <strong>ed2301b</strong> and tells us that there are <code class="ncode">9</code> revisions between the two points and that it should take only <code class="ncode">3</code> more steps to complete.
Now we run our test again.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;grep&nbsp;"Addition"&nbsp;*</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As we have no result here, this would be classed as a bad revision and so we mark it as so.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;bisect&nbsp;bad</code><br&nbsp;/>
<code>Bisecting:&nbsp;3&nbsp;revisions&nbsp;left&nbsp;to&nbsp;test&nbsp;after&nbsp;this&nbsp;(roughly&nbsp;2&nbsp;steps)</code><br&nbsp;/>
<code>[9710177657ae00665ca8f8027b17314346a5b1c4]&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Git now presents us with a new choice and you can see that the number of revisions left to check has decreased dramatically from <code class="ncode">9</code> to <code class="ncode">3</code>.
We continue marking our revisions as good and bad.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;grep&nbsp;"Addition"&nbsp;*</code><br&nbsp;/>
<code>my_third_committed_file:Addition&nbsp;to&nbsp;the&nbsp;line</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;bisect&nbsp;good</code><br&nbsp;/>
<code>Bisecting:&nbsp;2&nbsp;revisions&nbsp;left&nbsp;to&nbsp;test&nbsp;after&nbsp;this&nbsp;(roughly&nbsp;1&nbsp;step)</code><br&nbsp;/>
<code>[cfbecabb031696a217b77b0e1285f2d5fc2ea2a3]&nbsp;Fantastic&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;grep&nbsp;"Addition"&nbsp;*</code><br&nbsp;/>
<code>my_third_committed_file:Addition&nbsp;to&nbsp;the&nbsp;line</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;bisect&nbsp;good</code><br&nbsp;/>
<code>Bisecting:&nbsp;0&nbsp;revisions&nbsp;left&nbsp;to&nbsp;test&nbsp;after&nbsp;this&nbsp;(roughly&nbsp;1&nbsp;step)</code><br&nbsp;/>
<code>[b119573f4508514c55e1c4e3bebec0ab3667d071]&nbsp;Merge&nbsp;branch&nbsp;'wonderful'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;grep&nbsp;"Addition"&nbsp;*</code><br&nbsp;/>
<code>my_third_committed_file:Addition&nbsp;to&nbsp;the&nbsp;line</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;bisect&nbsp;good</code><br&nbsp;/>
<code>ed2301ba223a63a5a930b536a043444e019460a7&nbsp;is&nbsp;the&nbsp;first&nbsp;bad&nbsp;commit</code><br&nbsp;/>
<code>commit&nbsp;ed2301ba223a63a5a930b536a043444e019460a7</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Apr&nbsp;1&nbsp;07:37:34&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;third&nbsp;file</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>:100644&nbsp;000000&nbsp;68365cc0e5909dc366d31febf5ba94a3268751c6&nbsp;0000000000000000000000000000000000000000&nbsp;D	my_third_committed_file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Oh! Something different.  Git has actually finished the bisect and has suggested to us that this commit was responsible for introducing the bug in our code.
If we look at the comment it was in this revision that we removed a particular file.
This file was the one that contained our special <code class="ncode">Addition</code> string.
Git was right! We screwed up then.  At this point we can go back to our <strong>master</strong> branch and decide what to do about it.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch&nbsp;-v</code><br&nbsp;/>
<code>*&nbsp;(no&nbsp;branch)&nbsp;b119573&nbsp;Merge&nbsp;branch&nbsp;'wonderful'</code><br&nbsp;/>
<code>&nbsp;&nbsp;develop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aed985c&nbsp;More&nbsp;new&nbsp;deving</code><br&nbsp;/>
<code>&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30900fe&nbsp;More&nbsp;new&nbsp;deving</code><br&nbsp;/>
<code>&nbsp;&nbsp;wonderful&nbsp;&nbsp;&nbsp;4d91aab&nbsp;Updated&nbsp;another&nbsp;file&nbsp;again</code><br&nbsp;/>
<code>&nbsp;&nbsp;zaney&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7cc32db&nbsp;Made&nbsp;another&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Previous&nbsp;HEAD&nbsp;position&nbsp;was&nbsp;b119573...&nbsp;Merge&nbsp;branch&nbsp;'wonderful'</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice that at the end of the bisect, Git does not return us to the master branch.
We are left in the last tested checked out revision.<br><h3>Automating the process</h3>
So bisecting is a very powerful way of quickly and efficiently finding the point at which bugs were introduced or regression testing.
Git was spot on when it suggested that that revision was the one responsible for the mistake.
Sometimes you may not be able to test a revision that Git checks out for you for other reasons.
In this case you can always run <code class="ncode">git bisect skip</code> to skip that revision.
It is all very well being able to run this at each revision Git asks us to but to be honest, if you have 30-40 steps to test and you have to compile code to see if the bug is present it can get a little bit boring.<br><br>Git has a way of allowing us to test automatically.
The example we are going to use is obviously based on a Linux environment, but if you are a developer on a Windows platform, you should have no trouble understanding what is happening here.
We are going to create a small shell script that will automatically run our grep test.
If the string is found we will exit with a status code of <code class="ncode">0</code>, indicating that it was successful and if
the string is not found, we will exit with a status code of <code class="ncode">123</code>, indicating that the test was unsuccessful.<br><br>Git will use these status codes and interpret a code of <code class="ncode">0</code> as <strong>good</strong> and a code of <code class="ncode">123</code> as <strong>bad</strong>.
Below is a copy of our shell script which we have saved as <code class="ncode">test.sh</code> and have given relevant permissions to allow it to run etc.
Notice we have had to exclude our <code class="ncode">test.sh</code> file from the test, else the string <code class="ncode">Addition</code> would have been found there.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;cat&nbsp;test.sh&nbsp;</code><br&nbsp;/>
<code>#!/bin/bash</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>if&nbsp;grep&nbsp;-q&nbsp;Addition&nbsp;*&nbsp;--exclude=test.sh</code><br&nbsp;/>
<code>&nbsp;&nbsp;then&nbsp;echo&nbsp;"Good"</code><br&nbsp;/>
<code>&nbsp;&nbsp;exit&nbsp;0</code><br&nbsp;/>
<code>else&nbsp;</code><br&nbsp;/>
<code>&nbsp;&nbsp;echo&nbsp;"Bad"</code><br&nbsp;/>
<code>&nbsp;&nbsp;exit&nbsp;123</code><br&nbsp;/>
<code>fi</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we invoke <code class="ncode">git bisect</code> slightly differently by asking it to start and itterate over the revisions <code class="ncode">master</code> to <code class="ncode">v1.0a</code>.
At this point we have not told Git anything about which revisions are good or bad.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;bisect&nbsp;start&nbsp;master&nbsp;v1.0a</code><br&nbsp;/>
<code>Bisecting:&nbsp;9&nbsp;revisions&nbsp;left&nbsp;to&nbsp;test&nbsp;after&nbsp;this&nbsp;(roughly&nbsp;3&nbsp;steps)</code><br&nbsp;/>
<code>[ed2301ba223a63a5a930b536a043444e019460a7]&nbsp;Removed&nbsp;third&nbsp;file</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we ask Git to continue testing, but to run our script at each iteration to determine the success or failure of each checked out revision.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;bisect&nbsp;run&nbsp;sh&nbsp;./test.sh</code><br&nbsp;/>
<code>running&nbsp;sh&nbsp;./test.sh</code><br&nbsp;/>
<code>Bad</code><br&nbsp;/>
<code>Bisecting:&nbsp;3&nbsp;revisions&nbsp;left&nbsp;to&nbsp;test&nbsp;after&nbsp;this&nbsp;(roughly&nbsp;2&nbsp;steps)</code><br&nbsp;/>
<code>[9710177657ae00665ca8f8027b17314346a5b1c4]&nbsp;Added&nbsp;another&nbsp;file</code><br&nbsp;/>
<code>running&nbsp;sh&nbsp;./test.sh</code><br&nbsp;/>
<code>Good</code><br&nbsp;/>
<code>Bisecting:&nbsp;2&nbsp;revisions&nbsp;left&nbsp;to&nbsp;test&nbsp;after&nbsp;this&nbsp;(roughly&nbsp;1&nbsp;step)</code><br&nbsp;/>
<code>[cfbecabb031696a217b77b0e1285f2d5fc2ea2a3]&nbsp;Fantastic&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>running&nbsp;sh&nbsp;./test.sh</code><br&nbsp;/>
<code>Good</code><br&nbsp;/>
<code>Bisecting:&nbsp;0&nbsp;revisions&nbsp;left&nbsp;to&nbsp;test&nbsp;after&nbsp;this&nbsp;(roughly&nbsp;1&nbsp;step)</code><br&nbsp;/>
<code>[b119573f4508514c55e1c4e3bebec0ab3667d071]&nbsp;Merge&nbsp;branch&nbsp;'wonderful'</code><br&nbsp;/>
<code>running&nbsp;sh&nbsp;./test.sh</code><br&nbsp;/>
<code>Good</code><br&nbsp;/>
<code>ed2301ba223a63a5a930b536a043444e019460a7&nbsp;is&nbsp;the&nbsp;first&nbsp;bad&nbsp;commit</code><br&nbsp;/>
<code>commit&nbsp;ed2301ba223a63a5a930b536a043444e019460a7</code><br&nbsp;/>
<code>Author:&nbsp;John&nbsp;Haskins&nbsp;&lt;john.haskins@tamagoyakiinc.koala&gt;</code><br&nbsp;/>
<code>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Apr&nbsp;1&nbsp;07:37:34&nbsp;2011&nbsp;+0100</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;third&nbsp;file</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>:100644&nbsp;000000&nbsp;68365cc0e5909dc366d31febf5ba94a3268751c6&nbsp;0000000000000000000000000000000000000000&nbsp;D	my_third_committed_file</code><br&nbsp;/>
<code>bisect&nbsp;run&nbsp;success</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>The parameters after the <code class="ncode">git bisect run</code> tell Git which command we wish to run at each stage.
In our case it is <code class="ncode">sh ./test.sh</code>.
You can see Git invoking our <code class="ncode">test.sh</code> script in each case, and the result of our script, either <code class="ncode">Good</code> or <code class="ncode">Bad</code> depending on which was echoed from the result of the grep test.
Git has arrived at exactly the same result, but we have had to do nothing other than write a small script.
For larger tests, this would have saved us a large amount of work.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Simon could I have a word?" It was Rob and he wasn't looking happy.<br><br>Simon turned to him and grinned, "Sure buddy what's up?"  His face dropped when he saw Rob's expression.<br><br>"I think we'd better go grab the meeting room."<br><br>Simon looked confused.<br><br>"I used the bisect tool to find the bug.  But you're not gonna like what I found."<br><br> * * * <br><br>"Simon how could you have done that?" John was asking the questions and they were coming thick and fast.
"I mean changing the API key for the web sevice whilst developing was not a great idea to start with, but committing that to the repository was rediculous."
Simon sat there with his head in his hands.
"You know how secret that API key is right?" Simon nodded.
"Simon we were supposed to be releasing this repository publically in a few weeks but now that the API is in there we can't do that."<br><br>"John I'm really sorry OK." Simon was kicking himself for his mistake.<br><br>John sighed, he had been really angry to begin with but now he was calming down,
"It's OK Simon, we're all getting used to the repository and version control.  Do you think we can fix it?"
</div><hr><br><h2>Day 3 - "Filtered repos"</h2>
<h3>Looking at a repo with rose tinted glasses</h3>
It does happen. Sometimes when people are under pressure, mistakes are made, just like earlier when we accidently deleted our branch from the repository.
This time the mistake is a little more crucial but again it does happen and it sometimes goes a long time before it is noticed.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"So it's been in there for how long?" asked John.<br><br>Simon looked pretty sheepish as he mouthed the words, "Weeks."<br><br>John bit on the end of the pen in his hand.
His teeth chewed into the plastic, deforming the blue lid.
"Did you find a way of sorting it out yet?"<br><br>"I think so. It's not ideal, but I think so."
</div><hr><br>It would be useful if we could rewrite the history to remove the information that we wanted to.
As it turns out there is a tool that we can use to do this.
The <code class="ncode">git filter-branch</code> allows us to run operations on a branch to rewrite its history.
Hopefully you are already remembering about the care we need to take when rewriting history, but sometimes there is a real need to perform some of these operations.
Let us take a look at a few examples to see how this can work.
We are going to assume that our file <code class="ncode">newfile1</code> contains some very sensitive information and we wish to remove it completely from the repository.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Already&nbsp;on&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;ls&nbsp;-la</code><br&nbsp;/>
<code>total&nbsp;40</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;&nbsp;3&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-27&nbsp;19:54&nbsp;.</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;32&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-27&nbsp;19:00&nbsp;..</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;35&nbsp;2011-07-22&nbsp;07:15&nbsp;another_file</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;25&nbsp;2011-07-22&nbsp;07:15&nbsp;cont_dev</code><br&nbsp;/>
<code>drwxrwxr-x&nbsp;&nbsp;9&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-27&nbsp;19:54&nbsp;.git</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;69&nbsp;2011-07-27&nbsp;19:54&nbsp;newfile1</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;58&nbsp;2011-07-22&nbsp;07:15&nbsp;newfile2</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;45&nbsp;2011-07-22&nbsp;07:15&nbsp;newfile3</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;2011-03-31&nbsp;22:15&nbsp;temp_file</code><br&nbsp;/>
<code>-rwxrwxr-x&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;114&nbsp;2011-07-21&nbsp;21:17&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, currently we have <code class="ncode">newfile1</code> in our tree.
We can also use the <code class="ncode">git log</code> tool to see each commit which has touched that path.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;--pretty=oneline&nbsp;master&nbsp;--&nbsp;newfile1</code><br&nbsp;/>
<code>9cb2af2a00fd2253060e6bf8cc6c377b3d55ecea&nbsp;Important&nbsp;Update</code><br&nbsp;/>
<code>d50ffb2fa536d869f2c4e89e8d6a48e0a29c5cc1&nbsp;Merged&nbsp;in&nbsp;zaney</code><br&nbsp;/>
<code>a27d49ef11d9f0e66edbad8f6c7806510ad5b2be&nbsp;Made&nbsp;an&nbsp;awesome&nbsp;change</code><br&nbsp;/>
<code>cfbecabb031696a217b77b0e1285f2d5fc2ea2a3&nbsp;Fantastic&nbsp;new&nbsp;feature</code><br&nbsp;/>
<code>55fb69f4ad26fdb6b90ac6f43431be40779962dd&nbsp;Added&nbsp;two&nbsp;new&nbsp;files</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So there were five commits in the past which have touched that path.
In our example we require the removal of this path from the entire history of the repository.
As this is a destructive operation that works on the current branch, meaning it will rewrite our branch HEAD, we are first going to switch into a new branch.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;remove_file</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;'remove_file'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we need to run the <code class="ncode">git filter-branch</code> tool.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;filter-branch&nbsp;--index-filter&nbsp;'git&nbsp;rm&nbsp;--cached&nbsp;--ignore-unmatch&nbsp;newfile1'&nbsp;HEAD</code><br&nbsp;/>
<code>Rewrite&nbsp;55fb69f4ad26fdb6b90ac6f43431be40779962dd&nbsp;(6/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;9710177657ae00665ca8f8027b17314346a5b1c4&nbsp;(7/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;4ac92012609cf8ed2480aa5d7f807caf2545fe2f&nbsp;(8/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;cfbecabb031696a217b77b0e1285f2d5fc2ea2a3&nbsp;(9/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;b119573f4508514c55e1c4e3bebec0ab3667d071&nbsp;(10/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;ed2301ba223a63a5a930b536a043444e019460a7&nbsp;(11/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;a27d49ef11d9f0e66edbad8f6c7806510ad5b2be&nbsp;(12/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;7cc32dbf121f2afa8c40337db54bafb26de5b9c4&nbsp;(13/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;d50ffb2fa536d869f2c4e89e8d6a48e0a29c5cc1&nbsp;(14/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;9cb2af2a00fd2253060e6bf8cc6c377b3d55ecea&nbsp;(15/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;37950f861a3cc0868c65ee9571fc6c491aa689ea&nbsp;(16/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;1c3206aac0fb012bfdaf5ff00e320b565bb89e7d&nbsp;(17/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;1968324ce2899883fca76bc25496bcf2b15e7011&nbsp;(18/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;f8d5100142b43ffaba9bbd539ba4fd92af79bf0e&nbsp;(19/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;a8281fb589e36389cc8cb0da7ebee225b4d1adfc&nbsp;(20/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code>Rewrite&nbsp;30900fe1b7e72411dabab8b02070f36e2431f704&nbsp;(21/21)rm&nbsp;'newfile1'</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>Ref&nbsp;'refs/heads/remove_file'&nbsp;was&nbsp;rewritten</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We have passed a few parameters to <code class="ncode">git filter-branch</code> and we should take a few seconds to discuss this as the syntax may seem a little strange.
Firstly we are invoking the <code class="ncode">git filter-branch</code> tool, that should not be anything new at all.
Next, we are passing three parameters to it.
The first of these is the type of filter we wish to use.
In our case we have used the <code class="ncode">--index-filter</code> option.
More information is available in the Git manual, but in a nutshell we have asked Git to work on the <em>index</em> at each commit stage.
There is another similar option called <code class="ncode">--tree-filter</code>, however care must be taken to distinguish between the two as using <code class="ncode">--tree-filter</code> checks out the commit at each point in history.
This may not sound like a problem, until you discover that as well as checking each revision out, it also automatically adds any untracked files in the working tree and commits them.<br><br>The next parameter is the actual command that we wish Git to perform on each revision.
In this case we want to <code class="ncode">git rm --cached --ignore-unmatch newfile1</code> each time.
We have enclosed the command we wish to run inside quotes so that Git does not get confused with which parameters are part of the <code class="ncode">filter-branch</code> and which are part of the <code class="ncode">rm</code>.
Using these options we have asked Git to work on just the <em>index</em> and not to complain if it can not find the file to delete.<br><br>Lastly we list the commit range we wish to filter.
In this case we have specified the target revision as <code class="ncode">HEAD</code>.
Git will interpret this as meaning everything up to the <code class="ncode">HEAD</code> revision.
As such Git will be rewriting the entire history of the branch.<br><br>Now if we list the files in the directory, we can see something important has happened.
The file that we wanted removed, has gone and <code class="ncode">newfile1</code> is no more.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;ls&nbsp;-la</code><br&nbsp;/>
<code>total&nbsp;36</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;&nbsp;3&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-27&nbsp;19:53&nbsp;.</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;32&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-27&nbsp;19:00&nbsp;..</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;35&nbsp;2011-07-22&nbsp;07:15&nbsp;another_file</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;25&nbsp;2011-07-22&nbsp;07:15&nbsp;cont_dev</code><br&nbsp;/>
<code>drwxrwxr-x&nbsp;&nbsp;9&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-27&nbsp;19:53&nbsp;.git</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;58&nbsp;2011-07-22&nbsp;07:15&nbsp;newfile2</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;45&nbsp;2011-07-22&nbsp;07:15&nbsp;newfile3</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;2011-03-31&nbsp;22:15&nbsp;temp_file</code><br&nbsp;/>
<code>-rwxrwxr-x&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;114&nbsp;2011-07-21&nbsp;21:17&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Re-running the log command we ran earlier against our new branch confirms our operation.
However checking out the <strong>master</strong> also confirms that the file is still present elsewhere.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;log&nbsp;--pretty=oneline&nbsp;remove_file&nbsp;--&nbsp;newfile1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;ls&nbsp;-la</code><br&nbsp;/>
<code>total&nbsp;40</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;&nbsp;3&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-27&nbsp;19:54&nbsp;.</code><br&nbsp;/>
<code>drwxr-xr-x&nbsp;32&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-27&nbsp;19:00&nbsp;..</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;35&nbsp;2011-07-22&nbsp;07:15&nbsp;another_file</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;25&nbsp;2011-07-22&nbsp;07:15&nbsp;cont_dev</code><br&nbsp;/>
<code>drwxrwxr-x&nbsp;&nbsp;9&nbsp;john&nbsp;john&nbsp;4096&nbsp;2011-07-27&nbsp;19:54&nbsp;.git</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;69&nbsp;2011-07-27&nbsp;19:54&nbsp;newfile1</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;58&nbsp;2011-07-22&nbsp;07:15&nbsp;newfile2</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;45&nbsp;2011-07-22&nbsp;07:15&nbsp;newfile3</code><br&nbsp;/>
<code>-rw-r--r--&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;2011-03-31&nbsp;22:15&nbsp;temp_file</code><br&nbsp;/>
<code>-rwxrwxr-x&nbsp;&nbsp;1&nbsp;john&nbsp;john&nbsp;&nbsp;114&nbsp;2011-07-21&nbsp;21:17&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>It should be stressed at this point how destructive the <code class="ncode">git filter-branch</code> command can be to your repository.
The <strong>master</strong> and <strong>remove_file</strong> branches have diverged from the point where <code class="ncode">newfile1</code> was first introduced.
Consequently all of our other branches, such as <strong>zaney</strong> and <strong>wonderful</strong> still refer to the <strong>master</strong> branch.
We would also have to rewrite those branches too, but because of the rewriting of commit objects, we could lose the relationships between the branches and their ancestors.
In short, though it is exceedingly powerful, this type of filtering can cause huge distress to other people working on the project.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"So what do we do?" asked John.
"We can't push out the repo as it is because it contains the API key."
He massaged his forehead moving down to his eyebrows.
"But we seem to be introducing a real headache if we filter the branch. Any suggestions?"<br><br>"Well the project is going to be finished in a few weeks right?" Simon was sitting at the end of the table.
He was ashamed and was talking through a pair of hands deperately trying to conceal his identity.<br><br>"Yeh, but what the hell has that got to do with it?" snorted Klaus.<br><br>"I'm just thinking that we leave the repo like it is until all development has finished," he paused to run his hands through his hair,
"then we filter the branch just before we release it."
He looked over at John, "At that point there shouldn't be any test or dev branches, and we can just get everyone to clone the repo if we need to do anything else."<br><br>John nodded.  "You know Simon I think you may have just redeemed yourself."
</div><hr><br><hr><div id="calloutblock"><h3>Note - Since you've been gone</h3>
Even though we have rewritten our tree, the fact that another branch still has the file present means that our potentially senitive data still exists somewhere inside the repository.
In order to truly get rid of the file we would need to not only remove the file from all branches, or delete the branches that contained the file,
but also run a few more steps if we wanted to ensure the file was gone <em>now</em>.
Be aware that these steps are potentially very destructive to a repository.
The best way to remove the file completely would be to remove ALL references to the file and then clone the repository.
Git will not clone objects into a new repository if nothing references them.
Alternatively if you absolutely must work on the current repository, you would need to do the following.<br><br>Delete the <code class="ncode">filter-branch</code> backup using <code class="ncode">git update-ref &lt;refname&gt; -d</code>.  (See the callout on <em>More backups</em>)<br><br>Expire all reflogs with <code class="ncode">git reflog expire --expire=now --all</code><br><br>Repack all of the pack files with <code class="ncode">git repack -ad</code><br><br>Prune all unreachable objects with <code class="ncode">git prune</code><br><br>As you can see some of these are quite scary procedures and so it is important that you understand all that you are doing before you do it.
</div><hr><br>The idea being proposed here is only really viable because of Tamagoyaki's situation.
The code is due to be finished soon and once that happens, the team have decided to push a rewritten branch into the public domain and to resync all of their development repositories to this new branch.
It should be noted that the <code class="ncode">filter-branch</code> tool can be used in other circumstances too.
We are going to take a look at just one of these.
However, let us first clean up our repository a little and move some things around.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;mkdir&nbsp;tester</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;ls</code><br&nbsp;/>
<code>another_file&nbsp;&nbsp;cont_dev&nbsp;&nbsp;newfile1&nbsp;&nbsp;newfile2&nbsp;&nbsp;newfile3&nbsp;&nbsp;temp_file&nbsp;&nbsp;tester&nbsp;&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;mv&nbsp;test.sh&nbsp;tester/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;mv&nbsp;newfile*&nbsp;tester</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;tester/test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;rm&nbsp;temp_file&nbsp;</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	renamed:&nbsp;&nbsp;&nbsp;&nbsp;newfile1&nbsp;-&gt;&nbsp;tester/newfile1</code><br&nbsp;/>
<code>#	renamed:&nbsp;&nbsp;&nbsp;&nbsp;newfile2&nbsp;-&gt;&nbsp;tester/newfile2</code><br&nbsp;/>
<code>#	renamed:&nbsp;&nbsp;&nbsp;&nbsp;newfile3&nbsp;-&gt;&nbsp;tester/newfile3</code><br&nbsp;/>
<code>#	new&nbsp;file:&nbsp;&nbsp;&nbsp;tester/test.sh</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Moved&nbsp;testing&nbsp;suite'</code><br&nbsp;/>
<code>[master&nbsp;f08ac57]&nbsp;Moved&nbsp;testing&nbsp;suite</code><br&nbsp;/>
<code>&nbsp;4&nbsp;files&nbsp;changed,&nbsp;9&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;rename&nbsp;newfile1&nbsp;=&gt;&nbsp;tester/newfile1&nbsp;(100&nbsp;rename&nbsp;newfile2&nbsp;=&gt;&nbsp;tester/newfile2&nbsp;(100&nbsp;rename&nbsp;newfile3&nbsp;=&gt;&nbsp;tester/newfile3&nbsp;(100&nbsp;create&nbsp;mode&nbsp;100755&nbsp;tester/test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We have reverted back to our <strong>master</strong> branch and in doing so have regained <code class="ncode">newfile1</code>.
After that, we deleted our rewritten branch and moved <code class="ncode">test.sh</code> along with all of the <code class="ncode">newfile</code>s into a new folder called <code class="ncode">tester</code>.<br><h2>Day 4 - "Let's make a library"</h2>
<h3>Splitting the atom</h3>
Sometimes, after a project has been running for a while certain components actually grow rather useful.
When this happens, people often want to move it outside of the original project and maintain it as a separate library.
Of course the easiest way to do this is to just copy and paste the files out of the main project and into a subdirectory.
In doing this we would lose or disconnect all of the development history of that subproject up to this point.<br><br>Using the <code class="ncode">git filter-branch</code> we can actually pull out a folder and retain all of its history.
The methodology behind this is that we rewrite the history to a new branch, but we only pull across changes to a particular folder and we store those in the root of the branch.
Let us see how this works with a quick example.
Remember we created the <code class="ncode">tester</code> folder?
We are going to make a few commits to the files in this folder to give it some history.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"More&nbsp;development&nbsp;work"&nbsp;&gt;&gt;&nbsp;tester/newfile1</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Work&nbsp;on&nbsp;tester&nbsp;nf1'</code><br&nbsp;/>
<code>[master&nbsp;1a4956b]&nbsp;Work&nbsp;on&nbsp;tester&nbsp;nf1</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"More&nbsp;dev&nbsp;work"&nbsp;&gt;&gt;&nbsp;tester/newfile2</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Work&nbsp;on&nbsp;tester&nbsp;nf2'</code><br&nbsp;/>
<code>[master&nbsp;7156104]&nbsp;Work&nbsp;on&nbsp;tester&nbsp;nf2</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"Even&nbsp;more&nbsp;dev&nbsp;work"&nbsp;&gt;&gt;&nbsp;tester/newfile3</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Work&nbsp;on&nbsp;tester&nbsp;nf3'</code><br&nbsp;/>
<code>[master&nbsp;1433223]&nbsp;Work&nbsp;on&nbsp;tester&nbsp;nf3</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we are going to split that off into a separate branch which we will then clone into a new Git repository.
After we have copied the history of the <code class="ncode">tester</code> folder to a new branch, see if you can run through in your head, the steps we would need to take to pull this branch into a new repository.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;tester_split</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;'tester_split'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;filter-branch&nbsp;--subdirectory-filter&nbsp;tester</code><br&nbsp;/>
<code>Rewrite&nbsp;1433223d9c8a8abc35410d12cf78128c318b6e42&nbsp;(4/4)</code><br&nbsp;/>
<code>Ref&nbsp;'refs/heads/tester_split'&nbsp;was&nbsp;rewritten</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;branch</code><br&nbsp;/>
<code>&nbsp;&nbsp;develop</code><br&nbsp;/>
<code>&nbsp;&nbsp;master</code><br&nbsp;/>
<code>*&nbsp;tester_split</code><br&nbsp;/>
<code>&nbsp;&nbsp;wonderful</code><br&nbsp;/>
<code>&nbsp;&nbsp;zaney</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;ls</code><br&nbsp;/>
<code>newfile1&nbsp;&nbsp;newfile2&nbsp;&nbsp;newfile3&nbsp;&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;ls</code><br&nbsp;/>
<code>another_file&nbsp;&nbsp;cont_dev&nbsp;&nbsp;tester</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So now the directory has been split away from the original source code into a new branch, have a think about what steps you would take to bring this into an entirely new repository.<br><hr><div id="calloutblock"><h3>Note - More backups</h3>
Git likes to make things easy for you.
You may not have noticed it before, but when using the <code class="ncode">git filter-branch</code> tool to rewrite a branch, Git keeps a backup of the value of HEAD before you started rewriting your branch.
This backup is kept in <code class="ncode">refs/original/refs/heads/&lt;branch_name&gt;</code>.
This file will contain a commit ID which we can use to revert our branch back to its original state, if the filter does horribly wrong.
</div><hr><br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"So John, I managed to split the Atom library out into a new branch like you said, but I have no idea how to pull this into a new repo."
Jack was finally feeling like he had gotten to grips with Git, but his latest task had left him feeling a little dejected.
He idly stabbed at his leg with a pen whilst waiting for John to finish his tapping away.<br><br>John lifted his keys from the keyboard and turned his chair.
"You really can't think of a way to coopy what we have in one repo into another?"<br><br>Suddenly it was like a light bulb had exploded with light inside Jack's skull.  "CLONES!" he shouted.
</div><hr><br>We actually have at least four methods we can use to do this.
<div style="padding-left:10px;"><ol><li>Copy the data from one repo to another with copy and paste</li>
<li>Clone our repository, delete all of the branches other than <strong>tester_split</strong> and then rename it to <strong>master</strong></li>
<li>Initialise a new repository, setup a remote to the original and then fetch our <strong>tester_split</strong> branch</li>
<li>Create a bundle of the <strong>tester_split</strong> and then clone from the bundle into a new repository</li>
</ol></div><br>The first of these will leave us with no history of development at all, so let us ignore it, as it is not what we require.
The second of these is trivial and should require no explanation at all.
We simply clone and then using the usual tools, we delete all unnecessary branches.
However this first method does have its disadvantages, namely the fact that when we clone the repository, we take every single object from the source repository into the new one.
Whilst this is generally not a problem it would mean that we would have to run some fairly aggressive garbage collection to remove all of these unwanted objects.
This would happen natually over time as the objects aged and were no longer referenced, but it would result in a repository that was initially much larger than it needed to be.<br><br>The other two methods deserve a little more consideration as they both perform much better in this respect.
The third method you should be familiar enough with pervious material to be able to perform right now.
However, using the fetch command as we have done so before would again pull in many more objects than we require.
As such we are going to do a subtle twist to this command in the following output.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;cd&nbsp;../</code><br&nbsp;/>
<code>john@satsuki:~$&nbsp;mkdir&nbsp;subrepo</code><br&nbsp;/>
<code>john@satsuki:~$&nbsp;cd&nbsp;subrepo/</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;git&nbsp;init</code><br&nbsp;/>
<code>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/home/john/subrepo/.git/</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;git&nbsp;remote&nbsp;add&nbsp;source&nbsp;/home/john/coderepo</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;git&nbsp;fetch&nbsp;source&nbsp;+tester_split:master</code><br&nbsp;/>
<code>fatal:&nbsp;Refusing&nbsp;to&nbsp;fetch&nbsp;into&nbsp;current&nbsp;branch&nbsp;refs/heads/master&nbsp;of&nbsp;non-bare&nbsp;repository</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;fatal:&nbsp;The&nbsp;remote&nbsp;end&nbsp;hung&nbsp;up&nbsp;unexpectedly</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>What we have asked Git to do is to pull only the branch <strong>tester_split</strong> from the remote we called <strong>source</strong> and place it into <strong>master</strong> locally.
Think of the <code class="ncode">+&lt;branch&gt;:&lt;branch&gt;</code> as <code class="ncode">+&lt;source&gt;:&lt;destination&gt;</code> and all will make sense.
As you can see Git is not too happy about our intentions here as it does not like overwriting the <strong>master</strong> branch of a non-bare repository.
That is OK, we have another way around this.<br><br><div id="codeblock"><code>john@satsuki:~/subrepo$&nbsp;git&nbsp;fetch&nbsp;source&nbsp;+tester_split:tmp</code><br&nbsp;/>
<code>remote:&nbsp;Counting&nbsp;objects:&nbsp;15,&nbsp;done.</code><br&nbsp;/>
<code>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100remote:&nbsp;Total&nbsp;15&nbsp;(delta&nbsp;3),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)</code><br&nbsp;/>
<code>Unpacking&nbsp;objects:&nbsp;100From&nbsp;/home/john/coderepo</code><br&nbsp;/>
<code>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tester_split&nbsp;-&gt;&nbsp;tmp</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;git&nbsp;branch&nbsp;-m&nbsp;tmp&nbsp;master</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So we have almost deceived Git a little here, but I think we can live with ourselves.
By first pulling the branch into a <strong>tmp</strong> branch, we were then allowed to rename it as <strong>master</strong>.
Notice the number of objects required for this branch <code class="ncode">15</code>.
If you remember when we cloned our repository a few <em>weeks</em> ago, this value was a lot higher than this.
It was the subtle <code class="ncode">+&lt;source&gt;:&lt;destination&gt;</code> which prevented us from pulling every last object from the source repository into our new slim <em>sub</em>-repository.<br><br><div id="codeblock"><code>john@satsuki:~/subrepo$&nbsp;ls</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Already&nbsp;on&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;ls</code><br&nbsp;/>
<code>newfile1&nbsp;&nbsp;newfile2&nbsp;&nbsp;newfile3&nbsp;&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Notice that there are no files in the repository until we have checked out.
This is because all the fetch did was to <em>fetch</em> the objects and place them in the repository object directory.
It did not place anything in the working directory.
If you remember this is same behaviour we saw with fetching before.
So now we have a complete copy of our <code class="ncode">tester</code> component of our repository from the source into a new repository.
If we do a <code class="ncode">git log</code>, we can see the history of the development.<br><br><div id="codeblock"><code>john@satsuki:~/subrepo$&nbsp;git&nbsp;log&nbsp;--format=oneline</code><br&nbsp;/>
<code>590e0eb79bc5ba0bc09f611392e643f676b00a04&nbsp;Work&nbsp;on&nbsp;tester&nbsp;nf3</code><br&nbsp;/>
<code>785b86d877d2a5c0679d98181a23d06ed2ba7652&nbsp;Work&nbsp;on&nbsp;tester&nbsp;nf2</code><br&nbsp;/>
<code>1ff89f787438f081a0d74de2d26eb2d831c9c738&nbsp;Work&nbsp;on&nbsp;tester&nbsp;nf1</code><br&nbsp;/>
<code>a5a0d9762dd4b50d8f3228e37b315f6056d5a034&nbsp;Moved&nbsp;testing&nbsp;suite</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Unfortunately since some of our development work on these files happened outside of this directory,
this was lost when splitting and this is something to keep in mind should you ever perform this kind of operation.<br><h3>Little bundles of joy</h3>
Git has so many ways to do things.
This is in part what makes it a little daunting for those just starting but after you have gained a little experience, you begin to understand just what is happening in the background.
When this realisation hits, you are able to almost immediately think of at least two different ways of performing the same thing.
There have been numerous examples throughout the book, where there have been multiple ways to complete the same task.
Here we are going to look at just one more way that we can create a new repo from our <strong>tester_split</strong> branch.<br><br>The tool we are going to introduce here is <code class="ncode">git bundle</code>.
The <code class="ncode">bundle</code> utility allows us to export a set of revisions and almost archive them to a file.
This file then becomes a resource that can be updated and pulled or fetched from.
This is especially useful if you have no physical connection between two computers and wish to sync some of the data from one to the other.
Let us take a quick look at how we could use the bundle tool in this case.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;bundle&nbsp;create&nbsp;../tester.bundle&nbsp;tester_split&nbsp;</code><br&nbsp;/>
<code>Counting&nbsp;objects:&nbsp;15,&nbsp;done.</code><br&nbsp;/>
<code>Compressing&nbsp;objects:&nbsp;100Writing&nbsp;objects:&nbsp;100Total&nbsp;15&nbsp;(delta&nbsp;3),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;cd&nbsp;..</code><br&nbsp;/>
<code>john@satsuki:~$&nbsp;git&nbsp;clone&nbsp;tester.bundle&nbsp;subrepo-b</code><br&nbsp;/>
<code>Cloning&nbsp;into&nbsp;subrepo-b...</code><br&nbsp;/>
<code>warning:&nbsp;remote&nbsp;HEAD&nbsp;refers&nbsp;to&nbsp;nonexistent&nbsp;ref,&nbsp;unable&nbsp;to&nbsp;checkout.</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>john@satsuki:~$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So the problem here is that when we created the bundle, the branch which was checked out at the time was <strong>master</strong>.
The objects we pulled from the source repository and placed in the bundle were all from the <strong>tester_split</strong> branch.
As such the HEAD of the working tree at the time of the bundle creation, pointed to an object in the <strong>master</strong> branch.
Obviously this object does not exist in our bundle and so Git complains.
If we had checked out <strong>tester_split</strong> before creating the bundle, there would have been no complaints.<br><br>So all we have to do is to remap the HEAD of <strong>master</strong> to that of the HEAD of <strong>tester_split</strong>.
As you can see below, it seems as if there are no branches at all and when we try to checkout master it does not exist.
What actually happened is that the objects were cloned into the repository, but as the object that the source HEAD pointed to was unavailable,
no branch was created.
With a litle <code class="ncode">git reset</code> trickery, we can create our <strong>master</strong> branch in our new repository.<br><br><div id="codeblock"><code>john@satsuki:~$&nbsp;cd&nbsp;subrepo-b/</code><br&nbsp;/>
<code>john@satsuki:~/subrepo-b$&nbsp;git&nbsp;branch</code><br&nbsp;/>
<code>john@satsuki:~/subrepo-b$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>error:&nbsp;pathspec&nbsp;'master'&nbsp;did&nbsp;not&nbsp;match&nbsp;any&nbsp;file(s)&nbsp;known&nbsp;to&nbsp;git.</code><br&nbsp;/>
<code>john@satsuki:~/subrepo-b$&nbsp;git&nbsp;reset&nbsp;--hard&nbsp;origin/tester_split&nbsp;</code><br&nbsp;/>
<code>HEAD&nbsp;is&nbsp;now&nbsp;at&nbsp;590e0eb&nbsp;Work&nbsp;on&nbsp;tester&nbsp;nf3</code><br&nbsp;/>
<code>john@satsuki:~/subrepo-b$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Already&nbsp;on&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/subrepo-b$&nbsp;ls</code><br&nbsp;/>
<code>newfile1&nbsp;&nbsp;newfile2&nbsp;&nbsp;newfile3&nbsp;&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/subrepo-b$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now we have our repository complete as before.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
Martha and John were sitting together in the office.
The rest of the team had left hours ago and it was getting really late.
Martha broke the silence, "So we've pulled the Atom library out," she giggled before continuing, "but how the heck do we put it back in again?"<br><br>"I'm really not sure said John," taking another swig of coffee before placing the mug back down on the desk.
On the side was written the word GIT in large marker pen, a gift from Klaus.<br><br>Martha sighed. "It's getting pretty late John. I think I'm gonna head out."<br><br>"Yeh, I know what you mean," started John, "I think I'll get going too.
Thanks for the help Martha."<br><br>"Anytime John."
</div><hr><br><h2>Day 5 - "Shhh....we're in a library"</h2>
<h3>Nuclear fusion</h3>
OK, so we are not quite at the stage of nuclear physics, but it would be nice to know how to bring our library back into our repository.
Git offers a tool called <code class="ncode">git submodule</code>.  This tool allows you to link a remote repositories branch and store it under a subdirectory of the project.
It does have some nuances which must be learnt, but can be very useful.
Let us add our testing suite from the <code class="ncode">subrepo</code> repository into the directory called <code class="ncode">tester</code> in our main <code class="ncode">coderepo</code> repository.
First we must remove our <code class="ncode">tester</code> directory.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;master&nbsp;</code><br&nbsp;/>
<code>Already&nbsp;on&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;rm&nbsp;tester/*</code><br&nbsp;/>
<code>rm&nbsp;'tester/newfile1'</code><br&nbsp;/>
<code>rm&nbsp;'tester/newfile2'</code><br&nbsp;/>
<code>rm&nbsp;'tester/newfile3'</code><br&nbsp;/>
<code>rm&nbsp;'tester/test.sh'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Removed&nbsp;tester&nbsp;-&nbsp;will&nbsp;be&nbsp;replaced&nbsp;by&nbsp;submodule'</code><br&nbsp;/>
<code>[master&nbsp;5698499]&nbsp;Removed&nbsp;tester&nbsp;-&nbsp;will&nbsp;be&nbsp;replaced&nbsp;by&nbsp;submodule</code><br&nbsp;/>
<code>&nbsp;4&nbsp;files&nbsp;changed,&nbsp;0&nbsp;insertions(+),&nbsp;20&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;tester/newfile1</code><br&nbsp;/>
<code>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;tester/newfile2</code><br&nbsp;/>
<code>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;tester/newfile3</code><br&nbsp;/>
<code>&nbsp;delete&nbsp;mode&nbsp;100755&nbsp;tester/test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We need to define what a submodule actualy is.
Submodules are tricky to understand and often people use them once and conclude that they are more trouble than they are worth.
However, if you take some time to understand what a submodule really is, then they can be very useful to you.
A submodule is the inclusion of a repositories branch at a specific commit.
It is not intended to track the development of the upstream library or module, (see the callout box for an explanation of <em>upstream</em>).<br><hr><div id="calloutblock"><h3>Terminology - Upstream</h3>
<em>Upstream</em> refers to the source of a project which may have one or more derivatives which are also distributed.
Take the package that was used to build this book for example, LaTeX.
LaTeX is distributed by the people who developed it as open source software, but it is also included with a number of Linux distributions.
The location of the software created by the LaTeX developers is referred to as the <em>upstream</em> project.
The projects which include it within their own are what is referred to as <em>downstream</em>.
Think of it like a river which flows from the source further <em>upstream</em>.
</div><hr><br>As we will see, though it can be a little longwinded to actually change the version of the code that the submodule refers to,
it actually makes a lot of sense to handle them in this way.
If the code in the submodule is being included in your repository, you do not want to run the risk of a change upstream resulting in a broken build for your project.
This is why submodules always refer to a single commit.<br><br>Let us go ahead, create a submodule and then discuss the steps we have taken.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;submodule&nbsp;add&nbsp;/home/john/subrepo&nbsp;tester</code><br&nbsp;/>
<code>Cloning&nbsp;into&nbsp;tester...</code><br&nbsp;/>
<code>done.</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	new&nbsp;file:&nbsp;&nbsp;&nbsp;.gitmodules</code><br&nbsp;/>
<code>#	new&nbsp;file:&nbsp;&nbsp;&nbsp;tester</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Added&nbsp;submodule&nbsp;(subrepo)'</code><br&nbsp;/>
<code>[master&nbsp;2aadc11]&nbsp;Added&nbsp;submodule&nbsp;(subrepo)</code><br&nbsp;/>
<code>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;4&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;.gitmodules</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;160000&nbsp;tester</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see we had to perform a number of steps before we obtained the source for the <strong>subrepo</strong> library in our <code class="ncode">tester</code> directory.
We had to begin by using <code class="ncode">git submodule</code> to add the upstream repository.
The upstream repository is really just like any remote repository we have been using, but we will use the terminology <em>upstream</em> to make a distinction.
The command <code class="ncode">git submodule add /home/john/subrepo tester</code> creates a special file in the root of our project called <code class="ncode">.gitmodules</code>,
plus it clones the upstream repository into the folder we specified, in this case <code class="ncode">tester</code>.<br><br>Notice that when we ran <code class="ncode">git status</code>, we saw two new entries, one for <code class="ncode">.gitmodules</code> and one for <code class="ncode">tester</code>.
Next we have to commit those entries using the standard <code class="ncode">git commit</code> command.
When we do, we see that there is a code in front of <code class="ncode">tester</code> which is special and tells Git to treat this directory as a submodule.<br><br>Though the submodule has now been added, it has not yet been initialised.
To do this, we run our next set of steps.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;submodule&nbsp;init</code><br&nbsp;/>
<code>Submodule&nbsp;'tester'&nbsp;(/home/john/subrepo)&nbsp;registered&nbsp;for&nbsp;path&nbsp;'tester'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;submodule&nbsp;update</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now our submodule has been added and initialised.
The update command is used to ensure that the directory <code class="ncode">tester</code> contains the version of the submodule that we committed earlier.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;cd&nbsp;tester/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;ls</code><br&nbsp;/>
<code>newfile1&nbsp;&nbsp;newfile2&nbsp;&nbsp;newfile3&nbsp;&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;git&nbsp;log&nbsp;--format=oneline</code><br&nbsp;/>
<code>590e0eb79bc5ba0bc09f611392e643f676b00a04&nbsp;Work&nbsp;on&nbsp;tester&nbsp;nf3</code><br&nbsp;/>
<code>785b86d877d2a5c0679d98181a23d06ed2ba7652&nbsp;Work&nbsp;on&nbsp;tester&nbsp;nf2</code><br&nbsp;/>
<code>1ff89f787438f081a0d74de2d26eb2d831c9c738&nbsp;Work&nbsp;on&nbsp;tester&nbsp;nf1</code><br&nbsp;/>
<code>a5a0d9762dd4b50d8f3228e37b315f6056d5a034&nbsp;Moved&nbsp;testing&nbsp;suite</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Looking in the directory we can see two things.
The first, is that the files present in the <strong>subrepo</strong> upstream project have now been added.
The second, may appear a little suprising to begin with.
The <code class="ncode">git log</code> command actually shows a log for the upstream project, not for the local root project stored in <code class="ncode">coderepo</code>.
In all honesty, the submodule repository is actually just a clone of the upstream project, with a few subtle differences.<br><br>The information about which upstream url to use for the project can be found in the <code class="ncode">.gitmodules</code> which we committed earlier.
Below is an example of what the file looks like in our current repository.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;cat&nbsp;.gitmodules&nbsp;</code><br&nbsp;/>
<code>[submodule&nbsp;"tester"]</code><br&nbsp;/>
<code>	path&nbsp;=&nbsp;tester</code><br&nbsp;/>
<code>	url&nbsp;=&nbsp;/home/john/subrepo</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br><h3>Changes down the river</h3>
So what happens when we want to pull in changes from the upstream project?
Well, you can make your submodule point to whatever point you like and stay there.
As long as you commit your changes in the super project, Git will always allow you to return to that point using the <code class="ncode">git submodule update</code> command.<br><br>Let us take a look at how we could pull in some changes into our <code class="ncode">tester</code> submodule.
First, we are going to make a change to our upstream project.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;cd&nbsp;..</code><br&nbsp;/>
<code>john@satsuki:~$&nbsp;cd&nbsp;subrepo</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;ls</code><br&nbsp;/>
<code>newfile1&nbsp;&nbsp;newfile2&nbsp;&nbsp;newfile3&nbsp;&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;echo&nbsp;"Added&nbsp;a&nbsp;new&nbsp;function"&nbsp;&gt;&nbsp;newfile4</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;git&nbsp;add&nbsp;newfile4</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Added&nbsp;a&nbsp;new&nbsp;library&nbsp;file'</code><br&nbsp;/>
<code>[master&nbsp;94ad27e]&nbsp;Added&nbsp;a&nbsp;new&nbsp;library&nbsp;file</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;newfile4</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$&nbsp;cd&nbsp;..</code><br&nbsp;/>
<code>john@satsuki:~/subrepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now that we have a new version of the project, let us try to pull those changes into our superproject.<br><br><div id="codeblock"><code>john@satsuki:~$&nbsp;cd&nbsp;coderepo</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;cd&nbsp;tester</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>nothing&nbsp;to&nbsp;commit&nbsp;(working&nbsp;directory&nbsp;clean)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;git&nbsp;fetch&nbsp;origin&nbsp;</code><br&nbsp;/>
<code>remote:&nbsp;Counting&nbsp;objects:&nbsp;4,&nbsp;done.</code><br&nbsp;/>
<code>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100remote:&nbsp;Total&nbsp;3&nbsp;(delta&nbsp;1),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)</code><br&nbsp;/>
<code>Unpacking&nbsp;objects:&nbsp;100From&nbsp;/home/john/subrepo</code><br&nbsp;/>
<code>&nbsp;&nbsp;&nbsp;590e0eb..94ad27e&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;origin/master</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;git&nbsp;checkout&nbsp;master&nbsp;</code><br&nbsp;/>
<code>Already&nbsp;on&nbsp;'master'</code><br&nbsp;/>
<code>Your&nbsp;branch&nbsp;is&nbsp;behind&nbsp;'origin/master'&nbsp;by&nbsp;1&nbsp;commit,&nbsp;and&nbsp;can&nbsp;be&nbsp;fast-forwarded.</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, we are told that our branch is currently one commit behind that of <strong>origin/master</strong>.
If we want to update our <strong>master</strong> branch in the submodule, we need to <em>pull</em> our changes in, just like a <strong>real</strong> Git repository.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo/tester$&nbsp;git&nbsp;pull</code><br&nbsp;/>
<code>Updating&nbsp;590e0eb..94ad27e</code><br&nbsp;/>
<code>Fast-forward</code><br&nbsp;/>
<code>&nbsp;newfile4&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;newfile4</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;ls</code><br&nbsp;/>
<code>newfile1&nbsp;&nbsp;newfile2&nbsp;&nbsp;newfile3&nbsp;&nbsp;newfile4&nbsp;&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;cd&nbsp;..</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now let us see what happens if we try to update the module.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;submodule&nbsp;update</code><br&nbsp;/>
<code>Submodule&nbsp;path&nbsp;'tester':&nbsp;checked&nbsp;out&nbsp;'590e0eb79bc5ba0bc09f611392e643f676b00a04'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;cd&nbsp;tester</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;ls</code><br&nbsp;/>
<code>newfile1&nbsp;&nbsp;newfile2&nbsp;&nbsp;newfile3&nbsp;&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Our new changes have disappeared.
How odd!
Well actually not really.
As we stated earlier, when we committed our <code class="ncode">.gitmodules</code> file along with the <code class="ncode">tester</code> directory,
we not only committed the fact that we required a submodule, we also committed the exact point we wanted that submodule to point to.
If we want to change this, then we must commit that as a change.
It may seem a little odd that we have to jump through these hoops to get an update to an upstream project, but if you think about it, it actually makes a lot of sense.
It means that anyone cloning our repository is sure to get a version of the submodule that we have decided is right for the project.
So keeping this in mind, let us walk through a quick example of how we would finish the job and commit a new version of the submodule.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;cd&nbsp;tester/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;git&nbsp;pull</code><br&nbsp;/>
<code>You&nbsp;are&nbsp;not&nbsp;currently&nbsp;on&nbsp;a&nbsp;branch,&nbsp;so&nbsp;I&nbsp;cannot&nbsp;use&nbsp;any</code><br&nbsp;/>
<code>'branch.&lt;branchname&gt;.merge'&nbsp;in&nbsp;your&nbsp;configuration&nbsp;file.</code><br&nbsp;/>
<code>Please&nbsp;specify&nbsp;which&nbsp;remote&nbsp;branch&nbsp;you&nbsp;want&nbsp;to&nbsp;use&nbsp;on&nbsp;the&nbsp;command</code><br&nbsp;/>
<code>line&nbsp;and&nbsp;try&nbsp;again&nbsp;(e.g.&nbsp;'git&nbsp;pull&nbsp;&lt;repository&gt;&nbsp;&lt;refspec&gt;').</code><br&nbsp;/>
<code>See&nbsp;git-pull(1)&nbsp;for&nbsp;details.</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Interesting!
What has happened here is that by performing the <code class="ncode">git submodule update</code> command, we effectively asked Git to checkout a commit.
Remember in the past we talked about detached HEAD?
This is exactly what Git has done. A submodule spends most of it's life in a detached HEAD state. 
As we tell Git that we must have the submodule at a specific commit, it means that Git checks out a commit, rather than a branch.
If you think about it, this makes sense, we do not want the contents of the module <em>changing</em>.<br><br>So to bring our module up to date, we need to first checkout master.
Then we can issue our <code class="ncode">git pull</code>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo/tester$&nbsp;git&nbsp;checkout&nbsp;master</code><br&nbsp;/>
<code>Previous&nbsp;HEAD&nbsp;position&nbsp;was&nbsp;590e0eb...&nbsp;Work&nbsp;on&nbsp;tester&nbsp;nf3</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;branch&nbsp;'master'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;git&nbsp;pull</code><br&nbsp;/>
<code>Already&nbsp;up-to-date.</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Oh? Should we not have seen some commits pulled in here?
Actually, no. We pulled the changes into master earlier, when we ran the <code class="ncode">git pull</code>.
When the module reverted to the earlier commit, <strong>590e0eb</strong>, it did not affect the master branch at all, as we simply checked out a single commit.
So by swiching to <strong>master</strong>, we have already altered the contents of the submodule directory, as can be seen below.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo/tester$&nbsp;ls</code><br&nbsp;/>
<code>newfile1&nbsp;&nbsp;newfile2&nbsp;&nbsp;newfile3&nbsp;&nbsp;newfile4&nbsp;&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;cd&nbsp;..</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;status</code><br&nbsp;/>
<code>#&nbsp;On&nbsp;branch&nbsp;master</code><br&nbsp;/>
<code>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)</code><br&nbsp;/>
<code>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;checkout&nbsp;--&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;discard&nbsp;changes&nbsp;in&nbsp;working&nbsp;directory)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>#	modified:&nbsp;&nbsp;&nbsp;tester&nbsp;(new&nbsp;commits)</code><br&nbsp;/>
<code>#</code><br&nbsp;/>
<code>no&nbsp;changes&nbsp;added&nbsp;to&nbsp;commit&nbsp;(use&nbsp;"git&nbsp;add"&nbsp;and/or&nbsp;"git&nbsp;commit&nbsp;-a")</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>All we need to do now is to commit the submodule changes into the repository and check that the update yields the new file.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Up&nbsp;revd&nbsp;upstream&nbsp;module'</code><br&nbsp;/>
<code>[master&nbsp;022a163]&nbsp;Up&nbsp;revd&nbsp;upstream&nbsp;module</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;submodule&nbsp;update</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;cd&nbsp;tester/</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;ls</code><br&nbsp;/>
<code>newfile1&nbsp;&nbsp;newfile2&nbsp;&nbsp;newfile3&nbsp;&nbsp;newfile4&nbsp;&nbsp;test.sh</code><br&nbsp;/>
<code>john@satsuki:~/coderepo/tester$&nbsp;cd&nbsp;..</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>As you can see, submodules can be rather useful.
You can even make changes to the repository in the submodule and commit them locally to perhaps keep changes that you want to make to the submodule.
Remember though that if you did make changes, and you committed them to the submodule,
if you then issued a <code class="ncode">git submodule update</code> without first committing your changes in the superproject, your commit would be lost.
Of course nothing in Git is ever really lost, but it would be prudent of you to always keep changes you make to submodules in a branch,
that way they are easy to bring back if you make a mistake like the one described.<br><br>With that all said and done, we have finished our tour of the major portions of Git.
What follows in the next chapter are some other points that are added more for information on what <strong>can</strong> be done with Git.<br><br><br><h2>Summary - John's Notes</h2>
<h3>Commands</h3>
<div style="padding-left:10px;"><ul><li><code class="ncode">git apply &lt;filename&gt;</code> - Applies a patch to the working tree</li>
<li><code class="ncode">git reflog show &lt;branch&gt;</code> - Show the reflog only for the specified branch</li>
<li><code class="ncode">git format-patch &lt;ref1&gt;..&lt;ref2&gt;</code> - Create a set of patches of each commit between two points</li>
<li><code class="ncode">git am &lt;filename&gt;</code> - Apply a specific patch containing a <em>format-patch</em> file</li>
<li><code class="ncode">git bisect start</code> - Begin a bisect session</li>
<li><code class="ncode">git bisect good &lt;ref&gt;</code> - Mark a reference as good, during a <code class="ncode">git bisect</code></li>
<li><code class="ncode">git bisect bad &lt;ref&gt;</code> - Mark a reference as bad, during a <code class="ncode">git bisect</code></li>
<li><code class="ncode">git bisect start &lt;ref_recent&gt; &lt;ref_old&gt;</code> - Start a bisect session between two known points</li>
<li><code class="ncode">git bisect run &lt;command&gt;</code> - Start an automated run of the bisect tool</li>
<li><code class="ncode">git filter-branch --index-filter 'git rm --cached  --ignore-unmatch &lt;file&gt;' HEAD</code> - Rewrites the current branch to remove file</li>
<li><code class="ncode">git filter-branch --subdirectory-filter &lt;directory&gt;</code> - Rewrites the current branch to make subdirectory directory the root of the branch</li>
<li><code class="ncode">git fetch &lt;remote&gt; +&lt;remote_branch&gt;:&lt;local_branch&gt;</code> - Creates a local branch from the remote branch existing in a remote repository</li>
<li><code class="ncode">git branch -m &lt;old_branch&gt; &lt;new_branch&gt;</code> - Move or rename a branch from old to ne</li>
<li><code class="ncode">git bundle create &lt;filename&gt; &lt;branch&gt;</code> - Create a bundle file in filename, containing all the objects and references from branch.</li>
<li><code class="ncode">git submodule add &lt;repo&gt; &lt;path&gt;</code> - Add a submodule at the directory specified by path</li>
<li><code class="ncode">git submodule init</code> - Initialise any submodules in the super project</li>
<li><code class="ncode">git submodule update</code> - Pull all submodules back to the points that have previously been committed to</li>
</ul></div><br><h3>Terminology</h3>
<div style="padding-left:10px;"><ul><li><strong>Patching</strong> - A method of distributing changes from someone elses repository without having a line of communication between the two,
or without a user having access to commit into the destination repository</li>
<li><strong>Bundle</strong> - A type of archive file that hold objects and commits and can be pulled from</li>
<li><strong>Bisect</strong> - A way of progressively searching through a repository to find where bugs were introduced</li>
<li><strong>Filtering</strong> - Takes a branch and rewrites it according to a set of rules</li>
<li><strong>Submodule</strong> - Incorporating a remotely reachable project as a subdirectory of a superproject</li>
<li><strong>Superproject</strong> - A Git repository containing one or more submodules</li>
</ul></div>

<h1>After Hours Week 8</h1>
<h2>"Fishing for beginners"</h2>
<h3>Hooking your scripts up</h3>
So we come to the last After Hours section of the book and this time we are going to take a look at hook scripts.
Hook scripts are tiny pieces of code that you are allowed to have executed at certain points during Git's processes which can affect the outcome of those same processes.
Imagine for example that whenever you committed to a repository you wanted an email to be sent to the project manager.
That is a job for a hook script.<br><br>The are a fairly large number of hook points available.
They are called hooks because it allows you to hook something else into the Git process.
Below is a list of a few of the available hook points along with a very brief description of when they are triggered and how they can affect the process.
For a full list, you should check out the manual for githooks.<br><div style="padding-left:10px;"><ul><li><strong>applypatch-msg</strong> - Invoked by <code class="ncode">git am</code>, it is provided with the name of the proposed commit message for the patch and allows for sanitisation.
Exiting with a non-zero status will cause <code class="ncode">git am</code> to abort the patch.
Will run the <strong>commit-msg</strong> hook if enabled.</li>
<li><strong>pre-applypatch</strong> - Invoked by <code class="ncode">git am</code>, it runs immediately after the patch is applied, but before a commit is made.
In this way, checks can be made to the working tree before committing.
Exiting with non-zero status aborts the commit.
Will run the <strong>pre-commit</strong> hook if enabled.</li>
<li><strong>post-applypatch</strong> - Invoked by <code class="ncode">git am</code>, it runs after the patch is applied and the commit is made.
It does not affect the flow of <code class="ncode">git am</code> and as such is useful for actions such as notifications.</li>
<li><strong>pre-commit</strong> - This hook is invoked by <code class="ncode">git commit</code> and can be bypassed with the <code class="ncode">--no-verify</code> option.
Exiting with non-zero status aborts the commit.</li>
<li><strong>prepare-commit-msg</strong> - This hook is invoked by <code class="ncode">git commit</code> and is run immediately after the commit message has been prepared, but before the message editor has been loaded.
It takes three parameters, the file containing the log message, the source of the commit message and an SHA hash.
Exiting with non-zero status aborts the commit.
It should not be used to replace <strong>pre-commit</strong>.</li>
<li><strong>commit-msg</strong> - This hook is invoked by <code class="ncode">git commit</code> and can be bypassed with the <code class="ncode">--no-verify</code> option.
The hook is used to normalise messages in place before commit.
Exiting with non-zero status aborts the commit.</li>
<li><strong>post-commit</strong> - Invoked by <code class="ncode">git commit</code>, it runs immediately after a commit is made.
It can not affect the flow of <code class="ncode">git commit</code> and as such is useful for actions such as notifications.</li>
<li><strong>pre-rebase</strong> - Invoked by <code class="ncode">git rebase</code>, it is useful for preventing a branch from being rebased.</li>
<li><strong>post-checkout</strong> - Invoked by <code class="ncode">git checkout</code> after it has updated the working tree.
The hook is given the ref of the previous HEAD, the new HEAD and a flag indicating if it was a branch or file checkout.
It is also invoked after <code class="ncode">git clone</code>, but can be overidden by the use of <code class="ncode">--no-checkout</code>.
The script is most useful for performing sanity and validity checks on the working tree post checkout.
It does not affect the process of <code class="ncode">git clone</code> or <code class="ncode">git checkout</code></li>
<li><strong>post-merge</strong> - Invoked by <code class="ncode">git merge</code> when run as part of a <code class="ncode">git pull</code>.
It does not affect the outcome of the merge, but does not get executed if the merge fails due to conflicts.</li>
</ul></div><br>So we have a large arsenal of hooks that we can employ to assist us in administrating our repository.
We are going to set up a fairly simple example here of ensuring that we do not delete one of our core files.
To begin with, let us add a <code class="ncode">corefile</code> to the repository in a new branch and play a little with a new hook script.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;hooktest</code><br&nbsp;/>
<code>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;'hooktest'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"Very&nbsp;Important&nbsp;File"&nbsp;&gt;&nbsp;corefile</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;add&nbsp;corefile</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Added&nbsp;Core&nbsp;File'</code><br&nbsp;/>
<code>[hooktest&nbsp;96fe8b9]&nbsp;Added&nbsp;Core&nbsp;File</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;corefile</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now let us create a hook script called <code class="ncode">.git/hooks/pre-commit</code>, with the following code.<br><br><div id="codeblock"><code>#!/bin/bash</code><br&nbsp;/>
<code></code><br&nbsp;/>
<code>if&nbsp;[&nbsp;-e&nbsp;"corefile"&nbsp;]&nbsp;</code><br&nbsp;/>
<code>then</code><br&nbsp;/>
<code>	echo&nbsp;"File&nbsp;OK"</code><br&nbsp;/>
<code>	exit&nbsp;0</code><br&nbsp;/>
<code>else</code><br&nbsp;/>
<code>	echo&nbsp;"File&nbsp;Deleted&nbsp;Not&nbsp;Committing"</code><br&nbsp;/>
<code>	exit&nbsp;2</code><br&nbsp;/>
<code>fi</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Now let us see what happens if we make a commit that does not affect the <code class="ncode">corefile</code>.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"New&nbsp;Development"&nbsp;&gt;&gt;&nbsp;cont_dev&nbsp;</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Added&nbsp;a&nbsp;commit'</code><br&nbsp;/>
<code>File&nbsp;OK</code><br&nbsp;/>
<code>[hooktest&nbsp;73656f2]&nbsp;Added&nbsp;a&nbsp;commit</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We see the text <code class="ncode">File OK</code> in the output, which indicates that the commit is allowed to go ahead.
What happens if we try to remove the core file and commit the result?<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;rm&nbsp;corefile</code><br&nbsp;/>
<code>rm&nbsp;'corefile'</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Removed&nbsp;a&nbsp;corefile'</code><br&nbsp;/>
<code>File&nbsp;Deleted&nbsp;Not&nbsp;Committing</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>We have been prevented from committing because we removed the all important <code class="ncode">corefile</code>.
To be able to commit again, we must return the file.<br><br><div id="codeblock"><code>john@satsuki:~/coderepo$&nbsp;git&nbsp;checkout&nbsp;HEAD&nbsp;--&nbsp;corefile</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;ls</code><br&nbsp;/>
<code>another_file&nbsp;&nbsp;cont_dev&nbsp;&nbsp;corefile&nbsp;&nbsp;tester</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;echo&nbsp;"New&nbsp;development"&nbsp;&gt;&gt;&nbsp;cont_dev&nbsp;</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'Some&nbsp;more&nbsp;development'</code><br&nbsp;/>
<code>File&nbsp;OK</code><br&nbsp;/>
<code>[hooktest&nbsp;6786dd5]&nbsp;Some&nbsp;more&nbsp;development</code><br&nbsp;/>
<code>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)</code><br&nbsp;/>
<code>john@satsuki:~/coderepo$</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>So you see hooks can be really simple, or they can do highly complex things.
Imagine a hook that would compile the code in the working tree prior to the commit and only allow it to continue if the code compiled cleanly.
That could be pretty useful in ensuring that there is always good clean buildable code in the repository.


<h1>A little extra help</h1>
<h2>Taking things further</h2>
We have completed our journey through eight weeks of intensive version control usage at Tamagoyaki Inc.
However, there are probably still many questions that you have regarding Git and its usage.
This chapter focusses on taking a few of the topics that were discussed a little further but does not go into as much detail as was presented in the rest of the book.
The reason for this is purely that as the tasks you are trying to achieve become more complex, they often require greater knowledge about the implementation details
and are often heavily customised to fit a particular scenario.
Also, some of the topics are rather specialised and are not of use to everybody, so taking a large amount of time discussing them may be a little redundant for the majority of the people reading the book.<br><br>If you have read through weeks 1-8, and supplemented it with the After Hours sections, you should have a very good understanding of the Git system.
As with most things practice makes perfect and it is important to play with any new system before using it in earnest.
If you are planning to migrate away from an existing version control system, take some time to test your current processes and procedures in Git to ensure that it will fit your needs.
Always keep in mind that no matter which system you try to introduce, there will nearly always be resistance from someone.<br><br>So let us touch on a few more topics and just wrap up a few loose ends.<br><h3>Collaborating with a larger audience</h3>
We looked at a few tools within the Git system to allow access to a Git repository, but what if you want to share your repository with a larger audience.
As stated earlier, the implementation of the tools in our testing was suitable for merely that, testing.
In a production environment one would should never use the instaweb tool for a providing a permanent setup where people can browse a repository over HTTP.<br><br>There are two distinct methods for handling the distribution of Git repositories to larger audiences.
Generally people will either, set up the server themselves or use a third party system to host their repositories.<br><h4>GitHub</h4>
No book on Git would be complete without at least a small section on GitHub.
GitHub is a third party site for hosting and interacting with Git repositories.
All of the information about GitHub is correct at the time of going to print.<br><br>GitHub offers the ability to host both public and private repositories.
Public repositories can be hosted for free, whereas private repositories require a subscription fee, however the pricing is tiered to allow you to start small and gradually grow your usage.
Repositories can be pulled via HTTPS, SSH and Git protocols which allows you to be entirely flexible in the methods you use to keep up to date.
Pushing to the repositories can be achieved via HTTPS or SSH, which again is rather flexible.<br><br>The real beauty of GitHub is how it is presented.
GitHub has a tagline of <em>Social Coding</em> and it really does live up to that name.
People can fork your project, which basically means they have cloned it to their account in GitHub.
Whenever they make commits to their fork, you can see these changes pop up in a section of the site called Network.<br><br>GitHub also allows you to edit files directly on the site and commit them.
This means that wherever you are, as long as you have a connection to the Internet and a browser, you can edit files in your repository and commit them.
When you return home, you can issue a pull and the changes will appear on your local system.<br><br>For open source projects, GitHub really does offer a wealth of features for collaborative coding.
When a collaborator has made enough changes to fix a bug or a feature, they can issue a pull request.
This sends a notification to you that Person X would like you to merge their changes into your branch.
If there are no conflicts these pull requests can be manage straight from GitHub, without requiring you to checkout the remote branch, merge it and push it back again.
You can also comment on lines in the diff and many more features.<br><br>Indeed during the writing of this book, several contributors used GitHub to make pull requests containing spelling mistakes and design suggestions.<br><h4>Hosting yourself</h4>
Many people choose to host themselves, be it for security or control reasons.
Sometimes people do not want to have their data <em>online</em> and prefer to keep it internal to the company, this may be due to IP, license or other restrictions.
However, it should be noted that this option does not pose a problem to the implementation of Git.
Though you may not have access to the fancy interface features of GitHub, you still get the raw power of Git in your workplace.<br><br>Apache is a common implementation of Git for companies as it is a robust webserver which offers the ability to serve and receive data through HTTP and HTTPS with a Git repository.
We are not going to go into the implementation details of such a set up as each one is different.
There are many tutorials on the Internet that deal with such set ups in different situations and for different purposes.<br><br>SSH is also a good choice for implementing a Git repository and there are several means of securing the Git repository to allow only certain users access to certain paths etc.
Git by default does not really have a security access control layer but then that is realy by design more than anything else.
Git was intended to be used by open source projects to share and collaborate on code.
However, this does not mean it can not be used on closed source projects, just that sometimes some modifications need to be made if more advanced features like access control are required.
Many people rely on the work flow processes to ensure that things are done in a secure manner.
If you have a blessed repository and have some dictators who are responsible for integrating code into it, it should be up to them to ensure that Developer X does not try to commit changes to Module Y.<br><h3>Taking out the garbage</h3>
Something that we glossed over is the subject of garbage collection.
Git handles this for us, routinely deleting objects that are older than a certain time period from the object database, as long as they are no longer referenced by any branches.
So by this we mean that an object that exists only in one branch will only remain imune to garbage collection whilst that branch is alive.
As soon as we delete the branch, all objects that are not longer referred to in any tree are left in a <em>dangling</em> state and may be deleted when garbage collection runs.
Of course as stated earlier, Git holds on to objects for a period of time for you, to make sure you do not do anything silly, like delete a branch you actually really wanted.<br><br>***Running manual gc***<br><h3>But how do you really know....you know?</h3>
When obtaining source code via an insecure means, over the Internet for example,
there are times when you would really like to be as sure as possible that someone has not tampered with it.
Let us take an example of someone distributing their content using a Git repository.
An attacker takes control of the repository, puts in some malware and tags the commit as release version 1.0.
People start do download it and as you can imagine all hell breaks loose.<br><br>It does not have to be this way.
Many developers and Internet users use GPG to encrypt and sign their emails and documents.
GPG is a tool which can be employed to both encrypt files so that they can only be read by the intended recipient, or to sign documents and files, such that you can be reasonably sure that document is the same as when the person signed it.
The private GPG <em>key</em> of the signing party is used along with the file to generate a code which is sent along with the email.
When it reaches the recipient a check can be made against the users public key and the content of the email, to validate that said user did actually sign that particular document or file.<br><br>Git allows you to use GPG signing for tags.
This gives people piece of mind that unless an attacker has gained access to both the repository and the developers private GPG key, if the sign a tag, that tag is exactly as it was intended.
To use Git in this way, you must first set up a GPG key, which is out of scope of this book.
Once you have this key, you can change your config like the example below, to tell Git to use a particular key when signing.<br><br><div id="codeblock"><code>git&nbsp;config&nbsp;user.signingkey&nbsp;0xABCDEFG</code><br&nbsp;/>
<code></code><br&nbsp;/>
</div><br>Then when you want to sign a tag, simply append the <code class="ncode">-s</code> parameter to the <code class="ncode">git tag</code> command.
You can also verify someone elses signed tag by running <code class="ncode">git tag -v &lt;tagname&gt;</code><br><h2>The end of the journey</h2>
Well we have reached the end of our journey.
We have taken a look at many of the aspects of both Git and the mechanisms by which it can be used.
As the workflow of actually using Git is so open, you will have to decide for yourself how you want to collaborate with others.
Do not worry if you do not get it right first time.
Try a test repository and make up scenarios, just like we have in the book, to test your workflows.<br><br>Using a version control system is not an exact science and should never be something that people dislike so much that they resent using it.
A good implementation of a version control system invents minimal work for the users, whilst giving themall the benefits we have desribed throughout.
Remember if your users dislike the system, the chances are they will not use it properly and sometimes will try at every stage to avoid it.
Help them to understand why you are using a version control system and get them onside early.
You will find the procedure will be much less painless.<br><br>Before we sign off for good, let us take one more trip back to the trenches to see how things panned out.<br><hr><div id="trenchblock"><strong>In the trenches...</strong><br>
"Well I have to say guys there were points during this project that I didn't think we'd ever complete it" said Markus with a grin on his face.
The rest of the team all smiled, including Klaus.<br><br>"It wasn't the easiest thing we've ever done," started John, "but it sure has helped us out in so many ways."
Markus grinned, "Well ya big bunch of gits, hows about we head off early today and take a trip to the pub.  First round is on me."<br><br>The room roared with shouts and cheers as they began to file out of the room, gather their things and head towards the Dog and Duck.<br><br> * * * <br><br>The team had been in the pub for well over two hours and several of Tamagoyaki Inc's were beginning to feel the effects of the consumption of alcohol.
Martha and John had broken away from the rest of the pack and were sat on a table on their own.
It hadn't been intentional, but their conversation hadn't seemed to fit with the rest of the team.<br><br>"Thanks for all the help John," started Martha, "You've been really good to me."<br><br>"Hey! I'm just glad you're on my team." he replied. "We certainly couldn't have done it without you."<br><br>At that point the effects of the alchopop were too much for Martha.
Her cheeks began to flush a bright shade of red, and in a totally out of character manouver she leant across the table and kissed John.<br><br>The rest of the team caught a glimpse of the events taking place in the isolated environment and cheered loudly.<br><br>"Geee, it's about time," jeered Klaus.
</div><hr><br>

